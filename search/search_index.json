{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Xians.ai Docs <p>Enterprise-grade Agent Development Kit for building AI agents.</p> Get Started View Examples Architecture <p>Understand the foundations and components of the Xians.ai platform</p> Start Reading Quick Start <p>Begin your agent development journey with our comprehensive setup guides</p> Start Setting Up"},{"location":"#key-features","title":"Key Features","text":"Enterprise-Grade <p>Workflow Engine - Built on temporal.io for fault-tolerant, scalable execution with enterprise reliability and performance.</p> Multi-Agent Systems <p>Collaborative Teams - Create agent teams with peer-to-peer communication, handoffs, and sophisticated coordination.</p> Event-Driven <p>Modern Architecture - Seamless agent communication through sophisticated event mechanisms and real-time messaging.</p> Comprehensive Tooling <p>Rich Ecosystem - Extensive tools and libraries for extending agent capabilities and building complex workflows.</p> Management Platform <p>Full-Featured Portal - Complete web interface for agent management, monitoring, and knowledge administration.</p> Platform Agnostic <p>No Vendor Lock-in - Works with any LLM provider, cloud platform, or infrastructure setup you choose.</p> Ready to build enterprise AI agents? <p>Join enterprise teams developing next-generation AI automation solutions</p> Start Building Now \u2192"},{"location":"0-architecture/1-why-xians-platform/","title":"Why Agentic Software is Different?","text":"<p>Future software will be very different to Conventional software created so far.</p> <p>There are 3 areas of main differences:</p>"},{"location":"0-architecture/1-why-xians-platform/#1-drive-of-process","title":"1. Drive of Process","text":"Traditional Software Agentic Software (Xians Platform) Users drive the business processes forward (doer role) AI agents self-drive the process with defined goals Manual process execution and decision-making Autonomous process execution and optimization Human-centric workflow management Users take on approver role when needed Users responsible for each step of the process AI involves users strategically rather than for every step Goal-oriented automation with human oversight"},{"location":"0-architecture/1-why-xians-platform/#autonomous-process-execution-in-xians","title":"Autonomous Process Execution in Xians","text":"<p>The platform provides several technical capabilities that enable AI agents to drive processes autonomously:</p> <ul> <li>Enterprise-Grade Workflow Engine: Built on temporal.io, providing fault-tolerant, long-running process execution that can operate for months or years</li> <li>Multi-Agent Systems: Peer-to-peer agent collaboration where agents coordinate complex tasks through explicit workflows or emergent cooperation. Agents communicate through sophisticated event mechanisms enabling complex coordination without tight coupling</li> <li>Flow Types: Support for both deterministic business processes and non-deterministic conversational flows, enabling different levels of autonomy based on requirements</li> </ul>"},{"location":"0-architecture/1-why-xians-platform/#2-system-evolution","title":"2. System Evolution","text":"Traditional Software Agentic Software (Xians Platform) Static intelligence systems Dynamic learning systems Rule-based engines with fixed logic Agent-environment feedback loops Intelligence remains unchanged unless software/data is manually upgraded Continuous learning, adjustment, and improvement Predetermined decision paths and responses Adaptive intelligence that evolves through experience State and reward-based optimization Self-improving capabilities over time"},{"location":"0-architecture/1-why-xians-platform/#adaptive-intelligence-in-xians","title":"Adaptive Intelligence in Xians","text":"<p>Technical features that support continuous learning and adaptation:</p> <ul> <li>Knowledge Management System: Dynamic knowledge bases that can be updated without code changes, allowing agents to evolve their behavior through the portal interface as well as through the API.</li> <li>Agent Memory Types: CAG Knowledge Prompts (Cache Augmented Generation), RAG (Retrieval Augmented Generation), and Cache-Memory are built in for Agents to use.</li> <li>Capabilities Framework: Extensible tool ecosystem where agents can acquire new abilities through MCPs, custom capabilities, third-party libraries, or other agents as tools</li> </ul>"},{"location":"0-architecture/1-why-xians-platform/#3-user-interaction","title":"3. User Interaction","text":"Traditional Software Agentic Software (Xians Platform) Users often misused as data entry operators Users engage through natural and adaptive means Form-based interfaces and manual input requirements AI reaches out through user's preferred channels of choice Limited interaction paradigms Multi-modal communication (Teams, Gmail, Phone, etc.) Technology-centric user experience Context-aware and personalized interactions Human-centric communication patterns"},{"location":"0-architecture/1-why-xians-platform/#architecture-requirements","title":"Architecture Requirements","text":"<p>To support these capabilities a new type of architecture is needed. This is where agentic platform architecture comes into play.</p>"},{"location":"0-architecture/1-why-xians-platform/#natural-user-interaction-in-xians","title":"Natural User Interaction in Xians","text":"<p>Platform features that enable human-centric communication:</p> <ul> <li>Multi-Channel Communication: Native integration with WebSocket (Real time), REST APIs (Synchronous and Asynchronous), and webhooks (Listens to events and messages) for reaching users through their preferred channels</li> <li>Agent Handoffs: Seamless transfer of conversations between specialized agents when different expertise is required</li> <li>Agent Hierarchies: Support for agent hierarchies, where agents can be grouped into teams and sub-teams, and can be assigned to different levels of the hierarchy</li> <li>Sophisticated Message Passing: Structured conversation management with support for both text (<code>Chat</code>) and structured data (<code>Data</code>) communication</li> </ul> <p>These technical capabilities work together to enable the fundamental shift from traditional software patterns to autonomous, adaptive, and naturally interactive agentic systems.</p>"},{"location":"0-architecture/2-platform-components/","title":"Xians Platform Components","text":""},{"location":"0-architecture/2-platform-components/#primary-platform-components","title":"Primary Platform Components","text":""},{"location":"0-architecture/2-platform-components/#xians-web-sdk","title":"Xians Web SDK","text":"<ul> <li>Github Repository</li> <li>NPM Package</li> </ul> <p>This helps developers to easily communicate with Agents from their web front ends. It is a wrapper around the Xians server's Websocket, REST and SSE APIs and provides a simple interface to interact with the agents. If someone wishes to bypass the SDK and directly communicate with the server, they can use the Xians Server APIs.</p>"},{"location":"0-architecture/2-platform-components/#xians-server","title":"Xians Server","text":"<ul> <li>Github Repository</li> <li>Docker Images</li> </ul> <p>This is the core of the Xians Platform. It is a server that manages the communication, agents, workflows, and other components of the platform.</p>"},{"location":"0-architecture/2-platform-components/#xians-agent-lib","title":"Xians Agent Lib","text":"<ul> <li>Github Repository</li> <li>NuGet Package</li> </ul> <p>Agents are developed as commandline applications. This library provides the ability for the agents to communicate with the Users, Xians server and fellow agents.</p>"},{"location":"0-architecture/2-platform-components/#xians-agent-portal","title":"Xians Agent Portal","text":"<ul> <li>Github Repository</li> <li>Docker Image</li> </ul> <p>This is the portal that allows the users to manage and monitor the agents.</p>"},{"location":"0-architecture/3-xians-core-features/","title":"Xians Platform Features","text":"<p>Xians Platform is an open-source &amp; LLM-agnostic framework for building AI agents. It provides a set of tools and libraries for building agents, as well as a management platform for deploying and monitoring agents.</p>"},{"location":"0-architecture/3-xians-core-features/#core-features","title":"Core Features","text":""},{"location":"0-architecture/3-xians-core-features/#enterprise-grade-workflow-engine","title":"Enterprise-Grade Workflow Engine","text":"<p>Xians ADK leverages temporal.io workflow engine to execute agent activities, making your applications fault-tolerant, scalable, and capable of managing long-running processes that can operate for months or years. Combine generative orchestration with deterministic workflows to create applications that are both adaptive and produce consistent, reliable results.</p>"},{"location":"0-architecture/3-xians-core-features/#sophisticated-agent-architecture","title":"Sophisticated Agent Architecture","text":"<p>Design agents using familiar software development patterns. Support true multi-agent systems with peer-to-peer agent handoffs as well as hierarchical agent team collaboration where agents are aware of each other's capabilities. This structured approach makes agent creation more predictable and maintainable while supporting both assistive and autonomous execution modes to suit your business requirements.</p> <p>Coordinate complex tasks through explicit workflows or emergent agent cooperation. Xians enables peer-to-peer agent handoffs and team-based collaboration where agents are aware of each other's capabilities.</p>"},{"location":"0-architecture/3-xians-core-features/#event-driven-agent-communication","title":"Event-Driven Agent Communication","text":"<p>User-2-Agent and Agent-2-Agent communication is seamless through sophisticated communication mechanisms (WebSockets, REST, SSE), enabling complex coordination without tight coupling.</p>"},{"location":"0-architecture/3-xians-core-features/#agent-resource-management","title":"Agent Resource Management","text":"<p>Xians ADK includes a full-featured Agent Management Portal and built-in Agent run UI, providing total visibility into agent definitions, processes, activities, logs, and a knowledge management portal for agent use. This comprehensive platform approach eliminates the need to build custom interfaces for agent management. Monitor and debug your agents with comprehensive tracing, logging, and evaluation capabilities.</p>"},{"location":"0-architecture/3-xians-core-features/#multi-tenant-support","title":"Multi-Tenant Support","text":"<p>Built from the ground up for multi-tenancy, Xians ADK is the most suitable platform for sophisticated product development and enterprise deployments where isolation and customization per tenant are critical requirements.</p>"},{"location":"0-architecture/3-xians-core-features/#flexible-deployment","title":"Flexible Deployment","text":"<p>Deploy your agents anywhere with our flexible deployment options. Run locally during development, scale in cloud environments, or integrate into existing infrastructure with container support and standardized interfaces. Xians ADK ensures no vendor lock-in, whether to a specific LLM model, provider, or cloud platform.</p>"},{"location":"0-architecture/3-xians-core-features/#enterprise-ready-security","title":"Enterprise-Ready Security","text":"<p>Build agents that meet organizational requirements with our security-first design. Implement fine-grained permissions, input validation, and output filtering to create trustworthy AI systems.</p>"},{"location":"0-architecture/3-xians-core-features/#next-steps","title":"Next Steps","text":"<ul> <li>Setting up</li> </ul>"},{"location":"1-getting-started/0-platform-setup/","title":"Platform Setup","text":"<p>To develop agentic software with the Xians platform, you'll need to set up the platform locally on your development machine. This local setup provides all the necessary infrastructure components required for agent development and testing.</p>"},{"location":"1-getting-started/0-platform-setup/#quick-setup-with-docker-compose","title":"Quick Setup with Docker Compose","text":"<p>The fastest and most reliable way to get started is using the Docker Compose setup from the Xians community edition. This setup includes all the essential components:</p> <ul> <li>Xians Server - Core platform API and orchestration</li> <li>Xians UI - Web-based management interface</li> <li>Temporal - Workflow orchestration engine</li> <li>Keycloak - Authentication and authorization</li> <li>Database components - Data persistence layer</li> </ul>"},{"location":"1-getting-started/0-platform-setup/#getting-started","title":"Getting Started","text":"<p>For complete setup instructions, system requirements, and configuration options, visit the official community edition repository:</p> <p>XiansAi Platform - Community Edition</p> <p>The repository provides:</p> <ul> <li>One-command setup scripts</li> <li>Environment configuration options</li> <li>Access URLs for all platform components</li> <li>Troubleshooting guidance</li> </ul>"},{"location":"1-getting-started/0-platform-setup/#important-notes","title":"Important Notes","text":"<ul> <li>The community edition is designed for development and testing only</li> <li>Requires Docker and Docker Compose</li> <li>Minimum 8GB RAM recommended</li> <li>Ensure you have an OpenAI API key for LLM capabilities</li> </ul> <p>Once your platform is running locally, you can proceed to create your first agent and begin developing agentic workflows.</p>"},{"location":"1-getting-started/1-agent-project-setting-up/","title":"Setting Up an Agent Project","text":""},{"location":"1-getting-started/1-agent-project-setting-up/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have installed:</p> <ul> <li>.NET 9 SDK</li> </ul>"},{"location":"1-getting-started/1-agent-project-setting-up/#creating-your-project","title":"Creating Your Project","text":"<p>Xians.ai agents run as standard .NET applications, which can be executed locally or deployed to any server environment. Let's create a new project:</p> <pre><code>dotnet new console -n &lt;Agent-Name&gt;\ncd &lt;Agent-Name&gt;\n</code></pre>"},{"location":"1-getting-started/1-agent-project-setting-up/#installing-the-sdk","title":"Installing the SDK","text":"<p>Add the Xians.ai SDK to your project:</p> <pre><code>dotnet add package XiansAi.Lib\n</code></pre>"},{"location":"1-getting-started/1-agent-project-setting-up/#agent-configuration","title":"Agent Configuration","text":"<p>Your agent needs to be configured with the agent server. This is done by obtaining the required settings from the Xians.ai portal's <code>Tenant Settings</code> page.</p> <p></p> <p>You should configure these settings in one of the following 3 ways in your <code>Program.cs</code> file:</p>"},{"location":"1-getting-started/1-agent-project-setting-up/#configuration-alternative-1-hardcode-values","title":"Configuration alternative 1 (hardcode values)","text":"<p>In your program.cs file, you can configure the platform by setting the following environment variables:</p> <p><code>Program.cs &gt;</code></p> <pre><code>using XiansAi;\n\n// manually set the app server url and api key\nPlatformConfig.APP_SERVER_URL = \"https://api.xians.ai\";\nPlatformConfig.APP_SERVER_API_KEY = \"your-api-key\";\n</code></pre>"},{"location":"1-getting-started/1-agent-project-setting-up/#configuration-alternative-2-using-env-file","title":"Configuration alternative 2 (using .env file)","text":"<p>For better security and maintainability, you may use a .env file to manage your configuration: You can use a package like DotNetEnv to load the environment variables from the <code>.env</code> file without hardcoding them in your code.</p> <p>Install the DotNetEnv package:</p> <pre><code>dotnet add package DotNetEnv\n</code></pre> <p>Create a <code>.env</code> file in the root of your project with the following content:</p> <pre><code># Platform environment variables\nAPP_SERVER_URL=https://api.xians.ai\nAPP_SERVER_API_KEY=your-api-key\n</code></pre> <p><code>Program.cs &gt;</code></p> <pre><code>using DotNetEnv;\n\n// Load the environment variables from the .env file\nEnv.Load();\n</code></pre>"},{"location":"1-getting-started/1-agent-project-setting-up/#next-steps","title":"Next Steps","text":"<ul> <li>First Agent</li> </ul>"},{"location":"1-getting-started/2-first-agent/","title":"Your First Conversational Flow","text":"<p>AI agent could have a multiple workflows. However in this example, we will create a simple agent with a single Flow which is a conversation bot.</p>"},{"location":"1-getting-started/2-first-agent/#creating-a-conversational-flow","title":"Creating a Conversational Flow","text":"<p>Update your Program.cs: <code>Program.cs &gt;</code></p> <pre><code>using XiansAi.Flow;\nusing DotNetEnv;\n\n// Load the environment variables from the .env file\nEnv.Load();\n\n// name your agent\nvar agent = new AgentTeam(\"News Agent\");\n\nvar bot = agent.AddAgent&lt;NewsReaderBot&gt;();\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"1-getting-started/2-first-agent/#add-a-conversation-bot-to-the-agent","title":"Add a conversation bot to the agent","text":"<p>Agents can be configured to have multiple workflows (business processes). One type of workflow is a conversation bot. This is a bot that can be used to interact with the users.</p> <p>To add a conversation bot to the agent, you need to add a new class to the agent project.</p> <p><code>NewsReaderBot.cs&gt;</code></p> <pre><code>using Temporalio.Workflows;\nusing XiansAi.Flow;\n\n[Workflow(\"News Agent:News Reader Bot\")]\npublic class NewsReaderBot : FlowBase\n{\n    public NewsReaderBot(){\n        SystemPrompt = \"You are a news reader bot.\";\n    }\n\n    [WorkflowRun]\n    public async Task Run()\n    {\n        await InitConversation();\n    }\n}\n</code></pre> <p>Important</p> <p>Bot and Flow names must follow the naming convention <code>&lt;agent-name&gt;:&lt;flow-name&gt;</code>. </p> <p>In the example above, <code>\"News Agent:News Reader Bot\"</code> uses the agent name \"News Agent\" followed by a colon and the specific flow name \"News Reader Bot\". This ensures proper organization and identification of flows within your agent.</p> <p>Notes:</p> <ul> <li> <p>The <code>[WorkflowRun]</code> and <code>[Workflow]</code> attributes are required to mark the method as the entry points for the workflow. You can see more about the Temporal.io workflow engine here.</p> </li> <li> <p>InitConversation is a method that initializes the conversation with the user. It is a method that is provided by the XiansAi.Flow library.</p> </li> <li> <p>The InitConversation function is designed for flexibility and supports two usage patterns:</p> <ul> <li>Providing a system prompt (string): Users can directly pass a system prompt to define the initial context or instructions for the conversation.</li> <li>Providing a knowledge object: Users can specify a Knowledge object that includes a knowledge name, allowing the conversation to be initialized based on a predefined knowledge base or content source.</li> </ul> </li> </ul>"},{"location":"1-getting-started/2-first-agent/#testing-your-setup","title":"Testing Your Setup","text":"<p>Important</p> <p>If you get a warning about another user using the same agent, you should change the agent name to something else.</p> <p>One tenant can have only one agent with the same name. </p> <p>For example, <code>News Agent</code> is already taken, so you should use <code>News Reader Agent - xyz</code> or something like that.</p> <p>Run the application requesting to test the configuration:</p> <pre><code>dotnet run\n</code></pre> <p>If no errors occur, your agent is now deployed to the Xians.ai platform.</p> <p>Note: You will have a <code>Warning</code> which we will fix in the next step.</p> <p>Log in to the Xians.ai Manager portal and you will see your agent under <code>Agent Definitions</code>.</p> <p></p> <p>Click <code>Activate</code> and activate a Singleton Flow Run.</p> <p>Now in the <code>Messaging</code> playground you can start a conversation with your agent.</p> <p></p> <p>You can see the conversation history and the agent's response.</p>"},{"location":"1-getting-started/2-first-agent/#visualizing-the-flows-logic","title":"Visualizing the Flow's Logic","text":"<p>You may have noted the <code>Warning</code> in the previous step. Also the disabled <code>Visualize</code> button in the portal.</p> <p>This is because the flow class file is not included in deployed package. Let's fix this.</p> <p>Add the following in your .csproj file:</p> <pre><code>&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;\n...\n\n  &lt;ItemGroup&gt;\n    &lt;!-- Embed the flow source files --&gt;\n    &lt;EmbeddedResource Include=\"NewsReaderBot.cs\"&gt;\n        &lt;LogicalName&gt;%(Filename)%(Extension)&lt;/LogicalName&gt;\n    &lt;/EmbeddedResource&gt;\n  &lt;/ItemGroup&gt;\n\n&lt;/Project&gt;\n</code></pre> <p>Now you can run the agent again and you will see the <code>Visualize</code> button enabled in the portal.</p> <pre><code>dotnet run\n</code></pre> <p>You will see the <code>Visualize</code> button enabled in the portal.</p> <p></p> <p>Click the <code>Visualize</code> button and you will see the flow's logic.</p>"},{"location":"1-getting-started/2-first-agent/#conversational-flows-are-non-deterministic","title":"Conversational Flows are Non-Deterministic","text":"<p>Non-deterministic flows don't follow a predefined path that executes the same way each time. Instead, the flow's execution is determined at runtime, leveraging AI models and available data to make decisions about next steps. Unlike deterministic processes where every step must be explicitly modeled beforehand, non-deterministic flows adapt dynamically. This approach offers several advantages:</p> <ul> <li>Faster development: Reduced need for extensive process design and testing</li> <li>Improved accessibility: Business users can automate processes without deep technical expertise</li> <li>Enhanced personalization: Flows can adapt to individual user needs and contexts</li> <li>Greater flexibility: The system can handle complex scenarios that would be difficult to model explicitly</li> </ul> <p>In deterministic systems, processes that can't be fully defined in advance typically require human intervention. Non-deterministic flows can increase automation in these scenarios, such as customer support, content generation, or decision-making tasks that traditionally needed human judgment.</p> <p>However, non-deterministic flows also present challenges, including less predictable behavior, potentially higher execution costs, and more complex auditing requirements. If the business process is well-known and requires repeatable results, then a deterministic flow is a better choice.</p> <p>To learn about deterministic flows, please refer to Process Automation.</p>"},{"location":"1-getting-started/2-first-agent/#next-steps","title":"Next Steps","text":"<ul> <li>Adding Capabilities</li> </ul>"},{"location":"1-getting-started/3-adding-capabilities/","title":"Adding Capabilities to Your Bot","text":"<p>Capabilities are function calls that can be executed upon user request. They extend your bot's functionality, allowing it to perform specific actions or access particular services.</p>"},{"location":"1-getting-started/3-adding-capabilities/#ways-to-add-capabilities","title":"Ways to Add Capabilities","text":"<p>You can add capabilities to your bot in two ways:</p> <ol> <li>By creating a new class that implements the capability</li> <li>Through the Model Configuration Protocol (MCP)</li> </ol> <p>In this guide, we'll focus on the first approach: adding a capability through a new class.</p>"},{"location":"1-getting-started/3-adding-capabilities/#adding-a-capability-class","title":"Adding a Capability Class","text":"<ol> <li>Create a new class file in your agent project</li> <li>Implement the required functions for capabilities</li> <li>Describe the functions that will be available to the bot</li> </ol> <p>Here's an example of a simple capability class using static methods:</p> <pre><code>using XiansAi.Flow.Router.Plugins;\n\npublic static class Capabilities\n{    \n    [Capability(\"Get latest news headlines\")]\n    [Parameter(\"count\", \"Number of news items to show (default: 5)\")]\n    [Returns(\"List of recent news headlines\")]\n    public static List&lt;object&gt; GetLatestNewsHeadlines(int count = 5)\n    {\n        var news = new List&lt;object&gt;\n        {\n            new \n            {\n                title = \"News 1\",\n                summary = \"Summary 1\"\n            },\n            new \n            {\n                title = \"News 2\",\n                summary = \"Summary 2\"\n            }\n        };\n\n        return news;\n    }\n\n    [Capability(\"Search news for a specific term\")]\n    [Parameter(\"searchTerm\", \"Term to search for in news headlines and summaries\")]\n    [Parameter(\"count\", \"Number of news items to show (default: 5)\")]\n    [Returns(\"List of news items containing the search term\")]\n    public static List&lt;object&gt; SearchNews(string searchTerm, int count = 5)\n    {\n        var news = new List&lt;object&gt;\n        {\n            new \n            {\n                title = \"News 1\",\n                summary = \"Summary 1\"\n            },\n            new \n            {\n                title = \"News 2\",\n                summary = \"Summary 2\"\n            }\n        };\n\n        return news;\n    }\n}\n</code></pre>"},{"location":"1-getting-started/3-adding-capabilities/#accessing-messagethread-in-capabilities","title":"Accessing MessageThread in Capabilities","text":"<p>Often, you'll need access to the <code>MessageThread</code> of the conversation within your capability class. This is particularly useful when you need to:</p> <ul> <li>Forward messages to other bots</li> <li>Send responses back to the user</li> <li>Access conversation context and history</li> </ul> <p>To access the <code>MessageThread</code>, implement a constructor in your capability class that accepts a <code>MessageThread</code> parameter:</p> <pre><code>using XiansAi.Flow.Router.Plugins;\nusing XiansAi.Messaging;\n\npublic class AssistantBotCapabilities\n{    \n    private readonly MessageThread _messageThread;\n\n    public AssistantBotCapabilities(MessageThread messageThread)\n    {\n        this._messageThread = messageThread;\n    }\n\n    [Capability(\"Perform a web search\")]\n    [Parameter(\"query\", \"Query to perform a web search\")]\n    [Returns(\"Results of the web search\")]\n    public async Task&lt;string?&gt; PerformWebSearch(string query)\n    {\n        var response = await _messageThread.ForwardMessage(typeof(WebBot), query);\n        return response.Text;\n    }\n\n    [Capability(\"Get user conversation history\")]\n    [Parameter(\"count\", \"Number of recent messages to retrieve (default: 10)\")]\n    [Returns(\"List of recent conversation messages\")]\n    public async Task&lt;List&lt;object&gt;&gt; GetConversationHistory(int count = 10)\n    {\n        // Access message thread properties and methods\n        var messages = await _messageThread.GetRecentMessages(count);\n        return messages.Select(m =&gt; new { \n            text = m.Text, \n            timestamp = m.Timestamp,\n            sender = m.Sender \n        }).ToList();\n    }\n}\n</code></pre>"},{"location":"1-getting-started/3-adding-capabilities/#configure-the-bot-to-use-the-new-capability","title":"Configure the Bot to Use the New Capability","text":"<p>Register your capability class in your bot's configuration.</p>"},{"location":"1-getting-started/3-adding-capabilities/#for-static-capability-classes","title":"For Static Capability Classes","text":"<pre><code>using XiansAi.Flow;\nusing DotNetEnv;\n\n// Load the environment variables from the .env file\nEnv.Load();\n\n// name your agent\nvar agent = new AgentTeam(\"News Reader Agent\");\n\nvar bot = agent.AddAgent&lt;NewsReaderBot&gt;();\nbot.AddCapabilities(typeof(Capabilities));\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"1-getting-started/3-adding-capabilities/#for-non-static-capability-classes-with-messagethread","title":"For Non-Static Capability Classes (with MessageThread)","text":"<p>When using capability classes that require <code>MessageThread</code> injection, use the generic method:</p> <pre><code>using XiansAi.Flow;\nusing DotNetEnv;\n\n// Load the environment variables from the .env file\nEnv.Load();\n\n// name your agent\nvar agent = new AgentTeam(\"Assistant Agent\");\n\nvar bot = agent.AddAgent&lt;AssistantBot&gt;();\nbot.AddCapabilities&lt;AssistantBotCapabilities&gt;();\n\nawait agent.RunAsync();\n</code></pre> <p>The framework will automatically inject the <code>MessageThread</code> instance into your capability class constructor.</p>"},{"location":"1-getting-started/3-adding-capabilities/#when-to-use-each-approach","title":"When to Use Each Approach","text":"<p>Use Static Methods when:</p> <ul> <li>Your capabilities don't need to interact with the conversation thread</li> <li>You're performing simple data processing or calculations</li> <li>You're calling external APIs without needing conversation context</li> </ul> <p>Use MessageThread Injection when:</p> <ul> <li>You need to forward messages to other bots</li> <li>You want to send responses back to the user from within the capability</li> <li>You need access to conversation history or context</li> <li>You're implementing complex conversational flows within capabilities</li> </ul>"},{"location":"1-getting-started/3-adding-capabilities/#testing-the-new-capability","title":"Testing the New Capability","text":"<p>After deploying your updated bot, you can test the capability by:</p> <ol> <li>Opening your bot in the portal</li> <li>Requesting the bot to use the capability, for example:</li> <li>\"What are the latest news headlines?\"</li> <li>\"Search for news about AI\"</li> </ol> <p>The bot should recognize these requests and invoke your capability's <code>GetLatestNewsHeadlines</code> or <code>SearchNews</code> method with the appropriate parameters.</p>"},{"location":"1-getting-started/3-adding-capabilities/#real-world-implementations","title":"Real World Implementations","text":"<p>In a real world implementation, you would use a news API to get the latest news headlines and search for news about a specific term. Capabilities are running as Temporal activities, and therefore you can use any IO operation to get the data you need.</p> <pre><code>    [Capability(\"Search news for a specific term\")]\n    [Parameter(\"searchTerm\", \"Term to search for in news headlines and summaries\")]\n    [Parameter(\"count\", \"Number of news items to show (default: 5)\")]\n    [Returns(\"List of news items containing the search term\")]\n    public static async Task&lt;string&gt; SearchNews(string searchTerm, int count = 5)\n    {\n        try\n        {\n            var jsonResponse = await GetNewsData($\"?q={Uri.EscapeDataString(searchTerm)}&amp;limit={count}\");\n            return FormatNewsResults(jsonResponse, count);\n        }\n        catch (Exception ex)\n        {\n            Console.Error.WriteLine($\"Failed to search news for '{searchTerm}'. Error: {ex.Message}\");\n            Console.Error.WriteLine(ex.StackTrace);\n            return $\"Failed to search news for '{searchTerm}'. Error: {ex.Message}\";\n        }\n    }\n    private static async Task&lt;JsonDocument&gt; GetNewsData(string queryParams = \"\")\n    {\n        string url = NEWS_API_URL + queryParams;\n        HttpResponseMessage response = await _httpClient.GetAsync(url);\n        response.EnsureSuccessStatusCode();\n        return await JsonDocument.ParseAsync(await response.Content.ReadAsStreamAsync());\n    }\n</code></pre>"},{"location":"1-getting-started/3-adding-capabilities/#best-practices","title":"Best Practices","text":"<ul> <li>Keep capabilities focused on specific functionality</li> <li>Use descriptive names for your capability methods</li> <li>Include proper documentation using XML comments</li> <li>Implement proper error handling in your capability methods</li> <li>Consider adding validation for input parameters</li> </ul>"},{"location":"1-getting-started/3-adding-capabilities/#next-steps","title":"Next Steps","text":"<ul> <li>New Business Process</li> </ul>"},{"location":"1-getting-started/4-new-business-process/","title":"Developing a Business Process Flow (Deterministic)","text":""},{"location":"1-getting-started/4-new-business-process/#what-is-a-deterministic-flow","title":"What is a Deterministic Flow?","text":"<p>Deterministic flows follow a predefined path that executes the same way each time. With deterministic process orchestration, what happens during each process execution is determined ahead of time, usually through a business process model. Given the same inputs, configuration, environment, and conditions, the process will always follow the same sequence of steps and yield the same results.</p> <p>Deterministic process orchestration offers several benefits:</p> <ul> <li>Predictability and reproducibility, making processes easy to audit</li> <li>Visual process models that help teams explain and collaborate on process design</li> <li>Self-documenting nature when using BPMN - what you see is exactly what will be executed</li> <li>Relatively low execution costs and typically fast performance</li> </ul> <p>However, deterministic flows also present challenges:</p> <ul> <li>Require thorough understanding and agreement on business processes, which many organizations struggle with</li> <li>Process model creation takes time and requires testing</li> <li>Difficult to deliver highly personalized experiences without maintaining many model variations</li> </ul> <p>If the business process is well-known and requires consistent, repeatable results, then a deterministic flow is an excellent choice.</p>"},{"location":"1-getting-started/4-new-business-process/#intelligence-at-activity-level","title":"Intelligence at Activity Level","text":"<p>While maintaining the deterministic nature of the overall process flow, it's possible to incorporate AI intelligence at the individual activity level. This hybrid approach leverages the predictability of deterministic processes while enhancing specific activities with the reasoning capabilities of Large Language Models (LLMs).</p> <p>For example:</p> <ul> <li>Document processing: An activity that needs to understand and extract information from emails, invoices, or contracts can use LLMs to intelligently parse unstructured content, even when formats vary.</li> <li>Data analysis: Activities requiring classification, summarization, or sentiment analysis can leverage LLMs to provide nuanced interpretations of text data.</li> <li>Decision support: When processes involve evaluating complex information (like candidate CVs or customer feedback), LLMs can assist by providing reasoned analysis while keeping the process flow itself deterministic.</li> <li>Content enrichment: Activities that need to enhance or transform content (such as product descriptions or knowledge base articles) can use LLMs to generate improvements.</li> </ul> <p>The key advantage of this approach is that you retain the reliability, auditability, and predictable execution of deterministic workflows while gaining the cognitive capabilities of AI at critical points in your process. Process activities become intelligent nodes within your deterministic framework, capable of handling unstructured data and complex reasoning tasks without sacrificing the overall control and predictability of your business process.</p>"},{"location":"1-getting-started/4-new-business-process/#creating-a-business-process-flow","title":"Creating a Business Process Flow","text":"<p>Update your Program.cs: <code>Program.cs &gt;</code></p> <pre><code>using XiansAi.Flow;\nusing DotNetEnv;\n\n// Load the environment variables from the .env file\nEnv.Load();\n\n// name your agent\nvar agent = new AgentTeam(\"News Reader Agent\");\n\nvar flow = agent.AddAgent&lt;NewsReportFlow&gt;();\nflow.AddActivities&lt;Activities&gt;(new Activities());\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"1-getting-started/4-new-business-process/#add-the-new-business-process-flow","title":"Add the new business process flow","text":"<p><code>NewsReportFlow.cs&gt;</code></p> <pre><code>using Microsoft.Extensions.Logging;\nusing Temporalio.Workflows;\nusing XiansAi.Flow;\n\n[Workflow(\"News Agent:News Report Flow\")]\npublic class NewsReportFlow : FlowBase\n{\n  private int count = 0;\n\n  [WorkflowRun]\n  public async Task&lt;string&gt; Run(string newsUrl, string recipientEmail)\n  {\n    count++;\n    Workflow.ExecuteActivityAsync(\n      (Activities a) =&gt; a.WriteToFile($\"Hello, world {count}\"),\n      new() { ScheduleToCloseTimeout = TimeSpan.FromMinutes(1) });\n  }\n}\n\n\npublic class Activities\n{\n    [Activity]\n    public void WriteToFile(string message)\n    {\n        Console.WriteLine(message);\n        File.WriteAllText(\"user-request.txt\", message);\n    }\n}\n</code></pre> <p>Notes:</p> <ul> <li>The Xians Flows are Temporal workflows. You can see more about the Temporal.io workflow engine here. You can simply use all the Temporal workflow features in your flows.</li> <li>More details about the Developing Business Process Flows with Xians engine can be found here.</li> </ul>"},{"location":"1-getting-started/5-adding-activities/","title":"Adding Activities to Your Flow (deprecated)","text":"<p>Activities are the individual steps in a business process flow. They are the building blocks of the flow. We will use the following activities in our flow:</p> <ul> <li>ExtractContentFromUrlAsync: Extracts the content from a URL</li> <li>CreateTextReportAsync: Creates a text report from the content</li> <li>SendEmailReportAsync: Sends the text report to the recipient</li> </ul>"},{"location":"1-getting-started/5-adding-activities/#temporal-workflows-and-activities","title":"Temporal Workflows and Activities","text":"<p>Temporal workflows have an important constraint: they cannot perform I/O operations directly. This means you cannot make HTTP requests, read files, or perform any other external operations directly within a workflow. This restriction exists because workflows must be deterministic - they must produce the same sequence of commands when replayed, regardless of when they are executed.</p> <p>Instead, all I/O operations must be performed through activities. Activities are the building blocks that handle all external interactions and I/O operations. They can:</p> <ul> <li>Make HTTP requests</li> <li>Read/write files</li> <li>Send emails</li> <li>Interact with databases</li> <li>Perform any other external operations</li> </ul> <p>This separation ensures that workflows remain deterministic while still allowing your application to interact with the outside world through activities.</p>"},{"location":"1-getting-started/5-adding-activities/#writing-the-activity-code","title":"Writing the Activity Code","text":"<p>Create a new file <code>NewsActivities.cs</code> and add the following code:</p> <p><code>NewsActivities.cs &gt;</code></p> <pre><code>using Temporalio.Activities;\n\ninterface INewsActivities\n{\n    [Activity]\n    Task&lt;string&gt; ExtractContentFromUrlAsync(string url);\n    [Activity]\n    Task&lt;string&gt; CreateTextReportAsync(string content);\n    [Activity]\n    Task SendEmailReportAsync(string reportText, string recipientEmail = \"recipient@example.com\");\n}\n\npublic class NewsActivities : INewsActivities\n{\n\n\n    public Task&lt;string&gt; ExtractContentFromUrlAsync(string url)\n    {\n        Console.WriteLine($\"Extracting content from URL: {url}\");\n        // Dummy implementation - would actually call a service to extract content\n        return Task.FromResult($\"Extracted content from {url}\");\n    }\n\n    public Task&lt;string&gt; CreateTextReportAsync(string content)\n    {\n        Console.WriteLine($\"Creating text report from content: {content.Substring(0, Math.Min(50, content.Length))}\");\n        // Dummy implementation - would actually format the content into a report\n        string reportText = $\"NEWS REPORT\\n\\nDate: {DateTime.Now}\\n\\nCONTENT:\\n{content}\\n\\nEND OF REPORT\";\n        Console.WriteLine(\"Text report created successfully\");\n        return Task.FromResult(reportText);\n    }\n\n    public Task SendEmailReportAsync(string reportText, string recipientEmail = \"recipient@example.com\")\n    {\n        Console.WriteLine($\"Sending email with text report to {recipientEmail}\");\n        Console.WriteLine($\"Report length: {reportText.Length} characters\");\n        // Dummy implementation - would actually send an email with the report text\n        return Task.CompletedTask;\n    }\n}\n</code></pre>"},{"location":"1-getting-started/5-adding-activities/#calling-the-activities-from-the-flow","title":"Calling the Activities from the Flow","text":"<p>Use Temporal.io Workflow.ExecuteActivityAsync to call the above activities from the flow.</p> <p><code>NewsReportFlow.cs &gt;</code></p> <pre><code>using Microsoft.Extensions.Logging;\nusing Temporalio.Workflows;\nusing XiansAi.Flow;\n\n[Workflow(\"News Report Flow\")]\npublic class NewsReportFlow : FlowBase\n{\n    private readonly ActivityOptions _activityOptions = new()\n    {\n        ScheduleToCloseTimeout = TimeSpan.FromMinutes(5)\n    };\n\n    [WorkflowRun]\n    public async Task&lt;string&gt; Run(string newsUrl, string recipientEmail)\n    {\n        Workflow.Logger.LogInformation(\"Starting News Report Flow for URL: {Url}\", newsUrl);\n\n        // Step 1: Extract content from the URL\n        var content = await Workflow.ExecuteActivityAsync(\n            (INewsActivities act) =&gt; act.ExtractContentFromUrlAsync(newsUrl), _activityOptions);\n\n        Workflow.Logger.LogInformation(\"Content extracted successfully\");\n\n        // Step 2: Create a text report from the content\n        var reportText = await Workflow.ExecuteActivityAsync(\n            (INewsActivities act) =&gt; act.CreateTextReportAsync(content), _activityOptions);\n\n        Workflow.Logger.LogInformation(\"Text report created successfully\");\n\n        // Step 3: Send an email with the text report\n        await Workflow.ExecuteActivityAsync(\n            (INewsActivities act) =&gt; act.SendEmailReportAsync(reportText, recipientEmail), _activityOptions);\n\n        Workflow.Logger.LogInformation(\"Email sent successfully to: {RecipientEmail}\", recipientEmail);\n\n        return reportText;\n    }\n}\n</code></pre>"},{"location":"1-getting-started/5-adding-activities/#adding-the-activities-to-the-flow","title":"Adding the Activities to the Flow","text":"<p>Update <code>Program.cs</code> to include the activities:</p> <p><code>Program.cs &gt;</code></p> <pre><code>using XiansAi.Flow;\nusing DotNetEnv;\n\n// Load the environment variables from the .env file\nEnv.Load();\n\n// name your agent\nvar agent = new AgentTeam(\"News Reader Agent\");\n\nvar flow = agent.AddAgent&lt;NewsReportFlow&gt;();\nflow.AddActivities&lt;INewsActivities, NewsActivities&gt;();\n\nvar bot = agent.AddAgent&lt;NewsReaderBot&gt;();\nbot.AddCapabilities(typeof(Capabilities));\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"1-getting-started/5-adding-activities/#running-the-flow","title":"Running the Flow","text":"<p>Now you can run the flow again to see the activities in action.</p> <pre><code>dotnet run\n</code></pre> <p>Now on the portal, navigate to <code>Agent Definitions</code> and <code>Activate</code> a flow. Then observe the workflow getting executed under <code>Agent Runs</code> tab.</p>"},{"location":"2-agent-communication/1-events/","title":"Events Between Agent Flows","text":"<p>Events provide a powerful mechanism for communication between different flows in the XiansAI system. This document explains how to implement event-based communication between flows.</p>"},{"location":"2-agent-communication/1-events/#overview","title":"Overview","text":"<p>Events in XiansAI allow flows to:</p> <ul> <li>Send events to other flows</li> <li>Subscribe to and handle events from other flows</li> <li>Pass data between flows asynchronously</li> </ul>"},{"location":"2-agent-communication/1-events/#sending-events","title":"Sending Events","text":"<p>To send an event from one flow to another, use the <code>MessageHub.SendFlowMessage</code> method. Here's how to implement it:</p> <pre><code>using XiansAi.Messaging;\n\n// Define an event payload class\npublic class NewsReportRequest\n{\n    [JsonPropertyName(\"url\")]\n    public required string Url { get; set; }\n\n    [JsonPropertyName(\"recipientEmail\")]\n    public required string RecipientEmail { get; set; }\n}\n\n// Send an event\nMessageHub.SendFlowMessage(\n    typeof(NewsReportFlow),  // Target flow type\n    new NewsReportRequest {  // Event payload\n        Url = url, \n        RecipientEmail = recipientEmail \n    }\n);\n</code></pre>"},{"location":"2-agent-communication/1-events/#receiving-events","title":"Receiving Events","text":"<p>To receive events in a flow, subscribe to them in the flow's constructor using the <code>_messageHub.SubscribeFlowMessageHandler</code> method:</p> <pre><code>using XiansAi.Flow;\n\npublic class NewsReportFlow : FlowBase\n{\n    private readonly Queue&lt;NewsReportRequest&gt; _newsRequests = new Queue&lt;NewsReportRequest&gt;();\n\n    public NewsReportFlow()\n    {\n        _messageHub.SubscribeAsyncFlowMessageHandler&lt;NewsReportRequest&gt;(async (args) =&gt;\n        {\n            if (args.Payload != null)\n            {\n                _newsRequests.Enqueue(args.Payload);\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/1-events/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing how two flows can communicate using events:</p> <ol> <li>Sending Flow (Capabilities.cs):</li> </ol> <pre><code>using XiansAi.Flow.Router.Plugins;\nusing XiansAi.Messaging;\n\n[Capability(\"Send summary report\")]\n[Parameter(\"url\", \"URL of the news article\")]\n[Parameter(\"recipientEmail\", \"Email address of the recipient\")]\n[Returns(\"Success message\")]\npublic static string SendSummaryReport(string url, string recipientEmail)\n{\n    MessageHub.SendFlowMessage(\n        typeof(NewsReportFlow), \n        new NewsReportRequest { Url = url, RecipientEmail = recipientEmail }\n    );\n    return \"Success\";\n}\n</code></pre> <ol> <li>Receiving Flow (NewsReportFlow.cs):</li> </ol> <pre><code>using XiansAi.Flow;\nusing XiansAi.Messaging;\n\n[Workflow(\"News Report Flow\")]\npublic class NewsReportFlow : FlowBase\n{\n    private readonly Queue&lt;NewsReportRequest&gt; _newsRequests = new Queue&lt;NewsReportRequest&gt;();\n\n    public NewsReportFlow()\n    {\n        _messageHub.SubscribeAsyncFlowMessageHandler&lt;NewsReportRequest&gt;(async (args) =&gt;\n        {\n            if (args.Payload != null)\n            {\n                _newsRequests.Enqueue(args.Payload);\n            }\n        });\n    }\n\n    [WorkflowRun]\n    public async Task&lt;string&gt; Run()\n    {\n        // Wait for events to arrive\n        await Workflow.WaitConditionAsync(() =&gt; _newsRequests.Count &gt; 0);\n        var request = _newsRequests.Dequeue();\n\n        // Process the event...\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/1-events/#event-flow","title":"Event Flow","text":"<ol> <li>A capability or flow sends an event using <code>MessageHub.SendFlowMessage</code></li> <li>The target flow receives the event through its subscription</li> <li>The receiving flow processes the event in its workflow</li> <li>The workflow can wait for events using <code>Workflow.WaitConditionAsync</code></li> </ol> <p>This event-based communication pattern enables loose coupling between flows while maintaining type safety and reliable message delivery.</p>"},{"location":"2-agent-communication/1-events/#sdk-reference","title":"SDK Reference","text":""},{"location":"2-agent-communication/1-events/#messagehub-class","title":"MessageHub Class","text":"<p>The <code>MessageHub</code> class provides the core functionality for event-based communication between flows.</p>"},{"location":"2-agent-communication/1-events/#sending-flow-messages-events","title":"Sending flow messages Events","text":"<p>Using Flow Type:</p> <pre><code>await MessageHub.SendFlowMessage(\n    typeof(NewsReportFlow),  // Target flow type\n    payload                 // Optional payload object\n);\n</code></pre>"},{"location":"2-agent-communication/1-events/#subscribing-to-events","title":"Subscribing to Events","text":"<p>The <code>MessageHub</code> class provides two ways to subscribe to events:</p> <ol> <li>Async Handler:</li> </ol> <pre><code>_messageHub.SubscribeAsyncFlowMessageHandler&lt;NewsReportRequest&gt;(async (args) =&gt;\n{\n    // Handle event asynchronously\n    await ProcessEventAsync(metadata, payload);\n});\n</code></pre> <ol> <li>Sync Handler:</li> </ol> <pre><code>_messageHub.SubscribeFlowMessageHandler&lt;NewsReportRequest&gt;((args) =&gt;\n{\n    // Handle event synchronously\n    ProcessEvent(metadata, payload);\n});\n</code></pre>"},{"location":"2-agent-communication/1-events/#unsubscribing-from-events","title":"Unsubscribing from Events","text":"<p>To remove event handlers:</p> <pre><code>// Remove async handler\n_messageHub.UnsubscribeAsyncFlowMessageHandler&lt;NewsReportRequest&gt;(asyncHandler);\n\n// Remove sync handler\n_messageHub.UnsubscribeFlowMessageHandler&lt;NewsReportRequest&gt;(syncHandler);\n</code></pre>"},{"location":"2-agent-communication/1-events/#event-metadata","title":"Event Metadata","text":"<p>Each event includes metadata about its source:</p> <pre><code>public class EventMetadata\n{\n    public required string SourceWorkflowId { get; set; }\n    public required string SourceWorkflowType { get; set; }\n    public required string SourceAgent { get; set; }\n}\n</code></pre>"},{"location":"2-agent-communication/1-events/#event-handlers","title":"Event Handlers","text":"<p>Two types of event handlers are supported:</p> <ol> <li>Async Handler:</li> </ol> <pre><code>public delegate Task EventReceivedAsyncHandler&lt;T&gt;(EventMetadata metadata, T? payload);\n</code></pre> <ol> <li>Sync Handler:</li> </ol> <pre><code>public delegate void EventReceivedHandler&lt;T&gt;(EventMetadata metadata, T? payload);\n</code></pre>"},{"location":"2-agent-communication/10-handling-data-rpc/","title":"Handling Data as RPC","text":"<p>This document explains how the Agent Flow can process data messages once received through the RPC (Remote Procedure Call) pattern.</p> <p>When an Agent Flow receives a data message, it can process it in two ways: through workflow activities or through direct RPC method invocation. The RPC approach provides a simplified way to handle data messages through direct method invocation, bypassing the workflow orchestration layer. This pattern is ideal for stateless, atomic operations that don't require Temporal workflow orchestration or complex state management.</p>"},{"location":"2-agent-communication/10-handling-data-rpc/#setting-up-data-processor","title":"Setting Up Data Processor","text":""},{"location":"2-agent-communication/10-handling-data-rpc/#1-create-a-data-processor-class","title":"1. Create a Data Processor Class","text":"<p>Create a class with methods that will handle your data operations:</p> <pre><code>public class DataProcessor \n{\n    private readonly MessageThread _messageThread;\n\n    public DataProcessor(MessageThread messageThread) \n    {\n        _messageThread = messageThread;\n    }\n\n    public async Task&lt;ContractWithValidations&gt; ProcessDocumentRequest(DocumentRequest documentRequest) \n    {\n        // TODO: Implement the logic to process the document request\n        return new ContractWithValidations();\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/10-handling-data-rpc/#2-register-data-processor","title":"2. Register Data Processor","text":"<p>Register the data processor with your flow in <code>Program.cs</code>:</p> <pre><code>var agent = new AgentTeam(\"Legal Contract Agent\");\n\n// Add flow\nvar flow = agent.AddAgent&lt;LegalContractFlow&gt;();\nflow.SetDataProcessor&lt;DataProcessor&gt;();  // Register the data processor\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"2-agent-communication/10-handling-data-rpc/#constructor-requirements","title":"Constructor Requirements","text":"<p>Your DataProcessor class constructor can optionally accept a <code>MessageThread</code> parameter:</p> <pre><code>public class DataProcessor \n{\n    // Option 1: Constructor with MessageThread (automatically injected)\n    public DataProcessor(MessageThread messageThread) { }\n\n    // Option 2: Parameterless constructor\n    public DataProcessor() { }\n}\n</code></pre> <p>The <code>MessageThread</code> parameter will be automatically passed by the framework when the processor is instantiated.</p>"},{"location":"2-agent-communication/10-handling-data-rpc/#method-design","title":"Method Design","text":""},{"location":"2-agent-communication/10-handling-data-rpc/#method-signatures","title":"Method Signatures","text":"<p>Your data processor methods can have:</p> <ul> <li>Any method name - will be invoked by name</li> <li>Any parameters - automatically converted from JSON</li> <li>Any return type - automatically serialized to JSON response</li> <li>Async or sync - both <code>Task&lt;T&gt;</code> and direct returns supported</li> </ul> <pre><code>public class DataProcessor \n{\n    // Synchronous method\n    public string ProcessSimpleRequest(string input) \n    {\n        return $\"Processed: {input}\";\n    }\n\n    // Asynchronous method  \n    public async Task&lt;UserData&gt; ProcessUserRequest(int userId, string action) \n    {\n        return await _userService.GetUserAsync(userId);\n    }\n\n    // Complex object parameters and return types\n    public async Task&lt;ValidationResult&gt; ValidateDocument(DocumentRequest request) \n    {\n        // Process complex object\n        return await _validator.ValidateAsync(request);\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/10-handling-data-rpc/#invoking-methods-via-rest-api","title":"Invoking Methods via REST API","text":""},{"location":"2-agent-communication/10-handling-data-rpc/#authentication","title":"Authentication","text":"<p>The REST API supports two authentication methods:</p> <ul> <li>API Key Authentication: Pass your API key using the <code>apikey</code> query parameter</li> <li>JWT Token Authentication: Include a Bearer token in the <code>Authorization</code> header</li> </ul> <p>For more details, see the REST API section here.</p>"},{"location":"2-agent-communication/10-handling-data-rpc/#api-endpoint-format","title":"API Endpoint Format","text":"<p>e.g.,</p> <pre><code>POST http://localhost:5000/api/user/rest/converse\n</code></pre>"},{"location":"2-agent-communication/10-handling-data-rpc/#query-parameters","title":"Query Parameters","text":"<ul> <li><code>workflow</code> - Agent and workflow type or workflow ID</li> <li><code>apikey</code> - Your API key</li> <li><code>tenantId</code> - Tenant identifier (usually \"default\")</li> <li><code>type</code> - Must be \"Data\" for RPC calls</li> <li><code>participantId</code> - User identifier</li> <li><code>text</code> - Method name to invoke</li> </ul>"},{"location":"2-agent-communication/10-handling-data-rpc/#example-request","title":"Example Request","text":"<pre><code>POST &lt;your-server-url&gt;/api/user/rest/converse?workflow=Legal%20Contract%20Agent:Legal%20Contract%20Flow&amp;apikey=sk-Xnai---&amp;tenantId=default&amp;type=Data&amp;participantId=user@gmail.com&amp;text=ProcessDocumentRequest\n\nContent-Type: application/json\n\n```json\n{\n  \"DocumentId\": \"contract-123\",\n  \"ValidationType\": \"full\"\n}\n</code></pre>"},{"location":"2-agent-communication/10-handling-data-rpc/#response-format","title":"Response Format","text":"<p>When a data processor method executes successfully, the response follows this format:</p> <pre><code>{\n    \"requestId\": \"f021cef9-da15-4160-a7fb-053c885ea84b\",\n    \"threadId\": \"688e4717d8636b0ffb690e18\",\n    \"response\": {\n        \"id\": \"689021145e6400caa55a9dd8\",\n        \"text\": null,\n        \"data\": {\n            \"Contract\": {\n               ...\n            },\n            \"Validations\": [\n               ...\n            ]\n        },\n        \"createdAt\": \"2025-08-04T02:55:16.583Z\",\n        \"direction\": 1,\n        \"messageType\": 1,\n        \"scope\": null,\n        \"hint\": null\n    }\n}\n</code></pre> <p>Response Fields:</p> <ul> <li><code>requestId</code> - Unique identifier for the request</li> <li><code>threadId</code> - Thread identifier for the conversation</li> <li><code>response.id</code> - Message identifier</li> <li><code>response.text</code> - Usually null for data responses</li> <li><code>response.data</code> - The actual return value from your method (serialized as JSON)</li> <li><code>response.createdAt</code> - Timestamp when the response was created</li> <li><code>response.direction</code> - Message direction (1 = outbound)</li> <li><code>response.messageType</code> - Type of message (1 = data message)</li> <li><code>response.scope</code> - Execution scope</li> <li><code>response.hint</code> - Additional hints</li> </ul>"},{"location":"2-agent-communication/10-handling-data-rpc/#parameter-passing","title":"Parameter Passing","text":"<p>Parameters are passed as JSON in the request body and automatically converted to method parameters. The framework supports multiple parameter formats:</p>"},{"location":"2-agent-communication/10-handling-data-rpc/#single-parameter","title":"Single Parameter","text":"<pre><code>\"simple string value\"\n</code></pre> <pre><code>42\n</code></pre> <pre><code>{\n  \"DocumentId\": \"contract-123\",\n  \"ValidationType\": \"full\"\n}\n</code></pre>"},{"location":"2-agent-communication/10-handling-data-rpc/#multiple-parameters-array-format","title":"Multiple Parameters (Array Format)","text":"<pre><code>[\"contract-123\", \"full\", true]\n</code></pre> <pre><code>[\n  \"userId123\", \n  {\n    \"action\": \"validate\",\n    \"options\": {\n      \"strictMode\": true\n    }\n  }\n]\n</code></pre>"},{"location":"2-agent-communication/10-handling-data-rpc/#parameter-matching-rules","title":"Parameter Matching Rules","text":"<p>The framework uses intelligent parameter matching:</p> <ol> <li>Method name matching - Case insensitive (<code>processDocumentRequest</code> matches <code>ProcessDocumentRequest</code>)</li> <li>Parameter count matching - Exact count preferred, optional parameters supported</li> <li>Type conversion - Automatic JSON to .NET type conversion</li> <li>Method overloading - First compatible method signature wins</li> </ol>"},{"location":"2-agent-communication/10-handling-data-rpc/#example-method-invocations","title":"Example Method Invocations","text":""},{"location":"2-agent-communication/10-handling-data-rpc/#simple-string-parameter","title":"Simple String Parameter","text":"<p>Method:</p> <pre><code>public string ProcessMessage(string message) =&gt; $\"Processed: {message}\";\n</code></pre> <p>Request:</p> <pre><code>POST .../converse?...&amp;text=ProcessMessage\nContent-Type: application/json\n\n\"Hello World\"\n</code></pre>"},{"location":"2-agent-communication/10-handling-data-rpc/#complex-object-parameter","title":"Complex Object Parameter","text":"<p>Method:</p> <pre><code>public async Task&lt;ContractResult&gt; ProcessDocumentRequest(DocumentRequest request)\n</code></pre> <p>Request:</p> <pre><code>POST .../converse?...&amp;text=ProcessDocumentRequest\nContent-Type: application/json\n\n{\n  \"DocumentId\": \"contract-123\",\n  \"ValidationType\": \"comprehensive\",\n  \"Options\": {\n    \"includeMetadata\": true,\n    \"validateSignatures\": true\n  }\n}\n</code></pre>"},{"location":"2-agent-communication/10-handling-data-rpc/#multiple-parameters","title":"Multiple Parameters","text":"<p>Method:</p> <pre><code>public async Task&lt;UserReport&gt; GenerateReport(string userId, DateTime fromDate, bool includeDetails)\n</code></pre> <p>Request:</p> <pre><code>POST .../converse?...&amp;text=GenerateReport\nContent-Type: application/json\n\n[\"user123\", \"2024-01-01T00:00:00Z\", true]\n</code></pre>"},{"location":"2-agent-communication/10-handling-data-rpc/#error-handling","title":"Error Handling","text":"<p>If an error occurs, framework will retry with the default Temporal retry policy. This could be overridden by setting the <code>SystemActivityOptions</code> on the <code>FlowBase</code> class.</p> <p>If all retries fail, the error will be returned to the client.</p> <pre><code>{\n    \"requestId\": \"c6a3312f-8a23-4555-b037-026275dbe990\",\n    \"threadId\": \"688e4717d8636b0ffb690e18\",\n    \"response\": {\n        \"id\": \"688f38ac6e7f1461070eaf11\",\n        \"text\": \"Error occurred while processing data\",\n        \"data\": {\n            \"error\": \"Activity task failed\"\n        },\n        \"createdAt\": \"2025-08-03T10:23:40.054Z\",\n        \"direction\": 1,\n        \"messageType\": 1,\n        \"scope\": null,\n        \"hint\": null\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/11-thread-and-scope/","title":"Threads and Scopes","text":"<p>Message threads and scopes provide organizational structure for conversations and context management within the Xians AI platform. They enable precise control over message flow, context isolation, and conversation history management.</p>"},{"location":"2-agent-communication/11-thread-and-scope/#message-threads","title":"Message Threads","text":"<p>Message threads are the fundamental organizational unit for conversations between users and agents. Every message exchange is associated with a specific thread that groups related interactions together.</p>"},{"location":"2-agent-communication/11-thread-and-scope/#thread-identity","title":"Thread Identity","text":"<p>Each message thread is uniquely identified by a composite primary key consisting of:</p> <ul> <li>Tenant ID: Identifies the organization or tenant</li> <li>Workflow ID: Identifies the specific workflow or agent instance</li> <li>Participant ID: Identifies the user or participant in the conversation</li> </ul> <p>This three-part identifier ensures that conversations are properly isolated and organized across different tenants, workflows, and users.</p> <p>All conversations between a specific user and agent are grouped within a single thread, maintaining context and conversation history throughout the interaction lifecycle.</p>"},{"location":"2-agent-communication/11-thread-and-scope/#message-scopes","title":"Message Scopes","text":"<p>Message scopes provide fine-grained organization within a message thread, allowing for logical grouping of related messages and context isolation within a single conversation.</p>"},{"location":"2-agent-communication/11-thread-and-scope/#scope-purpose","title":"Scope Purpose","text":"<p>Scopes enable agents and users to organize conversations around specific topics, tasks, or contexts without losing the broader thread continuity. This is particularly valuable in complex workflows where multiple distinct activities occur within the same overall conversation.</p>"},{"location":"2-agent-communication/11-thread-and-scope/#common-scope-use-cases","title":"Common Scope Use Cases","text":"<p>Task-Based Scoping: When a user is working on multiple tasks simultaneously, each task can be assigned its own scope. This allows the agent to maintain context about each specific task while keeping them logically separated.</p> <p>Document-Centric Workflows: In scenarios involving multiple documents, each document can have its own scope. This enables focused discussions about specific documents without interference from other document-related conversations.</p> <p>Project Phases: Long-running projects can use scopes to organize conversations by project phase, milestone, or sprint, maintaining historical context while focusing on current phase activities.</p>"},{"location":"2-agent-communication/11-thread-and-scope/#scope-behavior-and-access-control","title":"Scope Behavior and Access Control","text":"<p>History Retrieval: When fetching conversation history, specifying a scope returns only messages within that particular scope, providing focused context for the agent or application.</p> <p>Message Sending: Messages can be sent to specific scopes, ensuring they are associated with the appropriate context and accessible to relevant participants.</p> <p>Context Isolation: When a scope is specified, agents have access only to message history within that scope, creating focused interactions without distraction from other scope content.</p> <p>Default Scope Behavior: Messages sent without a specified scope are accessible when no scope filter is applied, creating a general conversation area within the thread.</p>"},{"location":"2-agent-communication/11-thread-and-scope/#thread-and-scope-interaction","title":"Thread and Scope Interaction","text":""},{"location":"2-agent-communication/11-thread-and-scope/#hierarchical-organization","title":"Hierarchical Organization","text":"<p>Threads and scopes work together in a hierarchical structure:</p> <ul> <li>Threads serve as the top-level conversation container</li> <li>Scopes provide sub-organization within threads</li> <li>Messages exist within specific scopes (or in the default scope 'null')</li> </ul>"},{"location":"2-agent-communication/12-welcome-msg/","title":"Sending Welcome Message","text":"<p>The Xians platform supports setting up a default welcome message (or initial message) for agents in a conversational flow. This feature allows your agent to automatically greet the user with a predefined message when the conversation starts or after certain triggers.</p>"},{"location":"2-agent-communication/12-welcome-msg/#overview","title":"Overview","text":"<p>With this feature, you can configure your agent to send a default message from the agent side without requiring an explicit user query. This is useful when you want to create a conversational bot that proactively sends a greeting or initial instructions to the user.</p> <p>The welcome message will be sent when the user sends an empty message, which acts as a trigger for the agent to respond with the predefined content.</p>"},{"location":"2-agent-communication/12-welcome-msg/#usage","title":"Usage","text":"<p>You can define the welcome message using the <code>RouterOptions.WelcomeMessage</code> property.</p> <pre><code>public async Task Run()\n{\n    SystemPrompt = sysPrompt;\n\n    RouterOptions.WelcomeMessage = \"Hei! Welcome \ud83d\ude0a\";\n\n    // Start the conversation loop\n    await InitConversation();\n}\n</code></pre>"},{"location":"2-agent-communication/12-welcome-msg/#parameters","title":"Parameters","text":"Property Description Default <code>WelcomeMessage</code> The initial message the agent sends when triggered by an empty user message. (None)"},{"location":"2-agent-communication/12-welcome-msg/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Agent-Initiated: Message originates from the agent without requiring a prior user query.</li> <li>Trigger by Empty Message: The welcome message is sent when the user sends an empty message.</li> <li>Customizable: You can define any text, emoji, or content as your welcome message.</li> <li>Easy Setup: Set via a single property in <code>RouterOptions</code>.</li> </ul>"},{"location":"2-agent-communication/12-welcome-msg/#when-to-use","title":"When to Use","text":"<p>Use the Default Welcome Message when you need:</p> <ul> <li>A conversational bot to greet users upon entering a chat.</li> <li>Instructions or onboarding messages before the user starts interacting.</li> <li>A way to re-engage the user after a pause or specific action.</li> </ul> <p>For more complex conversation flows involving system prompts, chat history, or function calling, use the full routing capabilities of the Xians platform.</p>"},{"location":"2-agent-communication/13-message-types/","title":"Message Types","text":"<p>The Xians platform supports two primary message types for all communication scenarios (Agent2User, User2Agent, Agent2Agent): Chat and Data. While both types share the same data fields and structure, they differ fundamentally in how Agent workflows process them.</p>"},{"location":"2-agent-communication/13-message-types/#message-type-overview","title":"Message Type Overview","text":"Type Processing Method Use Cases Chat Semantic Kernel + Natural Language Conversations, Q&amp;A, human-readable interactions Data DataProcessor RPC Methods API integrations, structured data processing, automation"},{"location":"2-agent-communication/13-message-types/#common-message-structure","title":"Common Message Structure","text":"<p>All messages share the same base structure regardless of type:</p> <pre><code>{\n  \"id\": \"string\",                    // Unique message identifier\n  \"createdAt\": \"string\",             // ISO 8601 timestamp\n  \"direction\": 1,                    // Message direction (0=incoming, 1=outgoing)\n  \"messageType\": 1,                  // Message type (0=Chat, 1=Data)\n  \"text\": \"string\",                   // Text content (optional)\n  \"data\": {},                        // Structured data (optional)\n  \"hint\": \"string\",                  // Processing hint (optional)\n  \"requestId\": \"string\",             // Request correlation ID\n  \"participantId\": \"string\",         // Participant identifier\n  \"workflowId\": \"string\",            // Workflow instance ID\n  \"scope\": \"string\"                  // Message scope (optional)\n}\n</code></pre>"},{"location":"2-agent-communication/13-message-types/#chat-messages","title":"Chat Messages","text":""},{"location":"2-agent-communication/13-message-types/#processing-method","title":"Processing Method","text":"<p>Chat messages are processed through the Semantic Kernel as natural language queries. The Agent workflow interprets the text content using AI language models to understand intent and generate appropriate responses.</p>"},{"location":"2-agent-communication/13-message-types/#structure-example","title":"Structure Example","text":"<pre><code>{\n  \"id\": \"msg-chat-123\",\n  \"createdAt\": \"2024-01-15T10:30:00Z\",\n  \"direction\": 0,\n  \"messageType\": 0,\n  \"text\": \"What is your return policy?\",\n  \"participantId\": \"user-123\",\n  \"workflowId\": \"customer-support-instance-1\",\n  \"requestId\": \"req-456\"\n}\n</code></pre>"},{"location":"2-agent-communication/13-message-types/#api-request","title":"API Request","text":"<pre><code>POST /api/user/rest/converse?workflow=Customer%20Support&amp;type=Chat&amp;participantId=user123&amp;text=What%20are%20your%20business%20hours?\n</code></pre>"},{"location":"2-agent-communication/13-message-types/#data-messages","title":"Data Messages","text":""},{"location":"2-agent-communication/13-message-types/#processing-method_1","title":"Processing Method","text":"<p>Data messages bypass the Semantic Kernel entirely and are processed through DataProcessor classes using RPC-style method invocation. The <code>text</code> field specifies the method name to invoke, while the request body contains the method parameters.</p>"},{"location":"2-agent-communication/13-message-types/#structure-example_1","title":"Structure Example","text":"<pre><code>{\n  \"id\": \"msg-data-456\",\n  \"createdAt\": \"2024-01-15T10:35:00Z\",\n  \"direction\": 0,\n  \"messageType\": 1,\n  \"text\": \"ProcessDocumentRequest\",\n  \"data\": {\n    \"DocumentId\": \"contract-123\",\n    \"ValidationType\": \"full\"\n  },\n  \"participantId\": \"system-api\",\n  \"workflowId\": \"document-processor-instance-2\",\n  \"requestId\": \"req-789\"\n}\n</code></pre>"},{"location":"2-agent-communication/13-message-types/#api-request_1","title":"API Request","text":"<pre><code>POST /api/user/rest/converse?workflow=Document%20Processor&amp;type=Data&amp;participantId=system&amp;text=ProcessDocumentRequest\nContent-Type: application/json\n\n{\n  \"DocumentId\": \"contract-123\",\n  \"ValidationType\": \"comprehensive\"\n}\n</code></pre>"},{"location":"2-agent-communication/13-message-types/#key-differences","title":"Key Differences","text":""},{"location":"2-agent-communication/13-message-types/#processing-pipeline","title":"Processing Pipeline","text":"<p>Chat Messages Flow:</p> <pre><code>graph TD\n    A[Incoming Message] --&gt; B[Semantic Kernel]\n    B --&gt; C[AI Language Model]\n    C --&gt; D[Response Generation]\n    D --&gt; E[Outgoing Message]</code></pre> <p>Data Messages Flow:</p> <pre><code>graph TD\n    A[Incoming Message] --&gt; B[DataProcessor]\n    B --&gt; C[RPC Method Invocation]\n    C --&gt; D[Direct Response]\n    D --&gt; E[Outgoing Message]</code></pre>"},{"location":"2-agent-communication/13-message-types/#performance-characteristics","title":"Performance Characteristics","text":"Aspect Chat Messages Data Messages Processing Speed Slower (AI processing) Faster (direct method calls) Deterministic No (AI-generated responses) Yes (programmatic logic) Resource Usage Higher (LLM inference) Lower (direct execution) Scalability Limited by AI model capacity Limited by system resources"},{"location":"2-agent-communication/13-message-types/#response-handling","title":"Response Handling","text":"<p>Chat Response:</p> <pre><code>{\n  \"response\": {\n    \"text\": \"Our return policy allows returns within 30 days of purchase...\",\n    \"data\": null,\n    \"messageType\": 0\n  }\n}\n</code></pre> <p>Data Response:</p> <pre><code>{\n  \"response\": {\n    \"text\": null,\n    \"data\": {\n      \"Contract\": { \"id\": \"contract-123\", \"status\": \"validated\" },\n      \"Validations\": [{\"field\": \"signature\", \"status\": \"valid\"}]\n    },\n    \"messageType\": 1\n  }\n}\n</code></pre>"},{"location":"2-agent-communication/13-message-types/#dataprocessor-implementation","title":"DataProcessor Implementation","text":"<p>For more details on Data message processing, see Handling Data as RPC.</p>"},{"location":"2-agent-communication/13-message-types/#typescript-sdk","title":"TypeScript SDK","text":"<p>The TypeScript SDK provides a comprehensive set of tools for working with messages in the Xians platform. The SDK includes classes for creating, sending, and receiving messages, as well as utilities for working with message types and processing methods.</p> <p>For more details on the TypeScript SDK message type handling, see TypeScript SDK message Types.</p>"},{"location":"2-agent-communication/15-proactive-messages/","title":"Proactive Messages","text":""},{"location":"2-agent-communication/15-proactive-messages/#sending-messages-to-user","title":"Sending Messages to User","text":"<p>Use <code>MessageHub.Agent2User</code> to send messages to users without a <code>MessageThread</code> reference. Useful for offline users or initiating conversations.</p>"},{"location":"2-agent-communication/15-proactive-messages/#interface-overview","title":"Interface Overview","text":"<p>The <code>IAgent2User</code> interface provides methods to send chat and data messages, either from the current workflow or by impersonating another workflow:</p>"},{"location":"2-agent-communication/15-proactive-messages/#basic-methods-current-workflow","title":"Basic Methods (Current Workflow)","text":"<pre><code>// Send chat message from current workflow\npublic Task SendChat(string participantId, string content, object? data = null, string? requestId = null, string? scope = null);\n\n// Send data message from current workflow\npublic Task SendData(string participantId, string content, object data, string? requestId = null, string? scope = null);\n</code></pre>"},{"location":"2-agent-communication/15-proactive-messages/#impersonation-methods-type-based","title":"Impersonation Methods (Type-based)","text":"<pre><code>// Send chat message as another workflow type\npublic Task SendChatAs(Type flowClassType, string participantId, string content, object? data = null, string? requestId = null, string? scope = null);\n\n// Send data message as another workflow type\npublic Task SendDataAs(Type flowClassType, string participantId, string content, object data, string? requestId = null, string? scope = null);\n</code></pre>"},{"location":"2-agent-communication/15-proactive-messages/#impersonation-methods-string-based","title":"Impersonation Methods (String-based)","text":"<pre><code>// Send chat message using workflow ID or type name\npublic Task SendChatAs(string workflowIdOrType, string participantId, string content, object? data = null, string? requestId = null, string? scope = null);\n\n// Send data message using workflow ID or type name\npublic Task SendDataAs(string workflowIdOrType, string participantId, string content, object data, string? requestId = null, string? scope = null);\n</code></pre>"},{"location":"2-agent-communication/15-proactive-messages/#usage-examples","title":"Usage Examples","text":"<pre><code>// From current workflow\nawait MessageHub.Agent2User.SendChat(userId, \"Hello!\");\nawait MessageHub.Agent2User.SendData(userId, \"Status update\", statusData);\n\n// Impersonate by type\nawait MessageHub.Agent2User.SendChatAs(typeof(MyFlow), userId, \"Hello from MyFlow!\");\nawait MessageHub.Agent2User.SendDataAs(typeof(MyFlow), userId, \"Data from MyFlow\", payload);\n\n// Impersonate by string\nawait MessageHub.Agent2User.SendChatAs(\"MyWorkflowId\", userId, \"Hello!\");\nawait MessageHub.Agent2User.SendDataAs(\"MyWorkflowType\", userId, \"Update\", data);\n</code></pre>"},{"location":"2-agent-communication/16-synchronous-chat/","title":"Synchronous Chat Messages","text":"<p>Synchronous chat message passing provides a simplified mechanism for agents to send conversational messages directly to other agents. This approach maintains an HTTP connection until the response is received, with a default 5-minute timeout.</p>"},{"location":"2-agent-communication/16-synchronous-chat/#overview","title":"Overview","text":"<p>The <code>Agent2Agent</code> class enables workflows to send chat messages synchronously to other workflow agents, supporting:</p> <ul> <li>Direct workflow ID/Type targeting: Send to a specific workflow instance</li> <li>Class-Type-based singleton targeting: Send to the singleton instance of a workflow type</li> <li>Immediate responses: Get responses without complex queuing mechanisms</li> <li>Built-in timeout handling: Configurable timeout (default: 300 seconds)</li> </ul>"},{"location":"2-agent-communication/16-synchronous-chat/#core-interface","title":"Core Interface","text":"<pre><code>interface IAgent2Agent {\n    Task&lt;MessageResponse&gt; SendChat(string workflowIdOrType, string message, ...);\n    Task&lt;MessageResponse&gt; SendChat(Type targetWorkflowType, string message, ...);\n}\n</code></pre>"},{"location":"2-agent-communication/16-synchronous-chat/#usage-patterns","title":"Usage Patterns","text":""},{"location":"2-agent-communication/16-synchronous-chat/#1-send-chat-to-specific-workflow","title":"1. Send Chat to Specific Workflow","text":"<pre><code>// Send chat message to specific workflow instance\nvar response = await MessageHub.Agent2Agent.SendChat(\n    workflowIdOrType: \"CustomerServiceAgent-123\",\n    message: \"Please review this customer inquiry and provide a response\"\n);\n</code></pre>"},{"location":"2-agent-communication/16-synchronous-chat/#2-send-chat-to-workflow-type-singleton","title":"2. Send Chat to Workflow Type (Singleton)","text":"<pre><code>// Send chat message to singleton instance of CustomerServiceAgent workflow\nvar response = await MessageHub.Agent2Agent.SendChat(\n    targetWorkflowType: typeof(CustomerServiceFlow),\n    message: \"Please analyze this customer feedback and categorize it\"\n);\n</code></pre>"},{"location":"2-agent-communication/16-synchronous-chat/#3-chat-messages-with-additional-data","title":"3. Chat Messages with Additional Data","text":"<pre><code>// Send chat message with optional structured data\nvar response = await MessageHub.Agent2Agent.SendChat(\n    workflowIdOrType: \"CustomerServiceAgent\",\n    message: \"Please review this customer inquiry\",\n    data: new CustomerInquiry { \n        CustomerId = \"cust-789\", \n        Issue = \"Billing question\",\n        Priority = \"High\"\n    }\n);\n</code></pre>"},{"location":"2-agent-communication/16-synchronous-chat/#4-advanced-options","title":"4. Advanced Options","text":"<pre><code>var response = await MessageHub.Agent2Agent.SendChat(\n    targetWorkflowType: typeof(AnalysisBot),\n    message: \"Analyze the sentiment of this customer feedback\",\n    requestId: Guid.NewGuid().ToString(),\n    scope: \"sentiment-analysis\",\n    authorization: \"Bearer token123\",\n    hint: \"urgent-analysis\",\n    timeoutSeconds: 120  // Custom timeout\n);\n</code></pre>"},{"location":"2-agent-communication/16-synchronous-chat/#real-world-example-company-name-extraction","title":"Real-World Example: Company Name Extraction","text":"<p>Here's a practical example of using synchronous chat to delegate natural language processing tasks:</p> <pre><code>[Capability(\"Extract the name of the company of interest from an online link, if any\")]\n[Parameter(\"url\", \"URL of the website to extract company of interest from\")]\n[Returns(\"Name of the company of interest. If no company is found, return `not-found`.\")]\npublic async Task&lt;string?&gt; ExtractCompanyNameFromLink(string url)\n{\n    var prompt = @$\"\n    Read the content in the following link: {url}\n    Check if the content mentions about a company.\n    If so, extract the name of the company.\n    Return the name of the company. If no company is found, return `not-found`.\n    Do not return any other text.\n    \";\n    var response = await MessageHub.Agent2Agent.SendChat(typeof(WebBot), prompt);\n    return response.Text;\n}\n</code></pre> <p>This example demonstrates:</p> <ul> <li>Task delegation: Delegating web content analysis to a specialized WebBot agent</li> <li>Clear instructions: Providing specific prompts for the target agent</li> <li>Simple response handling: Extracting the text response directly</li> </ul>"},{"location":"2-agent-communication/16-synchronous-chat/#message-response-handling","title":"Message Response Handling","text":"<pre><code>var response = await MessageHub.Agent2Agent.SendChat(...);\n\nif (response != null)\n{\n    // Handle successful response\n    var chatResponse = response.Text;\n    var additionalData = response.Data;\n\n    // Process the natural language response\n    Console.WriteLine($\"Agent responded: {chatResponse}\");\n}\nelse\n{\n    // Handle timeout or no response\n    _logger.LogWarning(\"No response received from target agent\");\n}\n</code></pre> <p>Sample Implementation</p> <p>See a complete working example of agent-to-agent synchronous chat communication at GitHub Samples.</p> <p>This synchronous chat approach provides a powerful way to leverage the conversational capabilities of different agents while maintaining simple, direct communication patterns.</p>"},{"location":"2-agent-communication/16-synchronous-data-rpc/","title":"Synchronous Data RPC","text":"<p>Synchronous Data RPC provides a simplified RPC-style mechanism for agents to send structured data messages directly to other agents. This approach maintains an HTTP connection until the response is received, with a default 5-minute timeout.</p>"},{"location":"2-agent-communication/16-synchronous-data-rpc/#overview","title":"Overview","text":"<p>The <code>Agent2Agent</code> class enables workflows to send data messages synchronously to other workflow agents, supporting:</p> <ul> <li>Direct workflow ID/Type targeting: Send to a specific workflow instance</li> <li>Class-Type-based singleton targeting: Send to the singleton instance of a workflow type</li> <li>Immediate responses: Get responses without complex queuing mechanisms</li> <li>Built-in timeout handling: Configurable timeout (default: 300 seconds)</li> </ul>"},{"location":"2-agent-communication/16-synchronous-data-rpc/#core-interface","title":"Core Interface","text":"<pre><code>interface IAgent2Agent {\n    Task&lt;MessageResponse&gt; SendData(string workflowIdOrType, object data, string methodName, ...);\n    Task&lt;MessageResponse&gt; SendData(Type targetWorkflowType, object data, string methodName, ...);\n}\n</code></pre>"},{"location":"2-agent-communication/16-synchronous-data-rpc/#usage-patterns","title":"Usage Patterns","text":""},{"location":"2-agent-communication/16-synchronous-data-rpc/#1-send-data-to-specific-workflow","title":"1. Send Data to Specific Workflow","text":"<pre><code>// Send to specific workflow instance\nvar response = await MessageHub.Agent2Agent.SendData(\n    workflowIdOrType: \"DocumentProcessor-123\",\n    data: new ProcessDocumentRequest { DocumentId = \"doc-456\" },\n    methodName: \"ProcessDocument\"\n);\n</code></pre>"},{"location":"2-agent-communication/16-synchronous-data-rpc/#2-send-data-to-workflow-type-singleton","title":"2. Send Data to Workflow Type (Singleton)","text":"<pre><code>// Send to singleton instance of DocumentProcessor workflow\nvar response = await MessageHub.Agent2Agent.SendData(\n    targetWorkflowType: typeof(DocumentProcessorFlow),\n    data: new ProcessDocumentRequest { DocumentId = \"doc-456\" },\n    methodName: \"ProcessDocument\"\n);\n</code></pre>"},{"location":"2-agent-communication/16-synchronous-data-rpc/#3-advanced-options","title":"3. Advanced Options","text":"<pre><code>var response = await MessageHub.Agent2Agent.SendData(\n    targetWorkflowType: typeof(PaymentProcessor),\n    data: paymentRequest,\n    methodName: \"ProcessPayment\",\n    requestId: Guid.NewGuid().ToString(),\n    scope: \"payment-processing\",\n    authorization: \"Bearer token123\",\n    hint: \"high-priority\",\n    timeoutSeconds: 60  // Custom timeout\n);\n</code></pre>"},{"location":"2-agent-communication/16-synchronous-data-rpc/#message-response-handling","title":"Message Response Handling","text":"<pre><code>var response = await MessageHub.Agent2Agent.SendData(...);\n\nif (response != null)\n{\n    // Handle successful response\n    var result = response.Data;\n}\nelse\n{\n    // Handle timeout or no response\n    _logger.LogWarning(\"No response received from target agent\");\n}\n</code></pre>"},{"location":"2-agent-communication/16-synchronous-data-rpc/#receiving-synchronous-data-messages","title":"Receiving Synchronous Data Messages","text":"<p>The receiving agent must handle synchronous data messages through RPC processors for optimal performance and simplicity. Unlike asynchronous data messages that require manual queuing, synchronous messages are processed directly through method invocation.</p>"},{"location":"2-agent-communication/16-synchronous-data-rpc/#setting-up-rpc-processor","title":"Setting Up RPC Processor","text":"<p>The receiving workflow should implement a DataProcessor class to handle incoming synchronous data messages:</p> <pre><code>public class DocumentDataProcessor \n{\n    private readonly MessageThread _messageThread;\n\n    public DocumentDataProcessor(MessageThread messageThread) \n    {\n        _messageThread = messageThread;\n    }\n\n    public async Task&lt;ProcessResult&gt; ProcessDocument(ProcessDocumentRequest request) \n    {\n        // Handle the synchronous data message\n        return new ProcessResult \n        { \n            DocumentId = request.DocumentId,\n            Status = \"Processed\",\n            ProcessedAt = DateTime.UtcNow\n        };\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/16-synchronous-data-rpc/#register-rpc-processor","title":"Register RPC Processor","text":"<p>Register the processor with your flow:</p> <pre><code>var agent = new AgentTeam(\"Document Processor Agent\");\nvar flow = agent.AddAgent&lt;DocumentProcessorFlow&gt;();\nflow.SetDataProcessor&lt;DocumentDataProcessor&gt;();  // Enable RPC handling\nawait agent.RunAsync();\n</code></pre> <p>Complete RPC Implementation Guide</p> <p>For detailed implementation instructions, method signatures, parameter handling, and error management, see Handling Data as RPC.</p>"},{"location":"2-agent-communication/16-synchronous-data-rpc/#comparison-with-asynchronous-data-handling","title":"Comparison with Asynchronous Data Handling","text":"Feature Synchronous Data RPC Asynchronous Data Handling Response Pattern Immediate (RPC-style) Event-driven queuing Connection Holds HTTP connection Fire-and-forget Timeout 5 minutes default No timeout Complexity Low (single method call) High (queuing, event handling) Use Case Simple request-response Complex orchestration Fault Tolerance Connection-based Temporal workflow guarantees Scalability Limited by connection pool High (async processing)"},{"location":"2-agent-communication/16-synchronous-data-rpc/#best-practices","title":"Best Practices","text":""},{"location":"2-agent-communication/16-synchronous-data-rpc/#when-to-use-synchronous-data-rpc","title":"When to Use Synchronous Data RPC","text":"<ul> <li>\u2705 Simple request-response scenarios with structured data</li> <li>\u2705 When you need immediate confirmation</li> <li>\u2705 Short-lived operations (&lt; 5 minutes)</li> <li>\u2705 Direct agent-to-agent data processing</li> </ul>"},{"location":"2-agent-communication/16-synchronous-data-rpc/#when-to-use-asynchronous-data-handling","title":"When to Use Asynchronous Data Handling","text":"<ul> <li>\u2705 Long-running processes</li> <li>\u2705 Complex workflow orchestration</li> <li>\u2705 High-throughput scenarios</li> <li>\u2705 When fault tolerance is critical</li> </ul> <p>Sample Implementation</p> <p>See a complete working example of agent-to-agent synchronous data communication at GitHub Samples.</p> <p>This synchronous data RPC approach provides a much simpler alternative to manual data message handling while maintaining the flexibility to communicate between different types of workflow agents using structured data.</p>"},{"location":"2-agent-communication/17-webhooks/","title":"Webhooks","text":"<p>Webhooks provide a powerful mechanism for external systems to send messages and trigger events in your XiansAI agents. They enable real-time integration with third-party services, allowing your agents to respond to external events as they occur.</p>"},{"location":"2-agent-communication/17-webhooks/#overview","title":"Overview","text":"<p>Webhooks in XiansAI allow external systems to:</p> <ul> <li>Send HTTP POST requests to trigger agent workflows</li> <li>Pass data and parameters to agent methods</li> <li>Receive immediate responses from agents</li> <li>Integrate with external services and APIs</li> </ul>"},{"location":"2-agent-communication/17-webhooks/#webhook-url-format","title":"Webhook URL Format","text":"<p>All webhook requests follow this standardized URL format:</p> <pre><code>POST &lt;server-url&gt;/api/user/webhooks/{workflow}/{methodName}?apikey={apikey}&amp;[additional-params]\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#url-parameters","title":"URL Parameters","text":"Parameter Description Required <code>workflow</code> Either the WorkflowId or the WorkflowType \u2705 Yes <code>methodName</code> Name of the Temporal Update method to invoke \u2705 Yes <code>apikey</code> Valid API key for authentication \u2705 Yes <code>tenantId</code> Tenant identifier (automatically derived from API key if not provided) \u274c Optional* <code>additional-params</code> Custom query parameters passed to the method \u274c Optional <p>*The tenant is automatically determined from the API key. You can optionally provide <code>tenantId</code> for backward compatibility, but it must match the API key's tenant.</p>"},{"location":"2-agent-communication/17-webhooks/#example-urls","title":"Example URLs","text":"<p>Recommended (secure): <pre><code>POST http://localhost:5000/api/user/webhooks/A2A%20Agent%20Team%3A%20Webhook%20Bot/mail-received?apikey=sk-Xnai-jJlpoIrOxiAhrOwOsB1xuO96TfEfZYmJa2u6xMqXjZg&amp;param=param-value\n</code></pre></p> <p>Legacy (with explicit tenantId): <pre><code>POST http://localhost:5000/api/user/webhooks/A2A%20Agent%20Team%3A%20Webhook%20Bot/mail-received?apikey=sk-Xnai-jJlpoIrOxiAhrOwOsB1xuO96TfEfZYmJa2u6xMqXjZg&amp;tenantId=default&amp;param=param-value\n</code></pre></p>"},{"location":"2-agent-communication/17-webhooks/#implementing-webhook-handlers","title":"Implementing Webhook Handlers","text":""},{"location":"2-agent-communication/17-webhooks/#1-define-webhook-method","title":"1. Define Webhook Method","text":"<p>Create a method in your workflow class decorated with the <code>[WorkflowUpdate]</code> attribute:</p> <pre><code>[WorkflowUpdate(\"method-name\")]\npublic async Task&lt;WebhookResponse&gt; WebhookUpdateMethod(IDictionary&lt;string, string&gt; queryParams, string body)\n{\n    // Process the webhook data\n    Console.WriteLine(\"Webhook received\");\n    Console.WriteLine(JsonSerializer.Serialize(queryParams));\n    Console.WriteLine(body);\n\n    // Return response to webhook caller\n    var response = new WebhookResponse(HttpStatusCode.OK);\n    response.Content = \"Webhook processed successfully\";\n    return response;\n}\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#2-method-signature-requirements","title":"2. Method Signature Requirements","text":"<ul> <li>Update Name: Must match the <code>methodName</code> in the webhook URL</li> <li>Parameters:</li> <li><code>queryParams</code>: Contains all query parameters except <code>apikey</code> (and <code>tenantId</code> if provided)</li> <li><code>body</code>: Contains the raw request body as a string</li> <li>Return Type: Must return a <code>WebhookResponse</code> object which allows you to control the HTTP status code, content, and content type sent back to the webhook caller.</li> </ul>"},{"location":"2-agent-communication/17-webhooks/#webhookresponse-class","title":"WebhookResponse Class","text":"<p>The <code>WebhookResponse</code> class provides fine-grained control over the HTTP response sent back to the webhook caller:</p> <pre><code>// Basic response with 200 OK status\nvar response = new WebhookResponse(HttpStatusCode.OK);\nresponse.Content = \"Success message\";\n\n// Response with custom status code\nvar errorResponse = new WebhookResponse(HttpStatusCode.BadRequest);\nerrorResponse.Content = JsonSerializer.Serialize(new { error = \"Invalid data\" });\n\n// Response with custom content type\nvar xmlResponse = new WebhookResponse(HttpStatusCode.OK, \"&lt;result&gt;success&lt;/result&gt;\", \"application/xml\");\n\n// Plain text response (useful for validation tokens)\nvar validationResponse = new WebhookResponse(HttpStatusCode.OK, \"validation-token-123\", \"text/plain\");\n</code></pre> <p>Constructor Options:</p> <ul> <li><code>WebhookResponse(HttpStatusCode statusCode)</code> - Basic response with status code</li> <li><code>WebhookResponse(HttpStatusCode statusCode, string content, string contentType)</code> - Full control over response</li> </ul> <p>Properties:</p> <ul> <li><code>StatusCode</code> - HTTP status code (200, 400, 500, etc.)</li> <li><code>Content</code> - Response body content</li> <li><code>ContentType</code> - MIME type (defaults to \"application/json\")</li> </ul>"},{"location":"2-agent-communication/17-webhooks/#3-complete-webhook-bot-example","title":"3. Complete Webhook Bot Example","text":"<pre><code>using System.Text.Json;\nusing System.Net;\nusing Temporalio.Workflows;\nusing XiansAi.Flow;\n\n[Workflow(\"Agent Team: Webhook Bot\")]\npublic class WebhookBot : FlowBase\n{\n    [WorkflowRun]\n    public async Task Run()\n    {\n        await InitWebhookProcessing();\n    }\n\n    [WorkflowUpdate(\"mail-received\")]\n    public async Task&lt;WebhookResponse&gt; MailReceived(IDictionary&lt;string, string&gt; queryParams, string body)\n    {\n        // Optional: Add processing delay\n        await Workflow.DelayAsync(TimeSpan.FromSeconds(1));\n\n        // Handle validation token (for services like Microsoft Graph)\n        if (queryParams.TryGetValue(\"validationToken\", out var validationToken))\n        {\n            return new WebhookResponse(HttpStatusCode.OK, validationToken, \"text/plain\");\n        }\n\n        // Log webhook reception\n        Console.WriteLine(\"Mail received\");\n        Console.WriteLine(JsonSerializer.Serialize(queryParams));\n        Console.WriteLine(body);\n\n        // Process the webhook data here\n        // ... your business logic ...\n\n        // Return response to caller\n        var response = new WebhookResponse(HttpStatusCode.OK);\n        response.Content = body; // Echo back the received body\n        return response;\n    }\n\n    [WorkflowUpdate(\"order-created\")]\n    public async Task&lt;WebhookResponse&gt; OrderCreated(IDictionary&lt;string, string&gt; queryParams, string body)\n    {\n        // Parse JSON body\n        var orderData = JsonSerializer.Deserialize&lt;OrderData&gt;(body);\n\n        // Process order\n        await ProcessOrder(orderData);\n\n        var response = new WebhookResponse(HttpStatusCode.OK);\n        response.Content = JsonSerializer.Serialize(new { status = \"processed\", orderId = orderData.Id });\n        return response;\n    }\n\n    private async Task ProcessOrder(OrderData order)\n    {\n        // Your order processing logic\n        await Workflow.DelayAsync(TimeSpan.FromSeconds(2));\n        Console.WriteLine($\"Processed order: {order.Id}\");\n    }\n}\n\npublic class OrderData\n{\n    public string Id { get; set; }\n    public string CustomerEmail { get; set; }\n    public decimal Amount { get; set; }\n}\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#understanding-initwebhookprocessing","title":"Understanding InitWebhookProcessing()","text":"<p>The <code>await InitWebhookProcessing()</code> call in the workflow's <code>Run()</code> method serves several critical functions:</p>"},{"location":"2-agent-communication/17-webhooks/#1-keeps-workflow-active-for-webhook-processing","title":"1. Keeps Workflow Active for Webhook Processing","text":"<p>This method holds the workflow indefinitely from completion, allowing it to continue processing incoming webhook requests. Without this call, the workflow would complete immediately and wouldn't be able to handle webhook updates.</p> <pre><code>[WorkflowRun]\npublic async Task Run()\n{\n    await InitWebhookProcessing(); // Keeps workflow alive to handle webhooks\n}\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#2-temporal-maintenance-continueasnew","title":"2. Temporal Maintenance (ContinueAsNew)","text":"<p><code>InitWebhookProcessing()</code> performs mandatory Temporal maintenance by automatically calling <code>ContinueAsNew</code> when the workflow history becomes too long. This prevents workflows from hitting Temporal's history size limits and ensures optimal performance.</p>"},{"location":"2-agent-communication/17-webhooks/#3-alternative-asynchronous-initialization","title":"3. Alternative: Asynchronous Initialization","text":"<p>While any workflow can process webhooks, it's a good practice to initialize webhook processing asynchronously if you have other workflow logic to execute:</p> <pre><code>[WorkflowRun]\npublic async Task Run()\n{\n    // Start webhook processing asynchronously (fire-and-forget)\n    _ = InitWebhookProcessing();\n\n    // Continue with other workflow logic\n    await PerformOtherTasks();\n\n    // Keep workflow running\n    await Workflow.WaitConditionAsync(() =&gt; false); // Wait indefinitely\n}\n\nprivate async Task PerformOtherTasks()\n{\n    // Your other workflow logic here\n    await SomeInitializationTask();\n    await SetupPeriodicTasks();\n}\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#4-best-practices","title":"4. Best Practices","text":"<ul> <li>Dedicated Webhook Workflows: For workflows that only handle webhooks, use <code>await InitWebhookProcessing()</code></li> <li>Mixed Workflows: For workflows with other logic, use <code>_ = InitWebhookProcessing()</code> and manage the workflow lifecycle separately</li> <li>Always Keep Active: Ensure your webhook workflow never completes if you want to continue receiving webhook calls</li> </ul> <p>Workflow Lifecycle and Webhook Processing</p> <p>If your webhook workflow completes (exits the <code>Run()</code> method), the system will automatically start a new workflow instance each time a webhook request is received. This \"Update with Start\" pattern ensures webhooks are always processed, but creates overhead from repeatedly starting new workflow instances.</p> <p>For optimal performance with frequent webhooks, keep your workflow active using <code>InitWebhookProcessing()</code> to maintain a single long-running instance.</p>"},{"location":"2-agent-communication/17-webhooks/#agent-configuration","title":"Agent Configuration","text":"<p>Register your webhook bot with the agent:</p> <pre><code>using XiansAi.Flow;\nusing DotNetEnv;\n\n// Load environment variables\nEnv.Load();\n\n// Create agent\nvar agent = new AgentTeam(\"Agent Team\");\n\n// Add webhook bot\nvar webhookBot = agent.AddAgent&lt;WebhookBot&gt;();\n\n// Run agent\nawait agent.RunAsync();\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#webhook-security","title":"Webhook Security","text":""},{"location":"2-agent-communication/17-webhooks/#api-key-authentication","title":"API Key Authentication","text":"<p>All webhook requests must include a valid API key in the query parameters:</p> <pre><code>?apikey=&lt;your-api-key&gt;\n</code></pre> <p>The API key provides both authentication and authorization. The system automatically extracts the tenant information from the authenticated API key, ensuring secure tenant isolation.</p>"},{"location":"2-agent-communication/17-webhooks/#tenant-isolation","title":"Tenant Isolation","text":"<p>Webhooks are automatically tenant-scoped based on the authenticated API key. The tenant associated with the API key is used to identify and route the webhook to the correct workflow instance.</p> <p>Security Best Practice: Do not include the <code>tenantId</code> parameter in your webhook URLs. Let the system derive it from your API key to prevent potential security issues.</p> <p>Legacy Support: If you need to include <code>tenantId</code> for backward compatibility, it must exactly match the tenant associated with your API key, otherwise the request will be rejected.</p>"},{"location":"2-agent-communication/17-webhooks/#testing-webhooks","title":"Testing Webhooks","text":""},{"location":"2-agent-communication/17-webhooks/#using-curl","title":"Using cURL","text":"<pre><code>curl -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"message\": \"Test message\", \"timestamp\": \"2024-01-15T10:30:00Z\"}' \\\n  \"http://localhost:5000/api/user/webhooks/WebhookBot/mail-received?apikey=your-api-key&amp;source=email\"\n</code></pre> <p>Note: The tenant is automatically derived from your API key. You don't need to include <code>tenantId</code> in the URL.</p>"},{"location":"2-agent-communication/17-webhooks/#common-use-cases","title":"Common Use Cases","text":""},{"location":"2-agent-communication/17-webhooks/#1-email-integration","title":"1. Email Integration","text":"<pre><code>[WorkflowUpdate(\"email-received\")]\npublic async Task&lt;WebhookResponse&gt; EmailReceived(IDictionary&lt;string, string&gt; queryParams, string body)\n{\n    var emailData = JsonSerializer.Deserialize&lt;EmailData&gt;(body);\n\n    // Process email\n    await ProcessEmail(emailData);\n\n    // Send to appropriate agent\n    await MessageHub.Agent2Agent.SendChat(\n        typeof(CustomerServiceAgent),\n        $\"New email from {emailData.From}: {emailData.Subject}\"\n    );\n\n    var response = new WebhookResponse(HttpStatusCode.OK);\n    response.Content = \"Email processed\";\n    return response;\n}\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#2-payment-notifications","title":"2. Payment Notifications","text":"<pre><code>[WorkflowUpdate(\"payment-completed\")]\npublic async Task&lt;WebhookResponse&gt; PaymentCompleted(IDictionary&lt;string, string&gt; queryParams, string body)\n{\n    var payment = JsonSerializer.Deserialize&lt;PaymentNotification&gt;(body);\n\n    // Update order status\n    await UpdateOrderStatus(payment.OrderId, \"paid\");\n\n    // Trigger fulfillment\n    await MessageHub.Agent2Agent.SendData(\n        typeof(FulfillmentAgent),\n        new FulfillmentRequest { OrderId = payment.OrderId },\n        \"ProcessFulfillment\"\n    );\n\n    var response = new WebhookResponse(HttpStatusCode.OK);\n    response.Content = JsonSerializer.Serialize(new { status = \"processed\" });\n    return response;\n}\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#3-system-monitoring","title":"3. System Monitoring","text":"<pre><code>[WorkflowUpdate(\"system-alert\")]\npublic async Task&lt;WebhookResponse&gt; SystemAlert(IDictionary&lt;string, string&gt; queryParams, string body)\n{\n    var alert = JsonSerializer.Deserialize&lt;SystemAlert&gt;(body);\n\n    if (alert.Severity == \"critical\")\n    {\n        // Escalate to on-call engineer\n        await MessageHub.Agent2User.SendChat(\n            alert.OnCallEngineerId,\n            $\"\ud83d\udea8 Critical Alert: {alert.Message}\"\n        );\n    }\n\n    // Log alert\n    Console.WriteLine($\"Alert received: {alert.Message}\");\n\n    var response = new WebhookResponse(HttpStatusCode.OK);\n    response.Content = \"Alert acknowledged\";\n    return response;\n}\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#best-practices","title":"Best Practices","text":""},{"location":"2-agent-communication/17-webhooks/#1-error-handling","title":"1. Error Handling","text":"<pre><code>[WorkflowUpdate(\"process-data\")]\npublic async Task&lt;WebhookResponse&gt; ProcessData(IDictionary&lt;string, string&gt; queryParams, string body)\n{\n    try\n    {\n        var data = JsonSerializer.Deserialize&lt;MyData&gt;(body);\n        await ProcessBusinessLogic(data);\n\n        var response = new WebhookResponse(HttpStatusCode.OK);\n        response.Content = JsonSerializer.Serialize(new { status = \"success\" });\n        return response;\n    }\n    catch (JsonException ex)\n    {\n        Console.WriteLine($\"JSON parsing error: {ex.Message}\");\n\n        var errorResponse = new WebhookResponse(HttpStatusCode.BadRequest);\n        errorResponse.Content = JsonSerializer.Serialize(new { status = \"error\", message = \"Invalid JSON format\" });\n        return errorResponse;\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine($\"Processing error: {ex.Message}\");\n\n        var errorResponse = new WebhookResponse(HttpStatusCode.InternalServerError);\n        errorResponse.Content = JsonSerializer.Serialize(new { status = \"error\", message = \"Processing failed\" });\n        return errorResponse;\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#2-async-processing","title":"2. Async Processing","text":"<pre><code>[WorkflowUpdate(\"long-running-task\")]\npublic async Task&lt;WebhookResponse&gt; LongRunningTask(IDictionary&lt;string, string&gt; queryParams, string body)\n{\n    // Start async processing\n    _ =  Workflow.RunTaskAsync(async () =&gt;\n    {\n        await ProcessLongRunningTask(body);\n    });\n\n    // Return immediate response\n    var response = new WebhookResponse(HttpStatusCode.Accepted);\n    response.Content = JsonSerializer.Serialize(new { status = \"accepted\", message = \"Task queued for processing\" });\n    return response;\n}\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#3-validation","title":"3. Validation","text":"<pre><code>[WorkflowUpdate(\"validate-and-process\")]\npublic async Task&lt;WebhookResponse&gt; ValidateAndProcess(IDictionary&lt;string, string&gt; queryParams, string body)\n{\n    // Validate required parameters\n    if (!queryParams.ContainsKey(\"source\"))\n    {\n        var errorResponse = new WebhookResponse(HttpStatusCode.BadRequest);\n        errorResponse.Content = JsonSerializer.Serialize(new { status = \"error\", message = \"Missing 'source' parameter\" });\n        return errorResponse;\n    }\n\n    // Validate body\n    if (string.IsNullOrEmpty(body))\n    {\n        var errorResponse = new WebhookResponse(HttpStatusCode.BadRequest);\n        errorResponse.Content = JsonSerializer.Serialize(new { status = \"error\", message = \"Empty request body\" });\n        return errorResponse;\n    }\n\n    // Process valid request\n    await ProcessValidRequest(queryParams[\"source\"], body);\n\n    var response = new WebhookResponse(HttpStatusCode.OK);\n    response.Content = JsonSerializer.Serialize(new { status = \"success\" });\n    return response;\n}\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#integration-with-other-agent-features","title":"Integration with Other Agent Features","text":""},{"location":"2-agent-communication/17-webhooks/#combining-with-proactive-messages","title":"Combining with Proactive Messages","text":"<pre><code>[WorkflowUpdate(\"user-action\")]\npublic async Task&lt;WebhookResponse&gt; UserAction(IDictionary&lt;string, string&gt; queryParams, string body)\n{\n    var action = JsonSerializer.Deserialize&lt;UserAction&gt;(body);\n\n    // Send proactive message to user\n    await MessageHub.Agent2User.SendChat(\n        action.UserId,\n        $\"We received your {action.ActionType} request and are processing it now.\"\n    );\n\n    var response = new WebhookResponse(HttpStatusCode.OK);\n    response.Content = \"Action acknowledged\";\n    return response;\n}\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#triggering-agent-to-agent-communication","title":"Triggering Agent-to-Agent Communication","text":"<pre><code>[WorkflowUpdate(\"external-event\")]\npublic async Task&lt;WebhookResponse&gt; ExternalEvent(IDictionary&lt;string, string&gt; queryParams, string body)\n{\n    var eventData = JsonSerializer.Deserialize&lt;ExternalEvent&gt;(body);\n\n    // Route to appropriate agent based on event type\n    switch (eventData.Type)\n    {\n        case \"order\":\n            await MessageHub.Agent2Agent.SendData(\n                typeof(OrderProcessingAgent),\n                eventData.Data,\n                \"ProcessOrder\"\n            );\n            break;\n\n        case \"support\":\n            await MessageHub.Agent2Agent.SendChat(\n                typeof(CustomerSupportAgent),\n                eventData.Message\n            );\n            break;\n    }\n\n    var response = new WebhookResponse(HttpStatusCode.OK);\n    response.Content = \"Event routed successfully\";\n    return response;\n}\n</code></pre>"},{"location":"2-agent-communication/17-webhooks/#architecture-notes","title":"Architecture Notes","text":"<p>Webhooks use the Temporal \"Update with Start\" pattern, which provides automatic workflow lifecycle management:</p> <ul> <li>Workflow Running: If the target workflow is already running, the webhook update method is called on the existing instance</li> <li>Workflow Not Running: If no workflow instance exists, the system automatically starts a new workflow instance and then calls the webhook update method</li> <li>Guaranteed Processing: This ensures that webhook requests are never lost, regardless of workflow state</li> </ul> <p>Performance Considerations</p> <p>Webhooks hold HTTP connections until the workflow method completes. For long-running processes, consider returning an immediate acknowledgment and processing asynchronously. Webhook requests will timeout in 30 seconds by default.</p> <p>Complete Sample</p> <p>See the complete webhook implementation example in the A2A Communications Sample repository.</p>"},{"location":"2-agent-communication/2-messaging/","title":"Agent Initiated Message","text":""},{"location":"2-agent-communication/2-messaging/#sending-messages-to-users","title":"Sending Messages to Users","text":"<p>Agents can send messages to users using the <code>_messageThread.SendChat</code> method. This method is designed to be used within a workflow context where an agent needs to communicate with a user.</p>"},{"location":"2-agent-communication/2-messaging/#method-signatures","title":"Method Signatures","text":"<pre><code>// For plain text communication\npublic static async Task&lt;string?&gt; SendChat(\n    string content,           // The message content to send\n    object? data = null   // Optional metadata to attach to the message\n)\n\n// For structured data communication\npublic static async Task&lt;string?&gt; SendData(\n    object data,        // The metadata to send\n    string? content = null   // Optional message content to send\n)\n</code></pre>"},{"location":"2-agent-communication/2-messaging/#usage-example","title":"Usage Example","text":"<pre><code>private readonly MessageThread _messageThread;\n\n// Basic message sending\nawait _messageThread.SendChat(\"Hello user!\");\n\n// Sending a message with metadata\nvar metadata = new { \n    messageType = \"notification\",\n    priority = \"high\"\n};\nawait _messageThread.SendData(metadata);\n</code></pre>"},{"location":"2-agent-communication/2-messaging/#important-notes","title":"Important Notes","text":"<ol> <li>The <code>SendChat</code> method must be called from within a workflow context where <code>AgentContext</code> is properly initialized and the <code>metadata</code> parameter is optional, can be used to attach additional context or information to the message.</li> <li>The <code>SendData</code> method can be used to send structured information to a conversation, chat thread, or messaging system within an application.</li> <li>Both methods returns a <code>Task&lt;string?&gt;</code> which indicates whether the message was sent successfully.</li> </ol>"},{"location":"2-agent-communication/2-messaging/#message-structure","title":"Message Structure","text":"<p>When a message is sent, it is wrapped in an <code>ChatOrDataRequest</code> object with the following properties:</p> <ul> <li>Text: The actual message content</li> <li>ParticipantId: The target user's ID</li> <li>Metadata: Any additional data attached to the message</li> <li>WorkflowId: Automatically populated from AgentContext</li> <li>WorkflowType: Automatically populated from AgentContext</li> <li>Agent: Automatically populated from AgentContext</li> </ul>"},{"location":"2-agent-communication/2-messaging/#return-value","title":"Return Value","text":"<p>The method returns a <code>Task&lt;string?&gt;</code> where the string value is the MessageThread ID if the message was sent successfully. The MessageThread ID can be used to reference this conversation thread in future interactions.</p> <pre><code>var threadId = await _messageThread.SendChat(\"Hello!\");\n_logger.LogInformation($\"Message sent successfully. Thread ID: {threadId}\");\n</code></pre>"},{"location":"2-agent-communication/3-handoffs/","title":"Handoff to Another Agent","text":"<p>Handoffs allow one agent to transfer a conversation to another agent that is better suited to handle the user's request. This is particularly useful when dealing with specialized domains or complex workflows that require different expertise.</p>"},{"location":"2-agent-communication/3-handoffs/#why-use-handoffs","title":"Why Use Handoffs?","text":"<ol> <li>Specialized Expertise: Different agents can be optimized for specific domains or tasks, leading to better and more accurate responses.</li> <li>Improved User Experience: Users get more relevant and focused assistance by being directed to the most appropriate agent.</li> <li>Modular Design: Breaking down complex workflows into specialized agents makes the system more maintainable and easier to update.</li> <li>Better Resource Management: Each agent can be optimized for its specific use case, leading to more efficient resource utilization.</li> </ol>"},{"location":"2-agent-communication/3-handoffs/#implementing-handoffs","title":"Implementing Handoffs","text":"<p>Handoffs are typically implemented as capabilities in your bot flow. Here's how to implement them:</p> <ol> <li>Create a capability class that handles handoffs</li> <li>Register the capability with your agent</li> <li>Implement handoff methods for each target agent</li> </ol>"},{"location":"2-agent-communication/3-handoffs/#example-implementation","title":"Example Implementation","text":"<p><pre><code>using XiansAi.Flow.Router.Plugins;\nusing XiansAi.Messaging;\n\npublic class HandoffCapabilities\n{\n    private readonly MessageThread _messageThread;\n\n    public HandoffCapabilities(MessageThread messageThread)\n    {\n        _messageThread = messageThread;\n    }\n\n    [Capability(\"Hand over to a specialized agent\")]\n    [Parameter(\"originalUserMessage\", \"The original user message\")]\n    [Returns(\"Name of the bot that took over the conversation\")]\n    public string HandoffToSpecializedBot(string originalUserMessage)\n    {\n        // Skip response to prevent duplicate messages (silent handoff)\n        _messageThread.SkipResponse = true;\n\n        _messageThread.SendHandoff(typeof(SpecializedBot), originalUserMessage);\n        return typeof(SpecializedBot).Name;\n    }\n}\n</code></pre> You can also pass a <code>targetWorkflowId</code> instead of <code>workflowType</code> to enable a handoff to a specific workflow instance.</p>"},{"location":"2-agent-communication/3-handoffs/#important-implementation-notes","title":"Important Implementation Notes","text":"<ol> <li>Non-Static Class: The handoff capability class should not be static because it needs to maintain state with the message thread.</li> <li>Constructor Injection: The class requires a <code>MessageThread</code> instance to be passed in the constructor, which is used to perform the actual handoff.</li> <li>Message Thread: The <code>MessageThread</code> class provides the <code>Handoff</code> method that transfers the conversation to another agent.</li> <li>Original Message: The original user message is passed to the new agent to maintain context.</li> </ol>"},{"location":"2-agent-communication/3-handoffs/#registering-handoff-capabilities","title":"Registering Handoff Capabilities","text":"<p>To use handoff capabilities, register them with your agent:</p> <pre><code>using XiansAi.Flow;\nusing DotNetEnv;\n\n// Load the environment variables from the .env file\nEnv.Load();\n\n// name your agent\nvar agent = new AgentTeam(\"Your Agent Name\");\n\nvar bot = agent.AddAgent&lt;YourBot&gt;();\nbot.AddCapabilities&lt;HandoffCapabilities&gt;();\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"2-agent-communication/3-handoffs/#best-practices","title":"Best Practices","text":"<ol> <li>Clear Handoff Triggers: Implement clear conditions for when a handoff should occur</li> <li>Silent Handoffs: Always set <code>_messageThread.SkipResponse = true</code> when performing handoffs to prevent the current agent from sending a response after the handoff. See Skipping Semantic Kernel Response for detailed examples.</li> <li>User Consent: Consider asking for user confirmation before performing a handoff</li> </ol>"},{"location":"2-agent-communication/4-responding/","title":"Responding to a User","text":"<p>Agents can respond to users through the <code>MessageThread</code> interface, which provides methods for sending messages and managing conversations. This is particularly useful when implementing capabilities that need to send responses back to the user.</p> <p>Agents can send messages to users using the <code>_messageThread.SendChat</code> method. This method is designed to be used within a workflow context where an agent needs to communicate with a user.</p>"},{"location":"2-agent-communication/4-responding/#method-signatures","title":"Method Signatures","text":"<pre><code>// For plain text communication\npublic static async Task&lt;string?&gt; SendChat(\n    string content,           // The message content to send\n    object? data = null   // Optional metadata to attach to the message\n)\n\n// For structured data communication\npublic static async Task&lt;string?&gt; SendData(\n    object data,        // The metadata to send\n    string? content = null   // Optional message content to send\n)\n</code></pre>"},{"location":"2-agent-communication/4-responding/#usage-example","title":"Usage Example","text":"<pre><code>private readonly MessageThread _messageThread;\n\n// Basic message sending\nawait _messageThread.SendChat(\"Hello user!\");\n\n// Sending a message with metadata\nvar metadata = new { \n    messageType = \"notification\",\n    priority = \"high\"\n};\nawait _messageThread.SendData(metadata);\n</code></pre>"},{"location":"2-agent-communication/4-responding/#scenario-manual-vs-automatic-responses","title":"Scenario: Manual vs Automatic Responses","text":"<p>The scenario covered in this section focuses on manual responses that you implement programmatically in your agent code, as opposed to the automatic responses that Semantic Kernel generates when processing user requests.</p> <p>While Semantic Kernel automatically generates responses based on your capabilities and function calls, there are situations where you need to:</p> <ul> <li>Send custom formatted messages</li> <li>Respond with structured data</li> <li>Send multiple responses during a single operation</li> <li>Control the exact timing and content of responses</li> <li>Send responses from background processes or workflows</li> </ul> <p>The <code>MessageThread</code> interface allows you to implement these manual response scenarios, giving you full control over when and how your agent communicates with users.</p>"},{"location":"2-agent-communication/4-responding/#implementing-response-capabilities","title":"Implementing Response Capabilities","text":"<p>Similar to handoffs, response capabilities can be implemented in a non-static class that receives the <code>MessageThread</code> instance through constructor injection:</p> <pre><code>using XiansAi.Flow.Router.Plugins;\nusing XiansAi.Messaging;\n\npublic class ResponseCapabilities\n{\n    private readonly MessageThread _messageThread;\n\n    public ResponseCapabilities(MessageThread messageThread)\n    {\n        _messageThread = messageThread;\n    }\n\n    [Capability(\"Send a formatted response to the user\")]\n    [Parameter(\"content\", \"The message content to send\")]\n    [Parameter(\"metadata\", \"Optional metadata to include with the response\")]\n    [Returns(\"The response ID if successful, null otherwise\")]\n    public async Task&lt;string?&gt; SendFormattedResponse(string content, object? data = null)\n    {\n        return await _messageThread.SendChat(content, data);\n    }\n\n    [Capability(\"Send a structured data response\")]\n    [Parameter(\"data\", \"The data to send\")]\n    [Returns(\"The response ID if successful, null otherwise\")]\n    public async Task&lt;string?&gt; SendDataResponse(object data)\n    {\n        ...\n        await _messageThread.SendData(data);\n        ...\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/5-skip-llm-response/","title":"Skipping Semantic Kernel Response","text":""},{"location":"2-agent-communication/5-skip-llm-response/#overview","title":"Overview","text":"<p>In some scenarios, you may want to prevent Semantic Kernel from automatically sending its default response to the user. This can be useful when your capability needs to handle the response manually, send custom formatted messages, or when no response is needed at all.</p> <p>The Xians AI platform provides a way to skip the automatic Semantic Kernel response by setting the <code>SkipResponse</code> property on the <code>MessageThread</code> instance.</p>"},{"location":"2-agent-communication/5-skip-llm-response/#when-to-skip-responses","title":"When to Skip Responses","text":"<p>You might want to skip the automatic response in the following scenarios:</p> <ul> <li>Silent Handoffs: When transferring a conversation to another agent without the current agent sending a response</li> <li>Custom Response Handling: When you need to send a specially formatted response using <code>SendChat</code> or <code>SendData</code></li> <li>Silent Operations: When performing background tasks that don't require user feedback</li> <li>Multi-step Processes: When the capability is part of a larger workflow that will respond later</li> <li>Error Handling: When you want to handle errors gracefully without confusing automatic responses</li> <li>Data Processing: When processing data that doesn't require immediate user notification</li> </ul>"},{"location":"2-agent-communication/5-skip-llm-response/#implementation","title":"Implementation","text":"<p>To skip the Semantic Kernel response, set the <code>SkipResponse</code> property to <code>true</code> in your capability class:</p> <pre><code>using XiansAi.Flow.Router.Plugins;\nusing XiansAi.Messaging;\n\npublic class ProcessingCapabilities\n{\n    private readonly MessageThread _messageThread;\n\n    public ProcessingCapabilities(MessageThread messageThread)\n    {\n        _messageThread = messageThread;\n    }\n\n    [Capability(\"Process data without sending automatic response\")]\n    [Parameter(\"data\", \"The data to process\")]\n    [Returns(\"Processing result\")]\n    public async Task&lt;string&gt; ProcessDataSilently(string data)\n    {\n        // Skip the automatic Semantic Kernel response\n        _messageThread.SkipResponse = true;\n\n        // Perform your processing logic\n        var result = ProcessData(data);\n\n        // Optionally send a custom response if needed\n        if (result.RequiresNotification)\n        {\n            await _messageThread.SendChat($\"Processing completed: {result.Summary}\");\n        }\n\n        return result.Details;\n    }\n\n    [Capability(\"Handle user request with custom response format\")]\n    [Parameter(\"request\", \"The user request\")]\n    [Returns(\"Status of the operation\")]\n    public async Task&lt;string&gt; HandleCustomResponse(string request)\n    {\n        // Skip automatic response to handle manually\n        _messageThread.SkipResponse = true;\n\n        try\n        {\n            var response = await ProcessRequest(request);\n\n            // Send formatted response with metadata\n            var metadata = new {\n                timestamp = DateTime.UtcNow,\n                requestType = \"custom\",\n                status = \"success\"\n            };\n\n            await _messageThread.SendChat(response.Message, metadata);\n            return \"Success\";\n        }\n        catch (Exception ex)\n        {\n            // Send error message manually\n            await _messageThread.SendChat($\"An error occurred: {ex.Message}\");\n            return \"Error\";\n        }\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/5-skip-llm-response/#client-side-handling","title":"Client-Side Handling","text":"<p>When a response is skipped using <code>SkipResponse = true</code>, clients still receive a response from the bot, but with important characteristics that allow for proper handling:</p>"},{"location":"2-agent-communication/5-skip-llm-response/#what-clients-receive","title":"What Clients Receive","text":"<ul> <li>Text Content: The client receives <code>null</code> as the text content instead of an actual message</li> <li>Response Structure: The response still follows the normal bot response format, maintaining consistency</li> <li>Processing Signal: This serves as a signal that the agent's processing is complete</li> </ul>"},{"location":"2-agent-communication/5-skip-llm-response/#client-implementation","title":"Client Implementation","text":"<p>Clients should check for <code>null</code> text content and handle it appropriately:</p> <pre><code>// Example client-side handling\nfunction handleBotResponse(responseText) {\n    if (responseText === null) {\n        // Mark processing as complete\n        setProcessingComplete(true);\n        return;\n    } else {\n        // Normal response - render the message\n        displayMessage(responseText);\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/5-skip-llm-response/#why-this-design","title":"Why This Design","text":"<p>This approach provides several benefits:</p> <ol> <li>Processing Completion Signal: Clients know when the agent has finished processing, even without a visible response</li> <li>UI State Management: Allows clients to properly hide typing indicators and loading states</li> <li>Consistent Response Format: Maintains the same response structure for easier client implementation</li> <li>Silent Operations Support: Enables smooth user experience for background operations and handoffs</li> </ol>"},{"location":"2-agent-communication/5-skip-llm-response/#usage-patterns","title":"Usage Patterns","text":""},{"location":"2-agent-communication/5-skip-llm-response/#1-silent-handoffs","title":"1. Silent Handoffs","text":"<p>This is one of the most important use cases for skipping responses. When one agent hands off to another agent, the first agent should skip its response to prevent duplicate or confusing messages to the user.</p> <pre><code>[Capability(\"Transfer conversation to specialized support agent\")]\n[Parameter(\"userQuery\", \"The user's original query\")]\n[Parameter(\"context\", \"Additional context for the handoff\")]\npublic async Task&lt;string&gt; HandoffToSupportAgent(string userQuery, string context = \"\")\n{\n    // Skip response from this agent since the target agent will handle communication\n    _messageThread.SkipResponse = true;\n\n    // Prepare handoff context\n    var handoffMessage = string.IsNullOrEmpty(context) \n        ? userQuery \n        : $\"{userQuery}\\n\\nContext: {context}\";\n\n    // Perform the handoff\n    _messageThread.SendHandoff(typeof(SupportBot), handoffMessage);\n\n    return \"Handoff completed to support agent\";\n}\n\n[Capability(\"Route technical queries to engineering team\")]\n[Parameter(\"technicalQuery\", \"The technical question from the user\")]\n[Parameter(\"urgency\", \"Priority level: low, medium, high\")]\npublic async Task&lt;string&gt; RouteToEngineering(string technicalQuery, string urgency = \"medium\")\n{\n    // Silent handoff - no response from routing agent\n    _messageThread.SkipResponse = true;\n\n    // Add routing metadata to the handoff\n    var routingContext = $\"Priority: {urgency}\\nQuery: {technicalQuery}\";\n\n    // Hand off to engineering bot\n    _messageThread.SendHandoff(typeof(EngineeringBot), routingContext);\n\n    return $\"Routed to engineering with {urgency} priority\";\n}\n\n[Capability(\"Escalate complex issues to human agent\")]\n[Parameter(\"issue\", \"Description of the complex issue\")]\n[Parameter(\"previousAttempts\", \"What has been tried so far\")]\npublic async Task&lt;string&gt; EscalateToHuman(string issue, string previousAttempts = \"\")\n{\n    _messageThread.SkipResponse = true;\n\n    var escalationContext = $\"Issue: {issue}\";\n    if (!string.IsNullOrEmpty(previousAttempts))\n    {\n        escalationContext += $\"\\nPrevious attempts: {previousAttempts}\";\n    }\n\n    // Handoff to human agent workflow\n    _messageThread.SendHandoff(typeof(HumanAgentBot), escalationContext);\n\n    return \"Escalated to human agent\";\n}\n</code></pre>"},{"location":"2-agent-communication/5-skip-llm-response/#2-silent-background-processing","title":"2. Silent Background Processing","text":"<pre><code>[Capability(\"Start background task\")]\n[Parameter(\"taskData\", \"Data for the background task\")]\npublic async Task&lt;string&gt; StartBackgroundTask(string taskData)\n{\n    _messageThread.SkipResponse = true;\n\n    // Start the task without immediate response\n    _ = Task.Run(async () =&gt; await ProcessInBackground(taskData));\n\n    return \"Task started\";\n}\n</code></pre>"},{"location":"2-agent-communication/5-skip-llm-response/#2-conditional-response-handling","title":"2. Conditional Response Handling","text":"<pre><code>[Capability(\"Process with conditional response\")]\n[Parameter(\"input\", \"Input to process\")]\n[Parameter(\"silent\", \"Whether to process silently\")]\npublic async Task&lt;string&gt; ConditionalProcess(string input, bool silent = false)\n{\n    if (silent)\n    {\n        _messageThread.SkipResponse = true;\n    }\n\n    var result = await ProcessInput(input);\n\n    if (!silent)\n    {\n        // Let Semantic Kernel handle the response automatically\n        return $\"Processed: {result}\";\n    }\n\n    // Silent mode - no response will be sent\n    return result;\n}\n</code></pre>"},{"location":"2-agent-communication/5-skip-llm-response/#4-custom-error-handling","title":"4. Custom Error Handling","text":"<pre><code>[Capability(\"Validate and process data\")]\n[Parameter(\"data\", \"Data to validate and process\")]\npublic async Task&lt;string&gt; ValidateAndProcess(string data)\n{\n    var validation = ValidateData(data);\n\n    if (!validation.IsValid)\n    {\n        // Skip automatic response to send custom error format\n        _messageThread.SkipResponse = true;\n\n        var errorResponse = new {\n            error = true,\n            message = validation.ErrorMessage,\n            suggestions = validation.Suggestions\n        };\n\n        await _messageThread.SendData(errorResponse, \"Validation failed\");\n        return \"Validation error\";\n    }\n\n    // Valid data - let Semantic Kernel respond normally\n    return ProcessValidData(data);\n}\n</code></pre>"},{"location":"2-agent-communication/5-skip-llm-response/#important-notes","title":"Important Notes","text":"<ol> <li> <p>Property Setting: The <code>SkipResponse</code> property must be set within the same capability method that you want to skip the response for.</p> </li> <li> <p>Response Responsibility: When you skip the automatic response, you become responsible for providing user feedback if needed. Consider the user experience carefully.</p> </li> <li> <p>Return Values: Even when skipping responses, your capability method should still return meaningful values for logging and internal processing purposes.</p> </li> <li> <p>Error Handling: Be especially careful with error scenarios when skipping responses - users should still be informed of failures through manual responses.</p> </li> <li> <p>Threading: The <code>SkipResponse</code> property affects only the current execution context and thread.</p> </li> </ol>"},{"location":"2-agent-communication/5-skip-llm-response/#best-practices","title":"Best Practices","text":"<ul> <li>Use Sparingly: Only skip responses when you have a specific need and plan to handle user communication manually</li> <li>Silent Handoffs: Always use <code>SkipResponse = true</code> when performing handoffs to prevent duplicate responses</li> <li>Provide Feedback: If the operation takes time, consider sending progress updates using <code>SendChat</code></li> <li>Handle Errors: Always ensure users receive appropriate error messages, even in skip response scenarios</li> <li>Document Behavior: Clearly document when and why capabilities skip automatic responses</li> <li>Test Handoff Flows: Verify that handoff scenarios work smoothly and users don't experience communication gaps</li> <li>Test Thoroughly: Verify that the user experience remains smooth when responses are skipped</li> </ul>"},{"location":"2-agent-communication/6-forward-message/","title":"Inter-Bot Communication with ForwardMessage","text":""},{"location":"2-agent-communication/6-forward-message/#overview","title":"Overview","text":"<p>The <code>ForwardMessage</code> feature enables seamless communication between different bots within a multi-agent system. This functionality is crucial for implementing complex workflows where specialized bots need to collaborate to accomplish tasks that require diverse expertise.</p>"},{"location":"2-agent-communication/6-forward-message/#example-scenario-hr-management-system","title":"Example Scenario: HR Management System","text":"<p>Throughout this documentation, we'll use a comprehensive HR Management System to illustrate inter-bot communication. This system consists of:</p> <p>System Components:</p> <ul> <li>Router Bot: Central coordinator that analyzes user queries and routes them to appropriate specialized bots</li> <li>HireBot: Expert recruiter handling job openings, applications, interviews, and onboarding processes</li> <li>PayBot: Payroll specialist managing salary information, deductions, reimbursements, and tax queries  </li> <li>CareBot: Employee well-being assistant handling grievances, benefits, and care-related concerns</li> </ul> <p>Example Query: \"I heard there's a new position in my department. What's the salary range, and what benefits are included? Also, I'm interested in applying - what's the process?\"</p> <p>This single query requires coordination between all three specialized bots to provide a comprehensive response.</p>"},{"location":"2-agent-communication/6-forward-message/#why-inter-bot-communication-matters","title":"Why Inter-Bot Communication Matters","text":"<p>Separation of Concerns: Each bot focuses on its specific domain expertise while leveraging capabilities of other bots when needed.</p> <p>Scalability: New bots can be added without modifying existing bots, promoting modular architecture.</p> <p>Workflow Orchestration: Complex tasks can be broken down and distributed across multiple specialized bots.</p>"},{"location":"2-agent-communication/6-forward-message/#router-bot-architecture","title":"Router Bot Architecture","text":"<p>The Router Bot pattern implements a centralized communication hub:</p> <pre><code>                    User Query\n                         \u2193\n                    Router Bot\n                   (Coordinator)\n                         \u2193\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2193          \u2193          \u2193\n         HireBot      PayBot      CareBot\n        (Recruit)    (Payroll)   (Wellbeing)\n              \u2193          \u2193          \u2193\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2193\n                   Router Bot\n               (Synthesizes Response)\n                         \u2193\n                  Complete Answer\n</code></pre>"},{"location":"2-agent-communication/6-forward-message/#implementation","title":"Implementation","text":""},{"location":"2-agent-communication/6-forward-message/#system-setup-programcs","title":"System Setup (Program.cs)","text":"<pre><code>using XiansAi.Flow;\nusing DotNetEnv;\n\nEnv.Load();\n\nvar agent = new AgentTeam(\"HR Agent\");\n\n// Router Bot - Central communication hub\nvar RouteBot = agent.AddAgent&lt;RouterBot&gt;();\nRouteBot.AddCapabilities&lt;AskBotCapabilitiesForRouterBot&gt;();\n\n// Specialized Bots\nvar CareBot = agent.AddAgent&lt;CareBot&gt;();\nvar HireBot = agent.AddAgent&lt;HireBot&gt;();\nvar PayBot = agent.AddAgent&lt;PayBot&gt;();\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"2-agent-communication/6-forward-message/#router-bot-routerbotcs","title":"Router Bot (RouterBot.cs)","text":"<pre><code>using Temporalio.Workflows;\nusing XiansAi.Flow;\n\n[Workflow(\"HR Agent:Router Bot\")]\npublic class RouterBot : RouterFlowBase\n{    \n    [WorkflowRun]\n    public async Task Run()\n    {\n        var sysPrompt = @\"You are the Router Bot, a supervisor agent responsible for coordinating with specialized bots to assist employees effectively. Your task is to analyze each user query, determine the appropriate specialized bot(s) to handle the request, and synthesize a comprehensive response.\n\nYou coordinate with:\n- HireBot: Handles hiring process, job openings, applications, interviews, and onboarding\n- PayBot: Manages payroll, salary components, deductions, and tax-related queries\n- CareBot: Handles employee grievances, well-being concerns, and benefits\n\nProcess:\n1. Analyze user queries to determine their nature\n2. Forward queries to appropriate bot(s) based on expertise\n3. Combine responses into one clear, complete reply\n4. Always respond as a unified HR assistant\";\n\n        await InitConversation(sysPrompt);\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/6-forward-message/#router-bot-capabilities","title":"Router Bot Capabilities","text":"<pre><code>using XiansAi.Flow.Router.Plugins;\nusing XiansAi.Messaging;\n\npublic class AskBotCapabilitiesForRouterBot\n{\n    private readonly MessageThread _messageThread;\n\n    public AskBotCapabilitiesForRouterBot(MessageThread messageThread)\n    {\n        _messageThread = messageThread;\n    }\n\n    [Capability(\"Ask from Care Bot\")]\n    [Parameter(\"routerBotMessage\", \"The message crafted by the Router Bot for the target bot\")]\n    [Returns(\"Response from Care Bot\")]\n    public async Task&lt;string&gt; AskFromCareBot(string routerBotMessage)\n    {\n        var response = await _messageThread.ForwardMessage(typeof(CareBot), routerBotMessage);\n        return response.Text;\n    }\n\n    [Capability(\"Ask from Hire Bot\")]\n    [Parameter(\"routerBotMessage\", \"The message crafted by the Router Bot for the target bot\")]\n    [Returns(\"Response from Hire Bot\")]\n    public async Task&lt;string&gt; AskFromHireBot(string routerBotMessage)\n    {\n        var response = await _messageThread.ForwardMessage(typeof(HireBot), routerBotMessage);\n        return response.Text;\n    }\n\n    [Capability(\"Ask from Pay Bot\")]\n    [Parameter(\"routerBotMessage\", \"The message crafted by the Router Bot for the target bot\")]\n    [Returns(\"Response from Pay Bot\")]\n    public async Task&lt;string&gt; AskFromPayBot(string routerBotMessage)\n    {\n        var response = await _messageThread.ForwardMessage(typeof(PayBot), routerBotMessage);\n        return response.Text;\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/6-forward-message/#how-forwardmessage-works","title":"How ForwardMessage Works","text":""},{"location":"2-agent-communication/6-forward-message/#core-mechanism","title":"Core Mechanism","text":"<pre><code>var response = await _messageThread.ForwardMessage(typeof(TargetBot), message);\n</code></pre> <p>Parameters: - <code>typeof(TargetBot)</code>: The type of the destination bot - <code>message</code>: The message content to be forwarded</p> <p>Return Value: - Returns a <code>MessageResponse</code> object containing:   - <code>Text</code>: The response message text   - <code>Data</code>: Optional structured data   - <code>Id</code>: Message identifier   - <code>Timestamp</code>: When the message was created   - <code>Direction</code>: Message direction (incoming/outgoing)   - <code>MessageType</code>: Type of message   - <code>Scope</code>: Message scope   - <code>Hint</code>: Optional hint information   - <code>RequestId</code>: Request identifier   - <code>ThreadId</code>: Thread identifier</p> <p>Process Flow: 1. Router Bot receives user request 2. Analyzes request and determines appropriate specialized bot 3. Crafts specific message for target bot 4. <code>ForwardMessage</code> sends message to target bot 5. Target bot processes message using its specialized capabilities 6. Response returns through message thread 7. Router Bot synthesizes final response</p> <p>**Best Practices: - Use descriptive parameter names - Explain parameter content and format - Document return value expectations - Include context and requirements</p>"},{"location":"2-agent-communication/6-forward-message/#working-with-messageresponse","title":"Working with MessageResponse","text":"<p>The <code>ForwardMessage</code> method returns a <code>MessageResponse</code> object that contains both the text response and additional metadata:</p> <pre><code>[Capability(\"Advanced Web Search\")]\n[Parameter(\"query\", \"Search query\")]\n[Returns(\"Search results with metadata\")]\npublic async Task&lt;string&gt; AdvancedWebSearch(string query)\n{\n    var response = await _messageThread.ForwardMessage(typeof(WebBot), query);\n\n    // Access the text response\n    var searchResults = response.Text;\n\n    // Access additional metadata if needed\n    var messageId = response.Id;\n    var timestamp = response.Timestamp;\n    var threadId = response.ThreadId;\n\n    // Access structured data if the bot returns it\n    if (response.Data != null)\n    {\n        // Process structured data\n        var structuredData = response.Data;\n    }\n\n    return searchResults;\n}\n</code></pre> <p>Available Properties: - <code>Text</code>: The main response message text - <code>Data</code>: Optional structured data (can be any object) - <code>Id</code>: Unique message identifier - <code>Timestamp</code>: When the message was created - <code>Direction</code>: Message direction indicator - <code>MessageType</code>: Type classification of the message - <code>Scope</code>: Message scope information - <code>Hint</code>: Optional hint or context information - <code>RequestId</code>: Associated request identifier - <code>ThreadId</code>: Thread identifier for conversation tracking</p>"},{"location":"2-agent-communication/6-forward-message/#communication-patterns","title":"Communication Patterns","text":""},{"location":"2-agent-communication/6-forward-message/#1-sequential-processing","title":"1. Sequential Processing","text":"<pre><code>[Capability(\"Process Employee Onboarding\")]\n[Parameter(\"employeeData\", \"New employee information\")]\n[Returns(\"Complete onboarding status\")]\npublic async Task&lt;string&gt; ProcessOnboarding(string employeeData)\n{\n    var hireResult = await AskFromHireBot($\"Create employee: {employeeData}\");\n    var payResult = await AskFromPayBot($\"Setup payroll for: {hireResult}\");\n    var careResult = await AskFromCareBot($\"Schedule orientation for: {hireResult}\");\n\n    return $\"Onboarding completed:\\n{hireResult}\\n{payResult}\\n{careResult}\";\n}\n</code></pre>"},{"location":"2-agent-communication/6-forward-message/#2-parallel-processing-broadcast","title":"2. Parallel Processing (Broadcast)","text":"<pre><code>[Capability(\"Broadcast to All Bots\")]\n[Parameter(\"query\", \"Query to send to all bots\")]\n[Returns(\"Combined responses from all bots\")]\npublic async Task&lt;string&gt; BroadcastQuery(string query)\n{\n    var tasks = new[]\n    {\n        _messageThread.ForwardMessage(typeof(HireBot), query),\n        _messageThread.ForwardMessage(typeof(PayBot), query),\n        _messageThread.ForwardMessage(typeof(CareBot), query)\n    };\n\n    var responses = await Task.WhenAll(tasks);\n    var responseTexts = responses.Select(r =&gt; r.Text);\n    return string.Join(\"\\n---\\n\", responseTexts);\n}\n</code></pre>"},{"location":"2-agent-communication/6-forward-message/#3-conditional-routing","title":"3. Conditional Routing","text":"<pre><code>[Capability(\"Smart Route Query\")]\n[Parameter(\"query\", \"User query to route\")]\n[Returns(\"Response from appropriate bot\")]\npublic async Task&lt;string&gt; SmartRoute(string query)\n{\n    if (query.Contains(\"salary\") || query.Contains(\"pay\"))\n        return await AskFromPayBot(query);\n    else if (query.Contains(\"hiring\") || query.Contains(\"recruitment\"))\n        return await AskFromHireBot(query);\n    else if (query.Contains(\"benefits\") || query.Contains(\"care\"))\n        return await AskFromCareBot(query);\n    else\n        return \"Please specify if your query is about pay, hiring, or employee care.\";\n}\n</code></pre>"},{"location":"2-agent-communication/6-forward-message/#4-pipeline-processing","title":"4. Pipeline Processing","text":"<pre><code>[Capability(\"Pipeline Processing\")]\n[Parameter(\"inputData\", \"Raw data to process through pipeline\")]\n[Returns(\"Fully processed result\")]\npublic async Task&lt;string&gt; PipelineProcess(string inputData)\n{\n    var stage1Response = await _messageThread.ForwardMessage(typeof(HireBot), \n        $\"Validate and prepare: {inputData}\");\n    var stage2Response = await _messageThread.ForwardMessage(typeof(PayBot), \n        $\"Process data: {stage1Response.Text}\");\n    var stage3Response = await _messageThread.ForwardMessage(typeof(CareBot), \n        $\"Format final output: {stage2Response.Text}\");\n\n    return stage3Response.Text;\n}\n</code></pre>"},{"location":"2-agent-communication/6-forward-message/#5-event-driven-communication","title":"5. Event-Driven Communication","text":"<pre><code>[Capability(\"Handle Events\")]\n[Parameter(\"eventType\", \"Type of event (NewEmployee, SalaryReview, etc.)\")]\n[Parameter(\"eventData\", \"Event-specific data\")]\n[Returns(\"Event processing results\")]\npublic async Task&lt;string&gt; HandleEvent(string eventType, string eventData)\n{\n    var responses = new List&lt;string&gt;();\n\n    switch (eventType)\n    {\n        case \"NewEmployee\":\n            var hireResponse = await _messageThread.ForwardMessage(typeof(HireBot), \n                $\"Process new employee: {eventData}\");\n            responses.Add(hireResponse.Text);\n\n            var payResponse = await _messageThread.ForwardMessage(typeof(PayBot), \n                $\"Setup payroll for: {eventData}\");\n            responses.Add(payResponse.Text);\n\n            var careResponse = await _messageThread.ForwardMessage(typeof(CareBot), \n                $\"Schedule orientation for: {eventData}\");\n            responses.Add(careResponse.Text);\n            break;\n\n        case \"SalaryReview\":\n            var payReviewResponse = await _messageThread.ForwardMessage(typeof(PayBot), \n                $\"Review salary: {eventData}\");\n            responses.Add(payReviewResponse.Text);\n\n            var careMeetingResponse = await _messageThread.ForwardMessage(typeof(CareBot), \n                $\"Schedule review meeting: {eventData}\");\n            responses.Add(careMeetingResponse.Text);\n            break;\n    }\n\n    return string.Join(\"\\n\\n\", responses);\n}\n</code></pre>"},{"location":"2-agent-communication/6-forward-message/#best-practices","title":"Best Practices","text":""},{"location":"2-agent-communication/6-forward-message/#message-crafting","title":"Message Crafting","text":"<ul> <li>Create specific, contextual messages for each target bot</li> <li>Include relevant context and parameters</li> <li>Use clear, unambiguous language</li> </ul>"},{"location":"2-agent-communication/6-forward-message/#error-handling","title":"Error Handling","text":"<pre><code>public async Task&lt;string&gt; SafeForwardMessage(Type botType, string message)\n{\n    try\n    {\n        var response = await _messageThread.ForwardMessage(botType, message);\n        return response?.Text ?? \"No response received\";\n    }\n    catch (Exception ex)\n    {\n        return $\"Error communicating with bot: {ex.Message}\";\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/6-forward-message/#configuration","title":"Configuration","text":"<p>Ensure proper bot registration and capability assignment: <pre><code>var agent = new AgentTeam(\"Your Agent Name\");\nvar routerBot = agent.AddAgent&lt;RouterBot&gt;();\nrouterBot.AddCapabilities&lt;InterBotCommunicationCapabilities&gt;();\n</code></pre></p>"},{"location":"2-agent-communication/6-forward-message/#conclusion","title":"Conclusion","text":"<p>The ForwardMessage feature enables building sophisticated multi-agent systems with:</p> <ul> <li>Modular Architecture: Each bot maintains specialized focus</li> <li>Scalable Communication: Easy to add new bots and communication paths</li> <li>Complex Workflow Support: Orchestrate multi-step processes across bots</li> <li>Maintainable Code: Clear separation of concerns and responsibilities</li> </ul> <p>This pattern is essential for building robust, extensible AI agent systems that handle complex, multi-domain tasks efficiently.</p>"},{"location":"2-agent-communication/8-handling-data-messages/","title":"Handling Data Messages","text":"<p>When sending structured data messages to agents, you have two distinct approaches available, each designed for different use cases and requirements.</p>"},{"location":"2-agent-communication/8-handling-data-messages/#two-approaches-overview","title":"Two Approaches Overview","text":""},{"location":"2-agent-communication/8-handling-data-messages/#1-data-as-messages","title":"1. Data as Messages","text":"<p>Process data messages manually within the Temporal workflow class using event listeners and queuing mechanisms.</p> <p>Data Message Handling Documentation</p> <p>For complete implementation details, see Handling Data Messages.</p>"},{"location":"2-agent-communication/8-handling-data-messages/#2-data-as-rpc-dataprocessor","title":"2. Data as RPC (DataProcessor)","text":"<p>Use a simplified RPC-style approach by setting a DataProcessor class to handle data messages as atomic operations.</p> <p>Data Processing PRC Implementation</p> <p>For complete implementation details, see RPC Data Processing.</p>"},{"location":"2-agent-communication/8-handling-data-messages/#when-to-use-each-approach","title":"When to Use Each Approach","text":""},{"location":"2-agent-communication/8-handling-data-messages/#use-manual-data-handling-when","title":"Use Manual Data Handling When","text":"<ul> <li>\u2705 You need long-running workflows with complex orchestration</li> <li>\u2705 You require Temporal workflow capabilities (retries, timers, child workflows)</li> <li>\u2705 You need to coordinate multiple activities over time</li> <li>\u2705 You need durability and fault tolerance for complex business processes</li> </ul>"},{"location":"2-agent-communication/8-handling-data-messages/#use-rpc-abstraction-when","title":"Use RPC Abstraction When","text":"<ul> <li>\u2705 You need simple, atomic operations (request \u2192 process \u2192 respond)</li> <li>\u2705 You want immediate responses without workflow overhead</li> <li>\u2705 You prefer simplified development with less boilerplate</li> <li>\u2705 You don't need Temporal orchestration features</li> </ul>"},{"location":"2-agent-communication/8-handling-data-messages/#comparison-matrix","title":"Comparison Matrix","text":"Feature Manual Handling RPC Abstraction Execution Context Full Temporal Workflow Single Temporal Activity Orchestration \u2705 Full capabilities \u274c Not available Complexity Higher (manual queuing) Lower (automatic handling) Fault Tolerance \u2705 Full Temporal guarantees Limited (activity-level only) Use Case Complex business processes Simple data calls <p>Data messages require explicit handling in agent flows, unlike chat messages which are automatically processed by SemanticKernel.</p>"},{"location":"2-agent-communication/8-handling-data-messages/#chat-vs-data-messages","title":"Chat vs Data Messages","text":"<p>Chat Messages:</p> <ul> <li>Automatically intercepted by SemanticKernel when <code>await InitConversation()</code> is called under the <code>[WorkflowRun]</code> method</li> <li>Routed directly to Semantic Kernel for processing</li> </ul> <p>Data Messages:</p> <ul> <li>NOT routed to Semantic Kernel</li> <li>Require explicit listeners and manual processing</li> <li>Best practice: Queue messages and process them in the <code>[WorkflowRun]</code> method</li> </ul>"},{"location":"2-agent-communication/8-handling-data-messages/#implementation-pattern","title":"Implementation Pattern","text":""},{"location":"2-agent-communication/8-handling-data-messages/#1-setup-data-handler-subscription","title":"1. Setup Data Handler Subscription","text":"<p>Subscribe to data messages in your flow constructor:</p> <pre><code>public DocumentDataFlow()\n{\n    _messageHub.SubscribeDataHandler(\n        (MessageThread thread) =&gt; {\n            _logger.LogInformation($\"MessageThread received: {thread.ThreadId}\");\n            _messageQueue.Enqueue(thread);\n        });\n}\n</code></pre>"},{"location":"2-agent-communication/8-handling-data-messages/#2-queue-messages","title":"2. Queue Messages","text":"<p>Use a concurrent queue to store incoming data messages:</p> <pre><code>private readonly ConcurrentQueue&lt;MessageThread&gt; _messageQueue = new();\n</code></pre>"},{"location":"2-agent-communication/8-handling-data-messages/#3-process-messages-in-workflowrun","title":"3. Process Messages in WorkflowRun","text":"<p>Handle queued messages in your main workflow loop:</p> <pre><code>[WorkflowRun]\npublic async Task Run()\n{\n    while (true)\n    {\n        var messageThread = await DequeueMessage();\n        if (messageThread == null) continue;\n\n        var messageType = Message.GetMessageType(messageThread);\n\n        if (messageType == nameof(FetchDocument))\n        {\n            await HandleDocumentRequest(messageThread);\n        }\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/8-handling-data-messages/#4-dequeue-messages-deterministically","title":"4. Dequeue Messages Deterministically","text":"<pre><code>private async Task&lt;MessageThread?&gt; DequeueMessage()\n{\n    await Workflow.WaitConditionAsync(() =&gt; _messageQueue.Count &gt; 0);\n    return _messageQueue.TryDequeue(out var thread) ? thread : null;\n}\n</code></pre>"},{"location":"2-agent-communication/8-handling-data-messages/#complete-example","title":"Complete Example","text":"<pre><code>[Workflow(\"Document Data Flow\")]\npublic class DocumentDataFlow : FlowBase\n{\n    private readonly ConcurrentQueue&lt;MessageThread&gt; _messageQueue = new();\n    private static readonly Logger&lt;DocumentDataFlow&gt; _logger = Logger&lt;DocumentDataFlow&gt;.For();\n\n    public DocumentDataFlow()\n    {\n        _messageHub.SubscribeDataHandler(\n            (MessageThread thread) =&gt; {\n                _logger.LogInformation($\"MessageThread received: {thread.ThreadId}\");\n                _messageQueue.Enqueue(thread);\n            });\n    }\n\n    [WorkflowRun]\n    public async Task Run()\n    {\n        while (true)\n        {\n            try\n            {\n                var messageThread = await DequeueMessage();\n                if (messageThread == null) continue;\n\n                var messageType = Message.GetMessageType(messageThread);\n\n                if (messageType == nameof(FetchDocument))\n                {\n                    await HandleDocumentRequest(messageThread);\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\"Error processing data message\", ex);\n            }\n        }\n    }\n\n    private async Task HandleDocumentRequest(MessageThread messageThread)\n    {\n        var documentRequest = FetchDocument.FromThread(messageThread);\n\n        var result = await Workflow.ExecuteActivityAsync(\n            (IDocumentDataActivities act) =&gt; act.ValidateDocument(documentRequest.DocumentId), \n            _activityOptions);\n\n        await messageThread.SendData(new DocumentResponse {\n            AuditResult = result,\n        });\n    }\n}\n</code></pre>"},{"location":"2-agent-communication/8-handling-data-messages/#key-points","title":"Key Points","text":"<ul> <li>Data messages bypass SemanticKernel and require manual handling</li> <li>Always use deterministic queuing with <code>Workflow.WaitConditionAsync()</code></li> <li>Process messages within the <code>[WorkflowRun]</code> method for proper Temporal workflow execution</li> <li>Handle exceptions to prevent workflow failures</li> </ul>"},{"location":"3-knowledge/1-using-portal/","title":"Knowledge","text":""},{"location":"3-knowledge/1-using-portal/#what-is-knowledge","title":"What is Knowledge?","text":"<p>Knowledge are essential components that guide how AI agents (or other conventional agents) behave in your activities. Think of knowledge as a set of rules and guidelines that define:</p> <ul> <li>How agents should respond to different situations</li> <li>What tone and style they should use</li> <li>What tasks they should perform</li> <li>What limitations they should observe</li> <li>How output should be formatted</li> </ul> <p>Most agents in XiansAI are designed to be flexible and can adapt their behavior based on the knowledge you provide. This allows you to customize agents for different use cases without creating new ones from scratch.</p>"},{"location":"3-knowledge/1-using-portal/#creating-knowledge","title":"Creating Knowledge","text":"<p>To create new knowledge:</p> <ol> <li>Log in to the XiansAI portal</li> <li>Navigate to the Knowledge section</li> <li>Click the \"Create New\" button</li> </ol> <p></p>"},{"location":"3-knowledge/1-using-portal/#best-practices-for-writing-knowledge","title":"Best Practices for Writing Knowledge","text":"<ul> <li>Be specific and clear about what you want the agent to do</li> <li>Use examples when possible</li> <li>Break down complex tasks into smaller steps</li> <li>Include any necessary constraints or limitations</li> <li>Test your knowledge with different scenarios</li> </ul>"},{"location":"3-knowledge/1-using-portal/#versioning-knowledge","title":"Versioning Knowledge","text":"<p>Knowledge in XiansAI support versioning, allowing you to:</p> <ul> <li>Track changes over time</li> <li>Roll back to previous versions if needed</li> <li>Test different variations of knowledge</li> <li>Maintain consistency across your applications</li> </ul> <p></p>"},{"location":"3-knowledge/1-using-portal/#creating-new-versions","title":"Creating New Versions","text":"<p>To create a new version:</p> <ol> <li>Open the knowledge details page on side panel</li> <li>Click the 'Create New Version' button</li> <li>Make your changes to the content</li> <li>Save the new version</li> </ol> <p></p>"},{"location":"3-knowledge/1-using-portal/#version-management","title":"Version Management","text":"<ul> <li>By default, agents use the latest version of knowledge</li> <li>You can specify a particular version when requesting for knowledge</li> <li>Previous versions are preserved and can be restored if needed</li> </ul>"},{"location":"3-knowledge/2-accessing-knowledge/","title":"Accessing Knowledge","text":"<p>The <code>KnowledgeHub</code> class provides a centralized way for agents to access and update knowledge in the system. It handles both workflow and non-workflow contexts automatically, ensuring proper execution of knowledge operations.</p>"},{"location":"3-knowledge/2-accessing-knowledge/#fetching-knowledge","title":"Fetching Knowledge","text":"<p>To retrieve knowledge from the system, use the <code>Fetch</code> method:</p> <pre><code>var knowledge = await KnowledgeHub.Fetch(\"knowledgeName\");\n</code></pre> <p>This method will:</p> <ol> <li>Return the latest version of the specified knowledge</li> <li>If a tenant-specific version exists, it will be returned</li> <li>If no tenant-specific version exists, it will return the latest global version</li> <li>Returns <code>null</code> if no knowledge is found</li> </ol> <p>The method automatically handles:</p> <ul> <li>Workflow contexts through Temporal activities</li> <li>Direct execution in non-workflow contexts</li> </ul>"},{"location":"3-knowledge/2-accessing-knowledge/#updating-knowledge","title":"Updating Knowledge","text":"<p>To update or create new knowledge, use the <code>Update</code> method:</p> <pre><code>var success = await KnowledgeHub.Update(\n    \"knowledgeName\",\n    \"knowledgeType\",\n    \"knowledgeContent\"\n);\n</code></pre> <p>Parameters:</p> <ul> <li><code>knowledgeName</code>: The identifier for the knowledge</li> <li><code>knowledgeType</code>: The type/format of the knowledge</li> <li><code>knowledgeContent</code>: The actual content of the knowledge</li> </ul> <p>The method:</p> <ul> <li>Returns <code>true</code> if the update was successful</li> <li>Throws an exception with details if the update fails</li> <li>Handles both workflow and non-workflow contexts automatically</li> </ul>"},{"location":"3-knowledge/2-accessing-knowledge/#usage-examples","title":"Usage Examples","text":"<pre><code>// Inside a workflow\nvar knowledge = await KnowledgeHub.Fetch(\"company policies\");\n\n// Outside a workflow\nvar knowledge = await KnowledgeHub.Fetch(\"product documentation\");\n</code></pre> <pre><code>// Inside a workflow\nvar success = await KnowledgeHub.Update(\n    \"company_policies\",\n    \"markdown\",\n    \"# Company Policies\\n\\n1. Policy one\\n2. Policy two\"\n);\n\n// Outside a workflow\nvar success = await KnowledgeHub.Update(\n    \"product_documentation\",\n    \"markdown\",\n    \"# Product Documentation\\n\\n## Features\\n...\"\n);\n</code></pre>"},{"location":"3-knowledge/3-capabilities/","title":"Capabilities as Knowledge","text":"<p>While capabilities can be defined directly in code using attributes, Xians provides a more flexible way to manage capability descriptions through the portal using knowledge items. This approach allows you to modify capability descriptions without requiring code changes and redeployment.</p>"},{"location":"3-knowledge/3-capabilities/#knowledge-based-capability-descriptions","title":"Knowledge-Based Capability Descriptions","text":"<p>Capability descriptions can be managed as knowledge items in the portal, following a specific JSON structure:</p> <pre><code>{\n  \"description\": \"Detailed description of what the capability does\",\n  \"returns\": \"Description of what the capability returns\",\n  \"parameters\": {\n    \"parameterName1\": \"Description of parameter 1\",\n    \"parameterName2\": \"Description of parameter 2\"\n  }\n}\n</code></pre>"},{"location":"3-knowledge/3-capabilities/#knowledge-item-structure","title":"Knowledge Item Structure","text":"<ul> <li><code>description</code>: A clear explanation of what the capability does</li> <li><code>returns</code>: Description of the return value or outcome</li> <li><code>parameters</code>: An object containing parameter names and their descriptions</li> </ul>"},{"location":"3-knowledge/3-capabilities/#linking-knowledge-to-capabilities","title":"Linking Knowledge to Capabilities","text":"<p>To link a knowledge item to a capability, use the <code>[Knowledge]</code> attribute in your code:</p> <pre><code>[Knowledge(\"Your Capability Name\")]\npublic async Task&lt;string&gt; YourCapabilityMethod(\n    string parameter1,\n    string parameter2)\n{\n    // Implementation\n}\n</code></pre> <p>The knowledge item name in the <code>[Knowledge]</code> attribute should match the name of the knowledge item created in the portal.</p>"},{"location":"3-knowledge/3-capabilities/#example","title":"Example","text":"<p>Here's a complete example of a capability with its corresponding knowledge item:</p> <p>Name of the knowledge item: <code>Capability - Upload pre-assessment</code></p> <pre><code>// Knowledge Item in Portal\n{\n  \"description\": \"Create a patient ticket for summarization workflow. Confirm with the user before proceeding.\",\n  \"returns\": \"Confirmation message indicating that the patient ticket creation has been initiated\",\n  \"parameters\": {\n    \"patientName\": \"Patient's full name (first and last name)\",\n    \"appointmentNumber\": \"Patient's appointment number\",\n    \"patientAge\": \"Patient's age\",\n    \"complaint\": \"Primary complaint of the patient\",\n    \"symptomsDetails\": \"Details of the patient's symptoms\",\n    \"medicalHistory\": \"Patient's medical history\",\n    \"medicationsAndAllergies\": \"Details of medications and allergies\",\n    \"lifestyleContext\": \"Lifestyle and other contextual information\"\n  }\n}\n</code></pre> <pre><code>// Code Implementation\n[Knowledge(\"Capability - Upload pre-assessment\")]\npublic async Task&lt;string&gt; UploadPreAssessment(\n    string patientName,\n    string appointmentNumber,\n    int patientAge,\n    string complaint,\n    string symptomsDetails,\n    string medicationsAndAllergies)\n{\n    // Implementation\n}\n</code></pre>"},{"location":"3-knowledge/4-local-dev/","title":"Local Development","text":"<p>When developing agents you can work with knowledge files locally for easier manipulation and faster iteration. This is particularly useful during development and testing phases.</p>"},{"location":"3-knowledge/4-local-dev/#setting-up-local-knowledge-development","title":"Setting Up Local Knowledge Development","text":"<p>To enable local knowledge development, set the <code>LOCAL_KNOWLEDGE_FOLDER</code> environment variable to point to your local knowledge directory:</p> <pre><code>LOCAL_KNOWLEDGE_FOLDER=./knowledge-base\n</code></pre>"},{"location":"3-knowledge/4-local-dev/#environment-variable-configuration","title":"Environment Variable Configuration","text":"<p>You can set this environment variable in several ways:</p> <ol> <li> <p>In your terminal session: <pre><code>export LOCAL_KNOWLEDGE_FOLDER=./knowledge-base\n</code></pre></p> </li> <li> <p>In your agent project's launch configuration: <pre><code>LOCAL_KNOWLEDGE_FOLDER=./knowledge-base dotnet run\n</code></pre></p> </li> <li> <p>Using a .env file (if your agent supports it):    <pre><code>LOCAL_KNOWLEDGE_FOLDER=./knowledge-base\n</code></pre></p> </li> </ol>"},{"location":"3-knowledge/4-local-dev/#directory-structure","title":"Directory Structure","text":"<p>When using local knowledge development, organize your knowledge files in the specified folder:</p> <pre><code>YourAgentProject/\n\u251c\u2500\u2500 knowledge-base/\n\u2502   \u251c\u2500\u2500 documents/\n\u2502   \u2502   \u251c\u2500\u2500 procedures.md\n\u2502   \u2502   \u251c\u2500\u2500 guidelines.txt\n\u2502   \u2502   \u2514\u2500\u2500 faq.pdf\n\u2502   \u251c\u2500\u2500 templates/\n\u2502   \u2502   \u251c\u2500\u2500 response-templates.json\n\u2502   \u2502   \u2514\u2500\u2500 workflow-templates.yaml\n\u2502   \u2514\u2500\u2500 data/\n\u2502       \u251c\u2500\u2500 product-catalog.csv\n\u2502       \u2514\u2500\u2500 customer-data.json\n\u251c\u2500\u2500 Program.cs\n\u2514\u2500\u2500 YourAgent.csproj\n</code></pre>"},{"location":"3-knowledge/4-local-dev/#controlled-upload-of-knowledge-files","title":"Controlled Upload of Knowledge Files","text":"<p>Users can manage the upload of local knowledge files to the server through environment variables:</p>"},{"location":"3-knowledge/4-local-dev/#specifying-knowledge-files-location","title":"Specifying Knowledge Files Location","text":"<p>To specify the folder containing knowledge files, use the .env variable: <pre><code>LOCAL_KNOWLEDGE_FOLDER=&lt;path-to-knowledge-folder&gt;\n</code></pre></p>"},{"location":"3-knowledge/4-local-dev/#controlling-knowledge-upload","title":"Controlling Knowledge Upload","text":"<p>To control whether the knowledge files should be uploaded, set the following variable: <pre><code>UPLOAD_RESOURCES=true\n</code></pre></p>"},{"location":"3-knowledge/4-local-dev/#upload-behavior","title":"Upload Behavior","text":"<p>The upload behavior is controlled by the environment variable:</p> <ul> <li><code>UPLOAD_RESOURCES=true</code> \u2192 upload will occur.</li> <li><code>UPLOAD_RESOURCES=false</code> or missing \u2192 upload will not occur.</li> </ul>"},{"location":"3-knowledge/4-local-dev/#usage-examples","title":"Usage Examples","text":"<pre><code># Use .env setting for upload control\nUPLOAD_RESOURCES=true dotnet run\n\n# Disable upload (default behavior if not specified)\nUPLOAD_RESOURCES=false dotnet run\n</code></pre>"},{"location":"3-knowledge/4-local-dev/#controlled-upload-of-source-code","title":"Controlled Upload of Source Code","text":"<p>The agent now uses a hash-based mechanism on the client side to determine whether the current source code needs to be uploaded to the server:</p>"},{"location":"3-knowledge/4-local-dev/#hash-based-upload-optimization","title":"Hash-Based Upload Optimization","text":"<ul> <li>Hash Generation: A hash of the source code is generated locally and compared with the value stored in the database.</li> <li>No Changes Detected: If the hashes match, the source code has not changed, and upload is skipped.</li> <li>Changes Detected: If the hashes do not match, the source code has changed and will be uploaded to the server, updating the value in the database accordingly.</li> </ul> <p>This optimization reduces unnecessary uploads and improves deployment efficiency.</p>"},{"location":"3-knowledge/4-local-dev/#environment-configuration-examples","title":"Environment Configuration Examples","text":""},{"location":"3-knowledge/4-local-dev/#development-environment-envdevelopment","title":"Development Environment (.env.development)","text":"<pre><code>LOCAL_KNOWLEDGE_FOLDER=./knowledge-base\nUPLOAD_RESOURCES=false\n</code></pre>"},{"location":"3-knowledge/5-document-store/","title":"Structured Document Store","text":"<p>Agents can save structured information through the Xians server. It should not be used as a database to store transactional data, but agents can store configurations, settings, etc. that are transient. There is no guarantee of data reliability and therefore this store should not be used for critical data.</p>"},{"location":"3-knowledge/5-document-store/#overview","title":"Overview","text":"<p>The Document Store provides a simple interface for agents to save, retrieve, and manage JSON documents. Documents are typed objects with metadata and support operations like create, read, update, delete, and query.</p> <p>Important: Documents have a default Time-to-Live (TTL) of 30 days and will be automatically deleted after this period unless explicitly configured otherwise.</p>"},{"location":"3-knowledge/5-document-store/#interface","title":"Interface","text":"<p>The <code>IDocumentStore</code> interface provides the following operations:</p> <ul> <li>Save: Store new documents or update existing ones</li> <li>Get: Retrieve documents by ID or by type/key combination</li> <li>Query: Find documents using metadata filters</li> <li>Update: Modify existing documents</li> <li>Delete: Remove single or multiple documents</li> <li>Exists: Check if a document exists</li> </ul>"},{"location":"3-knowledge/5-document-store/#basic-usage","title":"Basic Usage","text":""},{"location":"3-knowledge/5-document-store/#saving-documents","title":"Saving Documents","text":"<pre><code>using XiansAi.Memory;\nusing System.Text.Json;\n\n// Object to be saved\nvar counter = new Counter {\n    Count = 1,\n    Message = \"Hello World\",\n    CreatedAt = DateTime.UtcNow\n};\n\n// Create a new document with Type and Key\nvar document = new Document {\n    Content = JsonSerializer.SerializeToElement(counter),\n    Type = \"Counter\",        // Category/namespace for the document\n    Key = \"my-counter\",      // Unique identifier within the \"Counter\" type\n    // optional\n    Metadata = new Dictionary&lt;string, object&gt; {\n        { \"Brand\", \"Xians\" },\n        { \"Version\", \"1.0\" }\n    }\n};\n\n// Save with options\nvar options = new DocumentOptions {\n    UseKeyAsIdentifier = true,  // Use Type+Key combination as identifier\n    Overwrite = true           // Allow updating existing documents\n};\n\nvar savedDoc = await MemoryHub.Documents.SaveAsync(document, options);\n</code></pre>"},{"location":"3-knowledge/5-document-store/#identification-strategies","title":"Identification Strategies","text":"<p>Option 1: Auto-generated ID (default)</p> <pre><code>var document = new Document {\n    Content = JsonSerializer.SerializeToElement(data),\n    Type = \"UserData\"  // Key is optional, ID will be auto-generated\n};\n// Results in document with auto-generated ID like \"doc-12345\"\n</code></pre> <p>Option 2: Type + Key combination</p> <pre><code>var document = new Document {\n    Content = JsonSerializer.SerializeToElement(data),\n    Type = \"UserSettings\",\n    Key = \"user-12345\"\n};\n\nvar options = new DocumentOptions {\n    UseKeyAsIdentifier = true  // Required for Type+Key identification\n};\n// Results in document identifiable by Type=\"UserSettings\" + Key=\"user-12345\"\n</code></pre>"},{"location":"3-knowledge/5-document-store/#retrieving-documents","title":"Retrieving Documents","text":"<p>There are multiple ways to retrieve documents based on how they were saved:</p>"},{"location":"3-knowledge/5-document-store/#method-1-retrieve-by-auto-generated-id","title":"Method 1: Retrieve by Auto-generated ID","text":"<pre><code>// For documents saved without UseKeyAsIdentifier=true\nvar docById = await MemoryHub.Documents.GetAsync(\"auto-generated-id\");\nif (docById != null) {\n    var counter = JsonSerializer.Deserialize&lt;Counter&gt;((JsonElement)docById.Content);\n}\n</code></pre>"},{"location":"3-knowledge/5-document-store/#method-2-retrieve-by-type-and-key","title":"Method 2: Retrieve by Type and Key","text":"<pre><code>// For documents saved with Type and Key using UseKeyAsIdentifier=true\nvar docByKey = await MemoryHub.Documents.GetByKeyAsync(\"Counter\", \"my-counter\");\nif (docByKey != null) {\n    var counter = JsonSerializer.Deserialize&lt;Counter&gt;((JsonElement)docByKey.Content);\n    Console.WriteLine($\"Counter value: {counter.Count}\");\n}\n</code></pre>"},{"location":"3-knowledge/5-document-store/#method-3-query-by-type-or-metadata","title":"Method 3: Query by Type or Metadata","text":"<pre><code>// Find all documents of a specific type\nvar query = new DocumentQuery {\n    Type = \"Counter\",\n    Limit = 50\n};\n\nvar counters = await MemoryHub.Documents.QueryAsync(query);\nforeach (var doc in counters) {\n    var counter = JsonSerializer.Deserialize&lt;Counter&gt;((JsonElement)doc.Content)!;\n    Console.WriteLine($\"Counter {doc.Key}: {counter.Count}\");\n}\n</code></pre>"},{"location":"3-knowledge/5-document-store/#existence-checks","title":"Existence Checks","text":"<pre><code>// Check if document exists by ID\nvar existsById = await MemoryHub.Documents.ExistsAsync(\"document-id\");\n\n// Check if document exists by Type+Key (query with Limit=1)\nvar existsByKey = await MemoryHub.Documents.QueryAsync(new DocumentQuery {\n    Type = \"Counter\",\n    Key = \"my-counter\",\n    Limit = 1\n});\nvar exists = existsByKey.Any();\n</code></pre>"},{"location":"3-knowledge/5-document-store/#updating-documents","title":"Updating Documents","text":"<pre><code>// Retrieve and update\nvar document = await MemoryHub.Documents.GetByKeyAsync(\"Counter\", \"my-counter\");\n\nif (document != null) {\n    var counter = JsonSerializer.Deserialize&lt;Counter&gt;((JsonElement)document.Content)!;\n    counter.Count++;\n    counter.LastUpdated = DateTime.UtcNow;\n\n    // Update the document content\n    document.Content = JsonSerializer.SerializeToElement(counter);\n    var success = await MemoryHub.Documents.UpdateAsync(document);\n}\n</code></pre>"},{"location":"3-knowledge/5-document-store/#querying-documents","title":"Querying Documents","text":"<pre><code>// Query by type\nvar query = new DocumentQuery {\n    Type = \"Counter\"\n};\n\nvar results = await MemoryHub.Documents.QueryAsync(query);\nforeach (var doc in results) {\n    var counter = JsonSerializer.Deserialize&lt;Counter&gt;((JsonElement)doc.Content)!;\n    Console.WriteLine($\"Document: {doc.Key}, Count: {counter.Count}\");\n}\n</code></pre>"},{"location":"3-knowledge/5-document-store/#deleting-documents","title":"Deleting Documents","text":"<pre><code>// Delete single document\nvar deleted = await MemoryHub.Documents.DeleteAsync(\"document-id\");\n\n// Delete multiple documents\nvar idsToDelete = new[] { \"doc1\", \"doc2\", \"doc3\" };\nvar deleteCount = await MemoryHub.Documents.DeleteManyAsync(idsToDelete);\n</code></pre>"},{"location":"3-knowledge/5-document-store/#document-structure","title":"Document Structure","text":"<p>Documents consist of:</p> <ul> <li>Content: A <code>JsonElement</code> containing your serialized object data</li> <li>Type: A string categorizing the document (e.g., \"Counter\", \"UserSettings\", \"Configuration\")</li> <li>Key: An optional custom identifier that, combined with Type, creates a unique document identifier</li> <li>Metadata: Key-value pairs for additional information and querying</li> <li>ID: Auto-generated unique identifier (used when Key is not provided)</li> <li>AgentId: The agent that created or owns this document</li> <li>WorkflowId: The workflow instance that created this document</li> <li>CreatedAt/UpdatedAt: Timestamps for creation and last update</li> <li>ExpiresAt: Optional expiration time for automatic cleanup</li> </ul>"},{"location":"3-knowledge/5-document-store/#type-and-key-structure","title":"Type and Key Structure","text":"<p>The Type and Key fields work together to provide a logical identification system:</p> <ul> <li>Type: Acts as a category or namespace for your documents (e.g., \"UserPreferences\", \"GameState\", \"Configuration\")</li> <li>Key: Acts as a unique identifier within that type (e.g., \"user-123\", \"level-5\", \"app-settings\")</li> </ul> <p>When both Type and Key are provided, they form a composite identifier that allows you to:</p> <ul> <li>Organize documents logically by category</li> <li>Use meaningful, human-readable identifiers</li> <li>Retrieve documents without needing to remember auto-generated IDs</li> <li>Enable the <code>UseKeyAsIdentifier</code> option for upsert behavior</li> </ul>"},{"location":"3-knowledge/5-document-store/#document-options","title":"Document Options","text":"<p>The <code>DocumentOptions</code> class provides control over how documents are saved and managed:</p>"},{"location":"3-knowledge/5-document-store/#available-options","title":"Available Options","text":"<pre><code>public class DocumentOptions\n{\n    /// &lt;summary&gt;\n    /// Time-to-live in minutes. Document will be automatically deleted after this time.\n    /// Default is 43,200 minutes (30 days).\n    /// &lt;/summary&gt;\n    public int? TtlMinutes { get; set; } = 43200; // 30 days default\n\n    /// &lt;summary&gt;\n    /// Whether to overwrite if a document with the same ID exists.\n    /// Default is false.\n    /// &lt;/summary&gt;\n    public bool Overwrite { get; set; } = false;\n\n    /// &lt;summary&gt;\n    /// When true, uses the combination of Type and Key as the unique identifier.\n    /// If a document with the same Type and Key exists, it will be updated.\n    /// Requires both Type and Key to be set on the document.\n    /// Default is false.\n    /// &lt;/summary&gt;\n    public bool UseKeyAsIdentifier { get; set; } = false;\n}\n</code></pre>"},{"location":"3-knowledge/5-document-store/#ttlminutes-time-to-live","title":"TtlMinutes (Time-to-Live)","text":"<p>Automatically delete documents after a specified time period. Default is 30 days (43,200 minutes) if not specified.</p> <pre><code>var options = new DocumentOptions {\n    TtlMinutes = 60  // Document expires in 1 hour\n};\n\nvar document = new Document {\n    Content = JsonSerializer.SerializeToElement(temporaryData),\n    Type = \"TempData\",\n    Key = \"session-12345\"\n};\n\nawait MemoryHub.Documents.SaveAsync(document, options);\n</code></pre> <p>Use cases for TTL:</p> <ul> <li>Session data that should expire</li> <li>Temporary caches</li> <li>Time-sensitive configurations</li> <li>Cleanup of old logs or metrics</li> </ul>"},{"location":"3-knowledge/5-document-store/#overwrite","title":"Overwrite","text":"<p>Control whether to overwrite existing documents with the same ID:</p> <pre><code>// Default behavior (Overwrite = false) - will fail if document exists\nvar options1 = new DocumentOptions {\n    Overwrite = false  // Default\n};\n\n// Allow overwriting existing documents\nvar options2 = new DocumentOptions {\n    Overwrite = true\n};\n\nvar document = new Document {\n    Id = \"specific-id\",  // Explicit ID\n    Content = JsonSerializer.SerializeToElement(data),\n    Type = \"Configuration\"\n};\n\nawait MemoryHub.Documents.SaveAsync(document, options2);\n</code></pre>"},{"location":"3-knowledge/5-document-store/#usekeyasidentifier","title":"UseKeyAsIdentifier","text":"<p>Enable upsert behavior using Type + Key combination:</p> <pre><code>var options = new DocumentOptions {\n    UseKeyAsIdentifier = true,  // Required for Type+Key identification\n    Overwrite = true           // Allow updates to existing documents\n};\n\nvar document = new Document {\n    Content = JsonSerializer.SerializeToElement(userSettings),\n    Type = \"UserSettings\",\n    Key = \"user-12345\"  // Both Type and Key must be provided\n};\n\n// First call: Creates new document\nvar result1 = await MemoryHub.Documents.SaveAsync(document, options);\n\n// Second call: Updates existing document (same Type+Key)\ndocument.Content = JsonSerializer.SerializeToElement(updatedSettings);\nvar result2 = await MemoryHub.Documents.SaveAsync(document, options);\n</code></pre> <p>Important Notes:</p> <ul> <li>When <code>UseKeyAsIdentifier = true</code>, both <code>Type</code> and <code>Key</code> must be set on the document</li> <li>The system will look for existing documents with the same Type+Key combination</li> <li>If found, the existing document will be updated; if not found, a new document is created</li> <li>This provides upsert (insert or update) behavior</li> </ul>"},{"location":"3-knowledge/5-document-store/#common-option-combinations","title":"Common Option Combinations","text":"<p>Temporary session data:</p> <pre><code>var options = new DocumentOptions {\n    UseKeyAsIdentifier = true,\n    Overwrite = true,\n    TtlMinutes = 30  // Auto-delete after 30 minutes\n};\n</code></pre> <p>Permanent configuration with upsert:</p> <pre><code>var options = new DocumentOptions {\n    UseKeyAsIdentifier = true,\n    Overwrite = true\n    // No TTL - permanent storage\n};\n</code></pre> <p>One-time data (no overwrites):</p> <pre><code>var options = new DocumentOptions {\n    Overwrite = false,\n    TtlMinutes = 1440  // Keep for 24 hours\n};\n</code></pre>"},{"location":"3-knowledge/5-document-store/#document-query","title":"Document Query","text":"<p>The <code>DocumentQuery</code> class provides powerful filtering and pagination capabilities for searching documents:</p>"},{"location":"3-knowledge/5-document-store/#available-query-options","title":"Available Query Options","text":"<pre><code>public class DocumentQuery\n{\n    /// &lt;summary&gt;\n    /// Filter by document type.\n    /// &lt;/summary&gt;\n    public string? Type { get; set; }\n\n    /// &lt;summary&gt;\n    /// Filter by document key.\n    /// &lt;/summary&gt;\n    public string? Key { get; set; }\n\n    /// &lt;summary&gt;\n    /// Filter by metadata key-value pairs.\n    /// &lt;/summary&gt;\n    public Dictionary&lt;string, object&gt;? MetadataFilters { get; set; }\n\n    /// &lt;summary&gt;\n    /// Maximum number of results to return.\n    /// &lt;/summary&gt;\n    public int? Limit { get; set; } = 100;\n\n    /// &lt;summary&gt;\n    /// Number of results to skip for pagination.\n    /// &lt;/summary&gt;\n    public int? Skip { get; set; } = 0;\n\n    /// &lt;summary&gt;\n    /// Sort field (e.g., \"CreatedAt\", \"UpdatedAt\").\n    /// &lt;/summary&gt;\n    public string? SortBy { get; set; }\n\n    /// &lt;summary&gt;\n    /// Sort direction.\n    /// &lt;/summary&gt;\n    public bool SortDescending { get; set; } = true;\n\n    /// &lt;summary&gt;\n    /// Include only documents created after this date.\n    /// &lt;/summary&gt;\n    public DateTime? CreatedAfter { get; set; }\n\n    /// &lt;summary&gt;\n    /// Include only documents created before this date.\n    /// &lt;/summary&gt;\n    public DateTime? CreatedBefore { get; set; }\n}\n</code></pre>"},{"location":"3-knowledge/5-document-store/#basic-queries","title":"Basic Queries","text":""},{"location":"3-knowledge/5-document-store/#query-by-type","title":"Query by Type","text":"<pre><code>// Find all user settings documents\nvar query = new DocumentQuery {\n    Type = \"UserSettings\"\n};\n\nvar userSettings = await MemoryHub.Documents.QueryAsync(query);\nforeach (var doc in userSettings) {\n    Console.WriteLine($\"User settings for: {doc.Key}\");\n}\n</code></pre>"},{"location":"3-knowledge/5-document-store/#query-by-type-and-key","title":"Query by Type and Key","text":"<pre><code>// Find a specific document by type and key\nvar query = new DocumentQuery {\n    Type = \"GameState\",\n    Key = \"level-5\"\n};\n\nvar results = await MemoryHub.Documents.QueryAsync(query);\nvar gameState = results.FirstOrDefault();\n</code></pre>"},{"location":"3-knowledge/5-document-store/#query-with-limit-and-pagination","title":"Query with Limit and Pagination","text":"<pre><code>// Get first 10 documents\nvar query = new DocumentQuery {\n    Type = \"ChatHistory\",\n    Limit = 10,\n    Skip = 0\n};\n\nvar firstPage = await MemoryHub.Documents.QueryAsync(query);\n\n// Get next 10 documents\nquery.Skip = 10;\nvar secondPage = await MemoryHub.Documents.QueryAsync(query);\n</code></pre>"},{"location":"3-knowledge/5-document-store/#advanced-filtering","title":"Advanced Filtering","text":""},{"location":"3-knowledge/5-document-store/#metadata-filtering","title":"Metadata Filtering","text":"<pre><code>// Query by metadata values\nvar query = new DocumentQuery {\n    Type = \"UserData\",\n    MetadataFilters = new Dictionary&lt;string, object&gt; {\n        { \"Status\", \"Active\" },\n        { \"Version\", \"2.0\" },\n        { \"Region\", \"US\" }\n    }\n};\n\nvar activeUsers = await MemoryHub.Documents.QueryAsync(query);\n</code></pre>"},{"location":"3-knowledge/5-document-store/#date-range-filtering","title":"Date Range Filtering","text":"<pre><code>// Find documents created in the last 24 hours\nvar query = new DocumentQuery {\n    Type = \"ActivityLog\",\n    CreatedAfter = DateTime.UtcNow.AddDays(-1),\n    Limit = 50\n};\n\nvar recentActivity = await MemoryHub.Documents.QueryAsync(query);\n\n// Find documents from a specific time period\nvar weeklyReport = new DocumentQuery {\n    Type = \"Report\",\n    CreatedAfter = DateTime.UtcNow.AddDays(-7),\n    CreatedBefore = DateTime.UtcNow.AddDays(-1)\n};\n\nvar weeklyReports = await MemoryHub.Documents.QueryAsync(weeklyReport);\n</code></pre>"},{"location":"3-knowledge/5-document-store/#sorting-results","title":"Sorting Results","text":"<pre><code>// Sort by creation date (newest first)\nvar query = new DocumentQuery {\n    Type = \"Message\",\n    SortBy = \"CreatedAt\",\n    SortDescending = true,\n    Limit = 20\n};\n\nvar recentMessages = await MemoryHub.Documents.QueryAsync(query);\n\n// Sort by update date (oldest first)\nvar oldestFirst = new DocumentQuery {\n    Type = \"Task\",\n    SortBy = \"UpdatedAt\",\n    SortDescending = false\n};\n\nvar oldestTasks = await MemoryHub.Documents.QueryAsync(oldestFirst);\n</code></pre>"},{"location":"3-knowledge/5-document-store/#complex-query-examples","title":"Complex Query Examples","text":""},{"location":"3-knowledge/5-document-store/#multi-criteria-search","title":"Multi-criteria Search","text":"<pre><code>// Complex search combining multiple filters\nvar query = new DocumentQuery {\n    Type = \"Order\",\n    MetadataFilters = new Dictionary&lt;string, object&gt; {\n        { \"Status\", \"Pending\" },\n        { \"Priority\", \"High\" }\n    },\n    CreatedAfter = DateTime.UtcNow.AddHours(-6),\n    SortBy = \"CreatedAt\",\n    SortDescending = true,\n    Limit = 25\n};\n\nvar urgentOrders = await MemoryHub.Documents.QueryAsync(query);\n</code></pre>"},{"location":"3-knowledge/5-document-store/#paginated-results-with-processing","title":"Paginated Results with Processing","text":"<pre><code>// Process all documents in batches\nvar pageSize = 50;\nvar skip = 0;\nvar hasMore = true;\n\nwhile (hasMore) {\n    var query = new DocumentQuery {\n        Type = \"LogEntry\",\n        Limit = pageSize,\n        Skip = skip,\n        SortBy = \"CreatedAt\",\n        SortDescending = false\n    };\n\n    var batch = await MemoryHub.Documents.QueryAsync(query);\n\n    // Process this batch\n    foreach (var doc in batch) {\n        var logEntry = JsonSerializer.Deserialize&lt;LogEntry&gt;((JsonElement)doc.Content)!;\n        ProcessLogEntry(logEntry);\n    }\n\n    hasMore = batch.Count == pageSize;\n    skip += pageSize;\n}\n</code></pre>"},{"location":"3-knowledge/5-document-store/#search-by-multiple-types","title":"Search by Multiple Types","text":"<pre><code>// Note: DocumentQuery filters by single type, so for multiple types, use separate queries\nvar userQueries = new[] { \"UserSettings\", \"UserProfile\", \"UserPreferences\" }\n    .Select(type =&gt; new DocumentQuery { Type = type, Limit = 100 });\n\nvar allUserDocs = new List&lt;Document&gt;();\nforeach (var query in userQueries) {\n    var docs = await MemoryHub.Documents.QueryAsync(query);\n    allUserDocs.AddRange(docs);\n}\n</code></pre>"},{"location":"3-knowledge/5-document-store/#query-performance-tips","title":"Query Performance Tips","text":"<ol> <li>Use Type filtering - Always specify Type when possible for better performance</li> <li>Limit results - Set appropriate Limit values to avoid large result sets</li> <li>Use pagination - For large datasets, process results in batches using Skip/Limit</li> <li>Index metadata - Commonly queried metadata fields perform better</li> <li>Date range queries - Use CreatedAfter/CreatedBefore for time-based filtering</li> <li>Sort efficiently - Sorting by CreatedAt or UpdatedAt is typically faster</li> </ol>"},{"location":"3-knowledge/6-types-of-memory/","title":"Types of Agent Memory","text":"<p>Just like humans, agents need to remember things to be effective. Below is a concise list of the key memory types involved in building reliable AI agents, without grouping into primary/secondary.</p>"},{"location":"3-knowledge/6-types-of-memory/#system-and-policy-prompt","title":"System and policy prompt","text":"<p>Persistent instructions and policies that steer behavior (role, capabilities, safety and business rules). This is not Cache Augmented Generation (CAG).</p>"},{"location":"3-knowledge/6-types-of-memory/#conversation-history-episodic","title":"Conversation history (episodic)","text":"<p>Message transcript (often summarized) that preserves context and coherence across turns.</p>"},{"location":"3-knowledge/6-types-of-memory/#working-memory-scratchpad","title":"Working memory / scratchpad","text":"<p>Internal reasoning artifacts (plans, intermediate computations). Sometimes persisted for traceability.</p>"},{"location":"3-knowledge/6-types-of-memory/#tool-and-capability-memory","title":"Tool and capability memory","text":"<ul> <li>Tool request/response transcript included in context for grounding.</li> <li>Short-lived tool state (pagination cursors, partial results).</li> <li>Capability schemas/affordances; see <code>3-capabilities.md</code>.</li> </ul>"},{"location":"3-knowledge/6-types-of-memory/#goal-and-plan-state","title":"Goal and plan state","text":"<p>Current objectives, subgoals, and plan-of-action, whether explicit (state machine/flow engine) or implicit (prompted plan).</p>"},{"location":"3-knowledge/6-types-of-memory/#knowledge-memory-rag","title":"Knowledge memory (RAG)","text":"<p>External knowledge indexed for retrieval (documents, code, KBs).</p> <ul> <li>Index types: vector, keyword/lexical, and graph (often combined).</li> <li>Consider freshness, provenance, and retrieval accuracy.</li> <li>See <code>2-accessing-knowledge.md</code> and <code>5-document-store.md</code>.</li> </ul>"},{"location":"3-knowledge/6-types-of-memory/#user-profile-and-preferences","title":"User profile and preferences","text":"<p>Identity, roles, preferences, and constraints for personalization. Requires consent, retention controls, and audit.</p>"},{"location":"3-knowledge/6-types-of-memory/#self-improving-profile-memory","title":"Self-improving profile memory","text":"<p>A governed mechanism to learn and update user traits over time.</p> <ul> <li>Signals: explicit inputs, in-chat confirmations, choice history, engagement signals, and tool outcomes.</li> <li>Representation: typed key\u2013value traits with confidence (0\u20131), evidence pointers, and last_seen_at timestamps.</li> <li>Updating: online updates with decay; add traits only after a confidence threshold; resolve conflicts by lowering confidence and requesting confirmation when needed.</li> <li>Personalization: include only high-confidence traits in prompts or retrieval filters; prefer structured context over free text.</li> <li>Controls: user consent, view/edit/reset UI, per-field TTL/retention, scope (per-user, per-agent, or org), and full audit trail.</li> <li>Safety: avoid sensitive/protected attributes unless strictly necessary; minimize PII; encrypt at rest and in transit; consider differential privacy for aggregated learning.</li> </ul>"},{"location":"3-knowledge/6-types-of-memory/#episodic-summaries-past-sessions","title":"Episodic summaries (past sessions)","text":"<p>Summaries of prior interactions and outcomes to maintain continuity without storing full transcripts.</p>"},{"location":"3-knowledge/6-types-of-memory/#organizationalshared-memory","title":"Organizational/shared memory","text":"<p>Team- or org-level facts, standards, and decisions accessible to multiple agents.</p>"},{"location":"3-knowledge/6-types-of-memory/#safety-and-policy-memory","title":"Safety and policy memory","text":"<p>Compliance constraints and allow/deny lists, maintained separately from prompts for auditable updates.</p>"},{"location":"3-knowledge/6-types-of-memory/#model-embedded-parametric-memory","title":"Model-embedded (parametric) memory","text":"<p>What the model \u201cknows\u201d from pretraining or fine-tuning (including adapters/LoRA).</p> <ul> <li>Pros: fast and compact at inference.</li> <li>Cons: hard to update; may hallucinate without external grounding.</li> </ul>"},{"location":"3-knowledge/6-types-of-memory/#operational-memory-and-caches","title":"Operational memory and caches","text":"<p>Mechanisms that accelerate or stabilize behavior.</p> <ul> <li>Caches (Cache Augmented Generation, CAG): prompt/output and embedding caches with invalidation to avoid staleness.</li> <li>Transformer KV cache: ephemeral per generation to speed decoding.</li> <li>Checkpoints and flow state: persisted progress for long-running or resumable processes.</li> </ul>"},{"location":"3-knowledge/6-types-of-memory/#governance-privacy-and-security","title":"Governance, privacy, and security","text":"<p>Cross-cutting concerns for any memory that contains user or sensitive data.</p> <ul> <li>Retention/TTL and redaction; per-field sensitivity classes.</li> <li>Encryption in transit and at rest; see <code>../n-encyclopedia/chat-message-encryption.md</code>.</li> <li>Access control, consent, and purpose limitation.</li> <li>Auditing and observability; see <code>../n-encyclopedia/logging.md</code>.</li> </ul>"},{"location":"3-knowledge/6-types-of-memory/#quick-reference-dimensions","title":"Quick reference: dimensions","text":"<ul> <li>Parametric vs external: in-model vs in a store (RAG, profiles, summaries).</li> <li>Ephemeral vs persistent: within one run/session vs across sessions.</li> <li>Private vs shared: per-user/agent vs organizational/multi-agent.</li> <li>Grounded vs generative: retrieved facts vs model\u2019s internal knowledge/synthesis.</li> </ul>"},{"location":"4-automation/0-introduction/","title":"Process Automation","text":""},{"location":"4-automation/0-introduction/#introduction","title":"Introduction","text":"<p>Unlike conventional automation tools that follow rigid, pre-programmed rules, AI agents possess the intelligence to understand context, make informed decisions, adapt to changing conditions, and learn from experience.</p>"},{"location":"4-automation/0-introduction/#core-requirements-for-ai-agent-automation","title":"Core Requirements for AI Agent Automation","text":"<p>To effectively automate business processes, AI agents must possess several critical capabilities that enable them to operate reliably in enterprise environments:</p>"},{"location":"4-automation/0-introduction/#1-external-trigger-responsiveness","title":"1. External Trigger Responsiveness","text":"<p>AI agents must be able to respond to various external stimuli that initiate business processes. This includes real-time event processing, webhook handling, and integration with external systems and APIs.</p> <p>External Triggers: Learn how to configure AI agents to respond to external events and triggers</p>"},{"location":"4-automation/0-introduction/#2-scheduled-and-periodic-execution","title":"2. Scheduled and Periodic Execution","text":"<p>Many business processes require execution at specific times or intervals. AI agents need robust scheduling capabilities to handle recurring tasks, time-based triggers, and complex scheduling patterns.</p> <p>Scheduled Execution: Implement time-based and periodic process automation</p>"},{"location":"4-automation/0-introduction/#3-fault-tolerance-and-resilience","title":"3. Fault Tolerance and Resilience","text":"<p>Enterprise environments demand high reliability. AI agents must gracefully handle failures, implement retry mechanisms, maintain process state during interruptions, and provide comprehensive error handling.</p> <p>Fault Tolerance: Build resilient AI agents that handle failures gracefully</p>"},{"location":"4-automation/0-introduction/#4-long-running-process-support","title":"4. Long-Running Process Support","text":"<p>Complex business processes often span extended periods, requiring agents to maintain context, manage state persistence, handle checkpoints, and coordinate across multiple phases of execution.</p> <p>Long-Running Processes: Design and implement processes that span extended time periods</p>"},{"location":"4-automation/1-external-triggers/","title":"External Communication with Agent Workflows","text":"<p>External parties can communicate with Agent workflows by sending Data messages to trigger specific operations. This enables integration with external systems, APIs, and applications.</p>"},{"location":"4-automation/1-external-triggers/#message-communication","title":"Message Communication","text":""},{"location":"4-automation/1-external-triggers/#message-types-and-threads","title":"Message Types and Threads","text":"<p>External systems send Data messages to Agent workflows. These messages are part of message threads that organize conversations and context.</p>"},{"location":"4-automation/1-external-triggers/#communication-protocols","title":"Communication Protocols","text":"<p>External parties can send messages through:</p> <ul> <li>REST API: HTTP requests for synchronous communication</li> <li>WebSocket: Real-time bidirectional communication</li> <li>Server-Sent Events (SSE): Server-to-client streaming</li> </ul> <p>Detailed API documentation: User API Reference</p>"},{"location":"4-automation/1-external-triggers/#calling-the-agent-http","title":"Calling the Agent - HTTP","text":"<p>Both REST and WebSocket clients can send Data messages:</p>"},{"location":"4-automation/1-external-triggers/#rest-api-synchronous","title":"REST API - Synchronous","text":"<pre><code>// REST API call\nconst response = await fetch('/api/user/rest/converse', {\n  method: 'POST',\n  params: {\n    workflow: 'MyAgent:MyFlow',\n    type: 'Data',\n    text: 'ProcessDocument',  // Method name\n    participantId: 'user@example.com'\n  },\n  body: JSON.stringify({     // Method arguments\n    documentId: 'doc-123',\n    options: { validate: true }\n  })\n});\n</code></pre> <p>See REST API for more details. There are Synchronous and Asynchronous methods available.</p>"},{"location":"4-automation/1-external-triggers/#websocket","title":"WebSocket","text":"<pre><code>// WebSocket using TypeScript SDK\nawait connection.invoke(\"SendInboundMessage\", {\n  participantId: \"user-123\", \n  workflow: \"customer-support\",\n  type: \"Data\",\n  text: \"ProcessDocument\",\n  data: {\n    documentId: 'doc-123',\n    options: { validate: true }\n  }\n}, \"Data\");\n</code></pre> <p>See WebSocket Client for more details.</p>"},{"location":"4-automation/1-external-triggers/#on-agent-rpc-invocation","title":"On Agent - RPC Invocation","text":""},{"location":"4-automation/1-external-triggers/#data-message-structure","title":"Data Message Structure","text":"<p>Workflows receive Data messages using RPC-style method invocation:</p> <ul> <li><code>text</code>: Method name to invoke</li> <li><code>data</code>: Method arguments (JSON)</li> </ul>"},{"location":"4-automation/1-external-triggers/#setup-data-processor","title":"Setup Data Processor","text":"<p>Configure data processing in your workflow:</p> <pre><code>var agent = new AgentTeam(\"Document Agent\");\nvar flow = agent.AddAgent&lt;DocumentFlow&gt;();\n\n// Option 1: Process in Temporal Activity (default)\nflow.SetDataProcessor&lt;DocumentProcessor&gt;();\n\n// Option 2: Process in Temporal Workflow\nflow.SetDataProcessor&lt;DocumentProcessor&gt;(processInWorkflow: true);\n</code></pre>"},{"location":"4-automation/1-external-triggers/#processing-location","title":"Processing Location","text":"<p>Use the <code>processInWorkflow</code> parameter to control execution:</p> Parameter Value Execution Location Use Cases Benefits <code>false</code> (default) Temporal Activity \u2022 Stateless, one-off operations\u2022 Simple data processing \u2022 Direct IO operations <code>true</code> Temporal Workflow \u2022 Complex orchestration scenarios\u2022 When you need Temporal business process capabilities \u2022 Access to workflow features (timers, signals, queries)"},{"location":"4-automation/1-external-triggers/#data-processor-implementation","title":"Data Processor Implementation","text":"<pre><code>public class DocumentProcessor\n{\n    public DocumentProcessor(MessageThread messageThread) { }\n\n    // Method invoked by external 'ProcessDocument' calls\n    public async Task&lt;DocumentResult&gt; ProcessDocument(DocumentRequest request)\n    {\n        // Process the document\n        return new DocumentResult\n        {\n            Id = request.DocumentId,\n            Status = \"processed\",\n            ValidationResults = await ValidateDocument(request)\n        };\n    }\n\n    // Method invoked by external 'GetStatus' calls\n    public DocumentStatus GetStatus(string documentId)\n    {\n        return _documentService.GetStatus(documentId);\n    }\n}\n</code></pre>"},{"location":"4-automation/1-external-triggers/#accessing-the-flow-instance","title":"Accessing the Flow Instance","text":"<p>When <code>processInWorkflow: true</code>, you can receive the active Flow instance via the processor's constructor for workflow state management:</p> <pre><code>public class DocumentProcessor\n{\n    private readonly MessageThread _messageThread;\n    private readonly DocumentFlow _flow;\n\n    // In workflow mode: Both MessageThread and Flow instance available\n    public DocumentProcessor(MessageThread messageThread, DocumentFlow flow)\n    {\n        _messageThread = messageThread;\n        _flow = flow;\n    }\n\n    public async Task&lt;DocumentResult&gt; ProcessDocument(DocumentRequest request)\n    {\n        // Access workflow state through _flow instance\n        _flow.DocumentsProcessed++;\n\n        return new DocumentResult { /* ... */ };\n    }\n}\n</code></pre> <p>Constructor Parameters by Mode:</p> <ul> <li>Activity mode (<code>processInWorkflow: false</code>): Only <code>MessageThread</code> parameter allowed</li> <li>Workflow mode (<code>processInWorkflow: true</code>): Both <code>MessageThread</code> and Flow instance parameters available</li> </ul> <p>Lifecycle and State:</p> <ul> <li>Data processor instances are created per invocation</li> <li>For state management across invocations, use the passed Flow instance when in workflow mode</li> <li>In activity mode, use external storage or the MessageThread for state coordination</li> </ul> <p>For detailed implementation guidance, see Handling Data as RPC.</p>"},{"location":"4-automation/1-external-triggers/#example","title":"Example","text":""},{"location":"4-automation/1-external-triggers/#document-processing-service","title":"Document Processing Service","text":"<pre><code>public class DocumentProcessor\n{\n    public async Task&lt;ProcessingResult&gt; ProcessDocument(DocumentRequest request)\n    {\n        var result = await _processor.ProcessAsync(request.Content);\n\n        return new ProcessingResult\n        {\n            DocumentId = request.DocumentId,\n            ProcessedAt = DateTime.UtcNow,\n            Status = \"completed\",\n            ExtractedData = result.Data\n        };\n    }\n}\n</code></pre>"},{"location":"4-automation/1-external-triggers/#external-api-call","title":"External API Call","text":"<pre><code>POST /api/user/rest/converse?workflow=DocumentAgent:DocumentFlow&amp;type=Data&amp;text=ProcessDocument\n\n{\n  \"DocumentId\": \"doc-123\",\n  \"Content\": \"base64-encoded-content\",\n  \"Options\": {\n    \"extractMetadata\": true,\n    \"validateFormat\": true\n  }\n}\n</code></pre>"},{"location":"4-automation/1-external-triggers/#response","title":"Response","text":"<pre><code>{\n  \"requestId\": \"req-456\",\n  \"threadId\": \"thread-789\",\n  \"response\": {\n    \"text\": null,\n    \"data\": {\n      \"DocumentId\": \"doc-123\",\n      \"ProcessedAt\": \"2024-01-15T10:30:00Z\",\n      \"Status\": \"completed\",\n      \"ExtractedData\": { /* processed data */ }\n    },\n    \"direction\": 1,\n    \"messageType\": 1,\n    \"scope\": null,\n    \"hint\": null\n  }\n}\n</code></pre> <p>This approach enables seamless integration between external systems and Agent workflows through standardized Data message communication.</p>"},{"location":"4-automation/2-flow-scheduling/","title":"Flow Scheduling","text":"<p>Flow scheduling allows agents to execute repetitively on a defined schedule. This mechanism uses Temporal's native scheduling features and is recommended for most scheduled execution use cases.</p>"},{"location":"4-automation/2-flow-scheduling/#setting-up-a-schedule","title":"Setting Up a Schedule","text":"<p>To schedule an agent workflow, use the <code>SetScheduleAsync</code> method when configuring your agent:</p> <pre><code>// Create the agent team\nvar agentTeam = new AgentTeam(\"Percy v4\", options);\n\n// Add the agent\nvar schedulerBot = agentTeam.AddAgent&lt;DiscoveryBot&gt;();\nschedulerBot.AddActivities&lt;ArticleActivities&gt;(new ArticleActivities());\n\n// Set up the schedule\nawait schedulerBot.SetScheduleAsync(new ScheduleSpec {\n    Intervals = new List&lt;ScheduleIntervalSpec&gt; {\n        new ScheduleIntervalSpec(TimeSpan.FromHours(4))\n    }\n});\n</code></pre> <p>This example configures the <code>DiscoveryBot</code> to run every 4 hours.</p>"},{"location":"4-automation/2-flow-scheduling/#schedule-specification-options","title":"Schedule Specification Options","text":"<p>The <code>ScheduleSpec</code> class provides three ways to define when your workflow should execute:</p>"},{"location":"4-automation/2-flow-scheduling/#interval-based-scheduling","title":"Interval-Based Scheduling","text":"<p>Use <code>Intervals</code> for simple, repeating time-based schedules:</p> <pre><code>await agent.SetScheduleAsync(new ScheduleSpec {\n    Intervals = new List&lt;ScheduleIntervalSpec&gt; {\n        new ScheduleIntervalSpec(TimeSpan.FromMinutes(30))\n    }\n});\n</code></pre>"},{"location":"4-automation/2-flow-scheduling/#calendar-based-scheduling","title":"Calendar-Based Scheduling","text":"<p>Use <code>Calendars</code> for more complex scheduling based on calendar dates and times:</p> <pre><code>await agent.SetScheduleAsync(new ScheduleSpec {\n    Calendars = new List&lt;ScheduleCalendarSpec&gt; {\n        new ScheduleCalendarSpec {\n            Hour = new List&lt;Range&gt; { new Range(9, 17) }, // 9 AM to 5 PM\n            DayOfWeek = new List&lt;Range&gt; { new Range(1, 5) } // Monday to Friday\n        }\n    }\n});\n</code></pre>"},{"location":"4-automation/2-flow-scheduling/#cron-based-scheduling","title":"Cron-Based Scheduling","text":"<p>Use <code>CronExpressions</code> for cron-style scheduling (primarily for migration from legacy systems):</p> <pre><code>await agent.SetScheduleAsync(new ScheduleSpec {\n    CronExpressions = new List&lt;string&gt; {\n        \"0 */2 * * *\" // Every 2 hours\n    }\n});\n</code></pre> <p>Note</p> <p>Cron expressions are provided for easy migration from legacy systems. New implementations should prefer <code>Calendars</code> for better clarity and functionality.</p>"},{"location":"4-automation/2-flow-scheduling/#receiving-the-schedule-id","title":"Receiving the Schedule ID","text":"<p>When your workflow is triggered by a schedule, it receives the Temporal schedule ID as a parameter:</p> <pre><code>[Workflow(\"Percy v4: Prospector Agent\")]\npublic class ProspectorAgent : FlowBase\n{\n    [WorkflowRun]\n    public async Task&lt;string?&gt; Run(string scheduleId)\n    {\n        // Use the scheduleId to retrieve configuration or context\n        var subAgentDefinition = await MemoryHub.Documents.QueryAsync(new DocumentQuery\n        {\n            Type = \"SubAgentDefinition\",\n            Key = scheduleId\n        });\n\n        // Your scheduled workflow logic here\n        // ...\n\n        return result;\n    }\n}\n</code></pre> <p>The <code>scheduleId</code> parameter can be used to:</p> <ul> <li>Retrieve schedule-specific configuration from the document store</li> <li>Track which schedule instance triggered the workflow</li> <li>Access user context or instructions associated with the schedule</li> </ul>"},{"location":"4-automation/2-flow-scheduling/#use-cases","title":"Use Cases","text":"<p>Flow scheduling is ideal for:</p> <ul> <li>Periodic data collection: Fetching data from external sources at regular intervals</li> <li>Report generation: Creating and distributing reports on a schedule</li> <li>Health checks: Running system monitoring tasks</li> <li>Data synchronization: Keeping external systems in sync with your platform</li> <li>Proactive notifications: Sending reminders or updates to users</li> </ul>"},{"location":"4-automation/2-flow-scheduling/#additional-resources","title":"Additional Resources","text":"<p>For more detailed information on Temporal scheduling features and advanced configuration options, refer to the Temporal Schedules documentation.</p>"},{"location":"4-automation/2-scheduled-execution/","title":"Scheduled Execution (Alternative Method)","text":""},{"location":"4-automation/2-scheduled-execution/#overview","title":"Overview","text":"<p>This document describes an alternative method for scheduling agent workflows using schedule attributes and processors. This approach is less recommended due to stability concerns and should only be used for specific use cases where the standard Temporal scheduling features are not suitable.</p> <p>Recommended Approach</p> <p>For most scheduling use cases, use Flow Scheduling instead, which leverages Temporal's native scheduling features and provides better stability and reliability.</p> <p>This alternative method enables AI agents to execute workflows automatically at predetermined times or intervals using schedule attributes within the workflow itself. While functional, it does not utilize Temporal's native scheduling infrastructure and may have limitations in terms of robustness and fault tolerance.</p>"},{"location":"4-automation/2-scheduled-execution/#how-scheduled-execution-works","title":"How Scheduled Execution Works","text":""},{"location":"4-automation/2-scheduled-execution/#workflow-structure","title":"Workflow Structure","text":"<p>To create a scheduled agent workflow, you need two main components:</p> <ol> <li>A Workflow Class: Inherits from <code>FlowBase</code> and defines the main process</li> <li>A Processor Class: Contains methods decorated with schedule attributes</li> </ol>"},{"location":"4-automation/2-scheduled-execution/#configuring-schedule-processor","title":"Configuring Schedule Processor","text":"<p>The schedule processor is configured using the <code>SetScheduleProcessor</code> method on your flow. This method controls how and where your scheduled tasks execute.</p>"},{"location":"4-automation/2-scheduled-execution/#example-workflow","title":"Example Workflow","text":"<pre><code>using Temporalio.Workflows;\nusing XiansAi.Flow;\n\n[Workflow(\"Invoice Agent:User Request Flow\")]\npublic class UserRequestFlow : FlowBase\n{\n    [WorkflowRun]\n    public async Task Run()\n    {\n        await InitSchedule();\n    }\n}\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#example-processor","title":"Example Processor","text":"<pre><code>using Temporalio.Workflows;\n\npublic class ScheduledProcessor\n{\n    [CronSchedule(\"*/1 * * * *\")]  // Every 1 minute\n    public void FrequentTask() \n    {\n        Console.WriteLine($\"Processing frequent task\");\n        Console.WriteLine($\"Is In Workflow: {Workflow.InWorkflow}\");\n        Console.WriteLine($\"Processed at: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\");\n    }\n\n    [IntervalSchedule(seconds: 10)]\n    public void RunEvery10Seconds()\n    {\n        Console.WriteLine($\"Processing 10-second interval data\");\n        Console.WriteLine($\"Processed at: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\");\n    }\n}\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#connecting-workflow-and-processor","title":"Connecting Workflow and Processor","text":"<p>To connect your workflow with a schedule processor, configure it in your <code>Program.cs</code>:</p> <pre><code>using XiansAi.Flow;\nusing DotNetEnv;\n\n// Load environment configuration\nEnv.Load();\n\n// Create agent\nvar agent = new AgentTeam(\"Scheduled Processing Agent\");\n\n// Add flow and configure schedule processor\nvar flow = agent.AddAgent&lt;UserRequestFlow&gt;();\nflow.SetScheduleProcessor&lt;ScheduledProcessor&gt;();\n\n// Run the agent\nawait agent.RunAsync();\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#setscheduleprocessor-method-parameters","title":"SetScheduleProcessor Method Parameters","text":"<p>The <code>SetScheduleProcessor</code> method provides fine-grained control over schedule execution behavior:</p> <pre><code>public Flow&lt;TWorkflow&gt; SetScheduleProcessor&lt;TProcessor&gt;(\n    bool processInWorkflow = false, \n    bool startAutomatically = true)\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#parameters-explained","title":"Parameters Explained","text":""},{"location":"4-automation/2-scheduled-execution/#processinworkflow-parameter","title":"<code>processInWorkflow</code> Parameter","text":"<p>Controls where scheduled methods execute within Temporal's architecture:</p> Parameter Value Execution Location Use Cases Benefits Limitations <code>false</code> (default) Temporal Activity \u2022 Simple, stateless operations \u2022 Direct I/O operations \u2022 Independent tasks \u2022 Direct access to external resources \u2022 Simple error handling \u2022 Better performance for simple tasks \u2022 No access to workflow features \u2022 Limited orchestration capabilities <code>true</code> Temporal Workflow \u2022 Complex orchestration \u2022 Tasks requiring workflow features \u2022 Multi-step processes \u2022 Access to timers, signals, queries \u2022 Workflow persistence \u2022 Advanced error handling \u2022 Cannot perform direct I/O \u2022 Must use activities for external calls"},{"location":"4-automation/2-scheduled-execution/#example-process-in-activity-default","title":"Example: Process in Activity (Default)","text":"<pre><code>// Configure for simple, stateless operations\nflow.SetScheduleProcessor&lt;ScheduledProcessor&gt;(processInWorkflow: false);\n\npublic class ScheduledProcessor\n{\n    [DailySchedule(\"09:00\")]\n    public async Task ProcessDailyReports()\n    {\n        // Direct database access is allowed\n        var data = await _database.GetDailyData();\n\n        // Direct file operations are allowed\n        await File.WriteAllTextAsync(\"report.txt\", data);\n\n        // Direct HTTP calls are allowed\n        await _httpClient.PostAsync(\"https://api.example.com\", content);\n    }\n}\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#example-process-in-workflow","title":"Example: Process in Workflow","text":"<pre><code>// Configure for complex orchestration scenarios\nflow.SetScheduleProcessor&lt;ScheduledProcessor&gt;(processInWorkflow: true);\n\npublic class ScheduledProcessor\n{\n    [DailySchedule(\"09:00\")]\n    public async Task ProcessComplexWorkflow()\n    {\n        // Access to workflow features\n        await Workflow.DelayAsync(TimeSpan.FromMinutes(5));\n\n        // Can wait for external signals\n        await Workflow.WaitConditionAsync(() =&gt; someCondition);\n\n        // Use activities for external operations\n        var data = await Workflow.ExecuteActivityAsync(\n            () =&gt; _activities.GetDailyData(),\n            ActivityOptions.Default\n        );\n\n        // Complex orchestration logic\n        if (data.RequiresApproval)\n        {\n            await Workflow.WaitConditionAsync(() =&gt; approvalReceived, TimeSpan.FromHours(24));\n        }\n    }\n}\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#accessing-the-flow-instance-and-processor-lifecycle","title":"Accessing the Flow instance and processor lifecycle","text":"<p>When <code>processInWorkflow: true</code>, you can receive the active Flow instance via the processor's constructor. This is useful when you need workflow context or to coordinate state within the same workflow execution.</p> <pre><code>public class ScheduledProcessor\n{\n    private readonly UserRequestFlow _userRequestFlow;\n\n    public ScheduledProcessor(UserRequestFlow userRequestFlow)\n    {\n        Console.WriteLine($\"ScheduledProcessor constructed with Flow: {userRequestFlow}\");\n        _userRequestFlow = userRequestFlow;\n    }\n\n    [CronSchedule(\"*/1 * * * *\")]\n    public void FrequentTask()\n    {\n        // Use _userRequestFlow as needed within the workflow context\n    }\n}\n</code></pre> <p>Note on lifecycle and state</p> <ul> <li>Processor instances are created per scheduled invocation. Any fields on the processor are scoped to that single execution and are not shared across runs.</li> <li>For state that must persist across invocations, store it on the workflow (via workflow state) or use activities/external storage.</li> </ul>"},{"location":"4-automation/2-scheduled-execution/#startautomatically-parameter","title":"<code>startAutomatically</code> Parameter","text":"<p>Controls whether schedules begin executing immediately when the workflow starts:</p> Parameter Value Behavior Use Cases <code>true</code> (default) Schedules start immediately when workflow runs \u2022 Standard automated processes \u2022 Background maintenance tasks \u2022 Regular business operations <code>false</code> Workflow must be manually triggered \u2022 On-demand scheduling \u2022 Conditional schedule activation \u2022 Manual process control"},{"location":"4-automation/2-scheduled-execution/#configuration-examples","title":"Configuration Examples","text":""},{"location":"4-automation/2-scheduled-execution/#basic-configuration","title":"Basic Configuration","text":"<pre><code>// Simple scheduled tasks with default settings\nvar flow = agent.AddAgent&lt;UserRequestFlow&gt;();\nflow.SetScheduleProcessor&lt;ScheduledProcessor&gt;();\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>// Complex orchestration with manual control\nvar flow = agent.AddAgent&lt;UserRequestFlow&gt;();\nflow.SetScheduleProcessor&lt;ScheduledProcessor&gt;(\n    processInWorkflow: true,     // Enable workflow features\n    startAutomatically: false    // Manual schedule control\n);\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#business-process-example","title":"Business Process Example","text":"<pre><code>// Financial processing that requires workflow capabilities\nvar flow = agent.AddAgent&lt;FinancialWorkflow&gt;();\nflow.SetScheduleProcessor&lt;FinancialProcessor&gt;(\n    processInWorkflow: true,     // Need timers and signals for approvals\n    startAutomatically: false    // Start only after compliance checks\n);\n\npublic class FinancialProcessor\n{\n    [MonthlySchedule(1, \"09:00\")]  // First day of month at 9 AM\n    public async Task ProcessMonthlyFinancials()\n    {\n        // Wait for month-end closing to complete\n        await Workflow.WaitConditionAsync(() =&gt; monthEndClosed);\n\n        // Process with approval timeout\n        await Workflow.ExecuteActivityAsync(\n            () =&gt; _activities.GenerateFinancialReport(),\n            new ActivityOptions { ScheduleToCloseTimeout = TimeSpan.FromHours(2) }\n        );\n\n        // Wait for approval with timeout\n        var approved = await Workflow.WaitConditionAsync(\n            () =&gt; reportApproved, \n            TimeSpan.FromDays(3)\n        );\n\n        if (approved)\n        {\n            await Workflow.ExecuteActivityAsync(() =&gt; _activities.DistributeReport());\n        }\n    }\n}\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#schedule-attributes","title":"Schedule Attributes","text":"<p>The XiansAi platform provides several scheduling attributes for different timing requirements:</p>"},{"location":"4-automation/2-scheduled-execution/#1-cronschedule-attribute","title":"1. CronSchedule Attribute","text":"<p>The <code>CronSchedule</code> attribute supports standard cron expressions and has two variants:</p>"},{"location":"4-automation/2-scheduled-execution/#hardcoded-cron-expression","title":"Hardcoded Cron Expression","text":"<pre><code>[CronSchedule(\"0 9 * * MON-FRI\")]  // 9 AM on weekdays\npublic void GenerateDailyReport() \n{\n    // Generate daily business reports\n    Console.WriteLine(\"Generating daily report...\");\n}\n\n[CronSchedule(\"0 0 1 * *\")]  // First day of each month at midnight\npublic void ProcessMonthlyBilling() \n{\n    // Process monthly billing cycles\n    Console.WriteLine(\"Processing monthly billing...\");\n}\n\n[CronSchedule(\"0 0 1 */3 *\")]  // First day of every quarter\npublic void QuarterlyReview() \n{\n    // Perform quarterly business reviews\n    Console.WriteLine(\"Performing quarterly review...\");\n}\n\n[CronSchedule(\"*/15 * * * *\")]  // Every 15 minutes\npublic void HealthCheck() \n{\n    // System health monitoring\n    Console.WriteLine(\"Performing health check...\");\n}\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#knowledge-based-cron-expression","title":"Knowledge-Based Cron Expression","text":"<p>For dynamic scheduling where the cron expression is stored in the Agent Portal's knowledge base:</p> <pre><code>[CronSchedule(\"Backup Schedule\", true)]\npublic void BackupTask() \n{\n    // The actual cron expression is retrieved from the knowledge base\n    // using the key \"Backup Schedule\"\n    Console.WriteLine($\"Processing backup task\");\n    Console.WriteLine($\"Processed at: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\");\n}\n</code></pre> <p>Knowledge-Based Benefits:</p> <ul> <li>Schedule can be modified without redeploying the agent</li> <li>Business users can update schedules through the Agent Portal</li> <li>Centralized schedule management across multiple agents</li> <li>Runtime schedule adjustments based on business needs</li> </ul>"},{"location":"4-automation/2-scheduled-execution/#2-intervalschedule-attribute","title":"2. IntervalSchedule Attribute","text":"<p>Execute tasks at regular intervals using various time units:</p> <pre><code>// Execute every 30 seconds\n[IntervalSchedule(seconds: 30)]\npublic void MonitorSystemMetrics()\n{\n    Console.WriteLine(\"Monitoring system metrics...\");\n}\n\n// Execute every 5 minutes\n[IntervalSchedule(minutes: 5)]\npublic void ProcessQueuedItems()\n{\n    Console.WriteLine(\"Processing queued items...\");\n}\n\n// Execute every 2 hours\n[IntervalSchedule(hours: 2)]\npublic void SyncExternalData()\n{\n    Console.WriteLine(\"Syncing external data...\");\n}\n\n// Execute every 3 days\n[IntervalSchedule(days: 3)]\npublic void PerformMaintenance()\n{\n    Console.WriteLine(\"Performing system maintenance...\");\n}\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#3-dailyschedule-attribute","title":"3. DailySchedule Attribute","text":"<p>Execute tasks at a specific time each day:</p> <pre><code>// Every day at 8:30 AM\n[DailySchedule(\"08:30\")]\npublic void MorningReports()\n{\n    Console.WriteLine(\"Generating morning reports...\");\n}\n\n// Every day at 6:00 PM\n[DailySchedule(\"18:00\")]\npublic void EndOfDayProcessing()\n{\n    Console.WriteLine(\"Processing end-of-day tasks...\");\n}\n\n// Every day at midnight\n[DailySchedule(\"00:00\")]\npublic void DailyDataArchival()\n{\n    Console.WriteLine(\"Archiving daily data...\");\n}\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#4-weeklyschedule-attribute","title":"4. WeeklySchedule Attribute","text":"<p>Execute tasks on specific days of the week at designated times:</p> <pre><code>// Every Tuesday at 2:00 PM\n[WeeklySchedule(DayOfWeek.Tuesday, \"14:00\")]\npublic void WeeklyTeamMeeting()\n{\n    Console.WriteLine(\"Preparing weekly team meeting data...\");\n}\n\n// Every Friday at 5:00 PM\n[WeeklySchedule(DayOfWeek.Friday, \"17:00\")]\npublic void WeeklyReports()\n{\n    Console.WriteLine(\"Generating weekly reports...\");\n}\n\n// Every Monday at 9:00 AM\n[WeeklySchedule(DayOfWeek.Monday, \"09:00\")]\npublic void WeeklyPlanning()\n{\n    Console.WriteLine(\"Initiating weekly planning process...\");\n}\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#5-monthlyschedule-attribute","title":"5. MonthlySchedule Attribute","text":"<p>Execute tasks on specific days of the month:</p> <pre><code>// Monthly on the 1st at 9:00 AM\n[MonthlySchedule(1, \"09:00\")]\npublic void MonthlyBilling()\n{\n    Console.WriteLine(\"Processing monthly billing...\");\n}\n\n// Monthly on the 15th at 2:00 PM\n[MonthlySchedule(15, \"14:00\")]\npublic void MidMonthReports()\n{\n    Console.WriteLine(\"Generating mid-month reports...\");\n}\n\n// Monthly on the last day (31st, adjusts for shorter months)\n[MonthlySchedule(31, \"23:59\")]\npublic void MonthEndProcessing()\n{\n    Console.WriteLine(\"Processing month-end tasks...\");\n}\n</code></pre>"},{"location":"4-automation/2-scheduled-execution/#when-to-use-this-approach","title":"When to Use This Approach","text":"<p>This alternative scheduling method may be appropriate for:</p> <ul> <li>Legacy systems being migrated to the XiansAi platform</li> <li>Specialized scheduling requirements not supported by Temporal's native features</li> <li>Experimental or prototype workflows</li> </ul> <p>For production systems and standard scheduling needs, use Flow Scheduling instead, which provides better stability, reliability, and leverages Temporal's proven scheduling infrastructure.</p>"},{"location":"4-automation/2-scheduled-execution/#comparison-with-flow-scheduling","title":"Comparison with Flow Scheduling","text":"Feature Flow Scheduling (Recommended) Scheduled Execution (Alternative) Stability High - Uses Temporal's native scheduling Lower - Custom implementation Reliability Production-ready with proven fault tolerance May have limitations Ease of Use Simple setup with <code>SetScheduleAsync</code> Requires processor configuration Maintenance Managed by Temporal Requires additional oversight Use Case Recommended for all production scenarios Specific legacy or edge cases <p>For most use cases, the schedule attributes and processor configuration described in this document should be replaced with the simpler and more reliable Flow Scheduling approach.</p>"},{"location":"4-automation/2-scheduling-sdk/","title":"Scheduling SDK","text":"<p>For advanced scenarios where you need to dynamically create and manipulate schedules at runtime, the Xians platform provides the <code>SchedulerHub</code> class. This gives you programmatic control over workflow scheduling from within your agent code.</p>"},{"location":"4-automation/2-scheduling-sdk/#overview","title":"Overview","text":"<p>The <code>SchedulerHub</code> class enables you to:</p> <ul> <li>Create schedules dynamically based on user input or system events</li> <li>Manage existing schedules (pause, unpause, delete, update)</li> <li>Trigger immediate workflow executions</li> <li>Query and inspect schedule configurations</li> <li>Backfill missed executions</li> </ul>"},{"location":"4-automation/2-scheduling-sdk/#creating-schedules","title":"Creating Schedules","text":"<p>You can create schedules in two ways:</p>"},{"location":"4-automation/2-scheduling-sdk/#using-workflow-type","title":"Using Workflow Type","text":"<pre><code>using Temporalio.Client.Schedules;\nusing XiansAi.Scheduler;\n\n// Create a schedule using the workflow class type\nvar scheduleHandle = await SchedulerHub.CreateScheduleAsync(\n    typeof(MyWorkflowFlow),\n    new ScheduleSpec {\n        CronExpressions = new List&lt;string&gt; { \"0 9 * * *\" } // Daily at 9 AM\n    },\n    scheduleName: \"daily-report\"\n);\n</code></pre>"},{"location":"4-automation/2-scheduling-sdk/#using-workflow-id-or-type-string","title":"Using Workflow ID or Type String","text":"<pre><code>// Create a schedule using workflow type string\nvar scheduleHandle = await SchedulerHub.CreateScheduleAsync(\n    workflowIdOrType: \"MyWorkflowFlow\",\n    new ScheduleSpec {\n        CronExpressions = new List&lt;string&gt; { \"*/15 * * * *\" } // Every 15 minutes\n    },\n    scheduleName: \"frequent-check\",\n    options: new WorkflowOptions {\n        RunTimeout = TimeSpan.FromMinutes(5)\n    }\n);\n</code></pre>"},{"location":"4-automation/2-scheduling-sdk/#managing-schedules","title":"Managing Schedules","text":""},{"location":"4-automation/2-scheduling-sdk/#pause-a-schedule","title":"Pause a Schedule","text":"<pre><code>await SchedulerHub.PauseAsync(\n    scheduleId: \"daily-report\",\n    note: \"Paused for maintenance\"\n);\n</code></pre>"},{"location":"4-automation/2-scheduling-sdk/#unpause-a-schedule","title":"Unpause a Schedule","text":"<pre><code>await SchedulerHub.UnpauseAsync(\n    scheduleId: \"daily-report\",\n    note: \"Resuming after maintenance\"\n);\n</code></pre>"},{"location":"4-automation/2-scheduling-sdk/#delete-a-schedule","title":"Delete a Schedule","text":"<pre><code>await SchedulerHub.DeleteAsync(\"daily-report\");\n</code></pre> <p>Note</p> <p>Deleting a schedule does not affect workflow executions that have already been started by the schedule.</p>"},{"location":"4-automation/2-scheduling-sdk/#trigger-immediate-execution","title":"Trigger Immediate Execution","text":"<pre><code>// Manually trigger a scheduled workflow to run immediately\nawait SchedulerHub.TriggerAsync(\"daily-report\");\n</code></pre>"},{"location":"4-automation/2-scheduling-sdk/#querying-schedules","title":"Querying Schedules","text":""},{"location":"4-automation/2-scheduling-sdk/#describe-a-schedule","title":"Describe a Schedule","text":"<pre><code>var description = await SchedulerHub.DescribeAsync(\"daily-report\");\n\nConsole.WriteLine($\"Schedule: {description.Id}\");\nConsole.WriteLine($\"Is Paused: {description.Schedule.State.Paused}\");\nConsole.WriteLine($\"Next Run: {description.Info.NextActionTimes.FirstOrDefault()}\");\n</code></pre>"},{"location":"4-automation/2-scheduling-sdk/#list-all-schedules","title":"List All Schedules","text":"<pre><code>var schedules = await SchedulerHub.ListSchedulesAsync();\n\nawait foreach (var schedule in schedules)\n{\n    Console.WriteLine($\"Schedule ID: {schedule.ScheduleId}\");\n    Console.WriteLine($\"Workflow Type: {schedule.Info.WorkflowType}\");\n}\n</code></pre>"},{"location":"4-automation/2-scheduling-sdk/#updating-schedules","title":"Updating Schedules","text":"<pre><code>await SchedulerHub.UpdateAsync(\"daily-report\", input =&gt;\n{\n    // Modify the schedule specification\n    var updatedSchedule = input.Description.Schedule;\n    updatedSchedule.Spec.CronExpressions = new List&lt;string&gt; { \"0 10 * * *\" }; // Change to 10 AM\n\n    return new ScheduleUpdate(updatedSchedule);\n});\n</code></pre>"},{"location":"4-automation/2-scheduling-sdk/#backfilling-schedules","title":"Backfilling Schedules","text":"<p>If you need to execute workflows for missed time periods:</p> <pre><code>var schedulerHub = new SchedulerHub();\n\nawait schedulerHub.BackfillAsync(\n    scheduleId: \"daily-report\",\n    backfills: new[] {\n        new ScheduleBackfill(\n            startAt: DateTime.UtcNow.AddDays(-7),\n            endAt: DateTime.UtcNow,\n            overlap: ScheduleOverlapPolicy.Skip\n        )\n    }\n);\n</code></pre>"},{"location":"4-automation/2-scheduling-sdk/#real-world-example","title":"Real-World Example","text":"<p>Here's a practical example from a super agent that manages scheduled subagent runs:</p> <pre><code>[Capability(\"Schedule a new subagent run definition for the user\")]\n[Parameter(\"subagentInstructions\", \"Subagent definition in JSON format\")]\n[Parameter(\"cronTrigger\", \"Cron trigger for the subagent\")]\n[Returns(\"Success message\")]\npublic async Task&lt;string&gt; ScheduleSubAgentRuns(string subagentInstructions, string cronTrigger)\n{\n    var guid = Guid.NewGuid();\n\n    // Save the subagent configuration to memory\n    await MemoryHub.Documents.SaveAsync(new Document {\n        Type = \"SubAgentDefinition\",\n        Key: guid.ToString(),\n        Content: JsonSerializer.SerializeToElement(subagentInstructions),\n        Metadata: new Dictionary&lt;string, object&gt; {\n            { \"userId\", _thread.ParticipantId }\n        }\n    });\n\n    // Create a schedule using the GUID as the schedule name\n    await SchedulerHub.CreateScheduleAsync(\n        typeof(ProspectorAgent),\n        new ScheduleSpec {\n            CronExpressions = new List&lt;string&gt; { cronTrigger }\n        },\n        scheduleName: guid.ToString()\n    );\n\n    return \"Subagent definition created successfully\";\n}\n\n[Capability(\"Delete a scheduled subagent run for the user\")]\n[Parameter(\"guid\", \"GUID of the subagent definition to delete\")]\npublic async Task&lt;string&gt; DeleteScheduledSubAgentRun(string guid)\n{\n    var existing = await GetScheduledSubAgentRun(guid);\n    if (existing == null) {\n        return \"Subagent definition not found\";\n    }\n\n    await SchedulerHub.DeleteAsync(guid);\n    return \"Subagent definition deleted successfully\";\n}\n</code></pre> <p>This example shows how to:</p> <ul> <li>Dynamically create schedules based on user-provided cron expressions</li> <li>Use GUIDs as schedule identifiers for easy correlation with stored data</li> <li>Clean up schedules when they're no longer needed</li> </ul>"},{"location":"4-automation/2-scheduling-sdk/#schedule-specifications","title":"Schedule Specifications","text":"<p>When creating schedules, you can use various <code>ScheduleSpec</code> options:</p> <pre><code>var spec = new ScheduleSpec\n{\n    // Cron expressions (can specify multiple)\n    CronExpressions = new List&lt;string&gt; { \n        \"0 9 * * 1-5\"  // Weekdays at 9 AM\n    },\n\n    // Or use intervals\n    Intervals = new List&lt;ScheduleIntervalSpec&gt; {\n        new ScheduleIntervalSpec {\n            Every = TimeSpan.FromHours(2),\n            Offset = TimeSpan.FromMinutes(15)\n        }\n    },\n\n    // Skip times\n    Skip = new List&lt;ScheduleCalendarSpec&gt; {\n        new ScheduleCalendarSpec {\n            DayOfWeek = new[] { 0, 6 }  // Skip weekends\n        }\n    },\n\n    // Time zone\n    TimeZoneId = \"America/New_York\"\n};\n</code></pre>"},{"location":"4-automation/3-fault-tolerance/","title":"Fault Tolerance and Error Handling","text":""},{"location":"4-automation/3-fault-tolerance/#overview","title":"Overview","text":"<p>Xians leverages Temporal workflow capabilities to provide robust fault tolerance and error handling for AI agents. Temporal automatically manages workflow state, retries, and failure recovery, eliminating the need for custom implementation of complex error handling patterns.</p>"},{"location":"4-automation/3-fault-tolerance/#temporal-based-fault-tolerance","title":"Temporal-Based Fault Tolerance","text":""},{"location":"4-automation/3-fault-tolerance/#core-principle","title":"Core Principle","text":"<p>To utilize fault tolerance features, critical business logic must run within workflows, not activities. Activities should only perform stateless operations and delegate complex error handling to workflows.</p>"},{"location":"4-automation/3-fault-tolerance/#workflow-configuration","title":"Workflow Configuration","text":"<p>Enable fault-tolerant processing by setting <code>processInWorkflow = true</code>:</p> <pre><code>// Data processing in workflow\nflow.SetDataProcessor&lt;MyDataProcessor&gt;(processInWorkflow: true);\n\n// Schedule processing in workflow\nflow.SetScheduleProcessor&lt;MyScheduleProcessor&gt;(processInWorkflow: true);\n</code></pre>"},{"location":"4-automation/3-fault-tolerance/#starting-workflows-from-activities","title":"Starting Workflows from Activities","text":"<p>When in an activity, explicitly start a workflow for fault-tolerant execution:</p>"},{"location":"4-automation/3-fault-tolerance/#retry-policies","title":"Retry Policies","text":""},{"location":"4-automation/3-fault-tolerance/#custom-retry-configuration","title":"Custom Retry Configuration","text":"<p>Always configure custom retry policies. The default Temporal retry policy attempts infinite retries, which can cause issues:</p> <pre><code>var retryPolicy = new RetryPolicy\n{\n    InitialInterval = TimeSpan.FromSeconds(1),\n    MaximumInterval = TimeSpan.FromMinutes(2),\n    BackoffCoefficient = 2.0,\n    MaximumAttempts = 5,\n    NonRetryableErrorTypes = new[] { \"ValidationException\", \"AuthenticationException\" }\n};\n\n// Apply to activity execution\nawait Workflow.ExecuteActivityAsync(\n    () =&gt; MyActivity.ProcessAsync(data),\n    new ActivityOptions \n    { \n        ScheduleToCloseTimeout = TimeSpan.FromMinutes(10),\n        RetryPolicy = retryPolicy \n    });\n</code></pre>"},{"location":"4-automation/3-fault-tolerance/#timeout-configuration","title":"Timeout Configuration","text":"<p>Use <code>ScheduleToCloseTimeout</code> to set maximum duration for activity completion:</p> <pre><code>var activityOptions = new ActivityOptions\n{\n    ScheduleToCloseTimeout = TimeSpan.FromHours(1), // Maximum total time\n    StartToCloseTimeout = TimeSpan.FromMinutes(10),  // Per-attempt timeout\n    RetryPolicy = retryPolicy\n};\n</code></pre>"},{"location":"4-automation/3-fault-tolerance/#exception-handling","title":"Exception Handling","text":""},{"location":"4-automation/3-fault-tolerance/#recoverable-failures","title":"Recoverable Failures","text":"<p>Activities should throw exceptions for recoverable failures to trigger Temporal's retry mechanisms:</p> <pre><code>[Activity]\npublic async Task&lt;ProcessResult&gt; ProcessDataActivity(ProcessingRequest request)\n{\n    try\n    {\n        var result = await _externalService.ProcessAsync(request);\n        return result;\n    }\n    catch (HttpRequestException ex) when (ex.Message.Contains(\"timeout\"))\n    {\n        // Let Temporal retry transient network issues\n        throw new ApplicationFailureException(\"Network timeout occurred\", ex);\n    }\n    catch (SqlException ex) when (IsTransientError(ex))\n    {\n        // Let Temporal retry database connection issues\n        throw new ApplicationFailureException(\"Database connection failed\", ex);\n    }\n}\n</code></pre>"},{"location":"4-automation/3-fault-tolerance/#non-retryable-failures","title":"Non-Retryable Failures","text":"<p>For data validation and permanent failures, set <code>NonRetryable = true</code>:</p> <pre><code>[Activity]\npublic async Task ValidateAndProcess(ProcessingRequest request)\n{\n    if (string.IsNullOrEmpty(request.UserId))\n    {\n        // Don't retry validation failures\n        throw new ApplicationFailureException(\n            \"User ID is required\", \n            null, \n            nonRetryable: true);\n    }\n\n    if (!await _authService.IsAuthorized(request.UserId))\n    {\n        // Don't retry authorization failures\n        throw new ApplicationFailureException(\n            \"User not authorized\", \n            null, \n            nonRetryable: true);\n    }\n\n    // Process the request...\n}\n</code></pre>"},{"location":"4-automation/3-fault-tolerance/#workflow-implementation-examples","title":"Workflow Implementation Examples","text":""},{"location":"4-automation/3-fault-tolerance/#data-processing-workflow","title":"Data Processing Workflow","text":"<pre><code>[Workflow]\npublic class DataProcessingWorkflow\n{\n    private readonly RetryPolicy _defaultRetryPolicy = new()\n    {\n        InitialInterval = TimeSpan.FromSeconds(2),\n        MaximumInterval = TimeSpan.FromMinutes(5),\n        BackoffCoefficient = 2.0,\n        MaximumAttempts = 3,\n        NonRetryableErrorTypes = new[] { \"ValidationException\" }\n    };\n\n    [WorkflowRun]\n    public async Task&lt;ProcessingResult&gt; RunAsync(DataProcessingRequest request)\n    {\n        // Validate input (non-retryable)\n        await Workflow.ExecuteActivityAsync(\n            () =&gt; ValidationActivity.ValidateAsync(request),\n            new ActivityOptions\n            {\n                StartToCloseTimeout = TimeSpan.FromMinutes(1),\n                RetryPolicy = new RetryPolicy { MaximumAttempts = 1 }\n            });\n\n        // Process data (retryable)\n        var processResult = await Workflow.ExecuteActivityAsync(\n            () =&gt; ProcessingActivity.ProcessAsync(request),\n            new ActivityOptions\n            {\n                ScheduleToCloseTimeout = TimeSpan.FromHours(2),\n                StartToCloseTimeout = TimeSpan.FromMinutes(30),\n                RetryPolicy = _defaultRetryPolicy\n            });\n\n        // Store results (retryable)\n        await Workflow.ExecuteActivityAsync(\n            () =&gt; StorageActivity.StoreAsync(processResult),\n            new ActivityOptions\n            {\n                StartToCloseTimeout = TimeSpan.FromMinutes(5),\n                RetryPolicy = _defaultRetryPolicy\n            });\n\n        return processResult;\n    }\n}\n</code></pre>"},{"location":"4-automation/3-fault-tolerance/#error-categories-and-handling","title":"Error Categories and Handling","text":""},{"location":"4-automation/3-fault-tolerance/#transient-errors-retryable","title":"Transient Errors (Retryable)","text":"<ul> <li>Network timeouts</li> <li>Database connection failures</li> <li>Temporary service unavailability</li> <li>Rate limiting (429 errors)</li> </ul> <pre><code>// Let Temporal handle retries automatically\nthrow new ApplicationFailureException(\"Service temporarily unavailable\", ex);\n</code></pre>"},{"location":"4-automation/3-fault-tolerance/#permanent-errors-non-retryable","title":"Permanent Errors (Non-Retryable)","text":"<ul> <li>Data validation failures</li> <li>Authentication/authorization errors</li> <li>Business rule violations</li> <li>Malformed requests</li> </ul> <pre><code>// Prevent unnecessary retries\nthrow new ApplicationFailureException(\"Invalid data format\", ex, nonRetryable: true);\n</code></pre>"},{"location":"4-automation/3-fault-tolerance/#timeout-types","title":"Timeout Types","text":"<ul> <li>StartToCloseTimeout: Maximum time for single activity execution</li> <li>ScheduleToCloseTimeout: Maximum total time including all retries</li> <li>HeartbeatTimeout: For long-running activities requiring heartbeats</li> </ul> <p>For more details, see Temporal Failure Handling.</p>"},{"location":"4-automation/3-fault-tolerance/#best-practices","title":"Best Practices","text":"<ol> <li>Run Critical Logic in Workflows: Place fault-tolerant business logic in workflows, not activities</li> <li>Configure Custom Retry Policies: Never rely on default infinite retry behavior</li> <li>Use Appropriate Timeouts: Set reasonable timeouts to prevent hanging processes</li> <li>Mark Non-Retryable Errors: Use <code>nonRetryable: true</code> for validation and permanent failures</li> <li>Implement Compensation: Use workflow capabilities for rollback and cleanup operations</li> <li>Monitor Workflow Execution: Leverage Temporal's UI and metrics for observability</li> </ol> <p>Temporal's workflow engine provides automatic state management, retry logic, and failure recovery, making fault tolerance straightforward and reliable without custom implementation complexity.</p>"},{"location":"4-automation/4-long-running-processes/","title":"Long-running processes with Temporal in Xians","text":"<p>Xians uses Temporal Workflows to reliably run operations that span hours, days, or even years. Workflows are durable: they survive worker restarts, deploys, and outages. This makes them ideal for human-in-the-loop steps, SLAs, escalations, and any process that must \u201cpause\u201d and later resume deterministically.</p>"},{"location":"4-automation/4-long-running-processes/#core-building-blocks","title":"Core building blocks","text":"<ul> <li>Durable Timers: Pause a Workflow for a precise duration without holding system resources. Timers persist in Temporal and automatically resume when due.</li> <li>Conditional waits: Block until a business condition becomes true, typically after receiving external input via Signals or Updates.</li> <li>Signals and Updates: Messages that change Workflow state and resume progress. Signals are fire-and-forget; Updates are validated, tracked, and return results.</li> </ul>"},{"location":"4-automation/4-long-running-processes/#minimal-net-examples","title":"Minimal .NET examples","text":"<ul> <li>Sleep/wait with a durable timer</li> </ul> <pre><code>// Pause the workflow for 3 days; resumes reliably even across restarts\nawait Workflow.DelayAsync(TimeSpan.FromDays(3));\n</code></pre> <ul> <li>Wait for external approval (Signal) before proceeding</li> </ul> <pre><code>public class DataProcessor {\n\n    private readonly MessageThread _messageThread;\n    private readonly ApprovalWorkflow _flow;\n\n    public DataProcessor(MessageThread messageThread, ApprovalWorkflow flow) {\n        _messageThread = messageThread;\n        _flow = flow;\n    }\n\n    public async Task ApproveAsync() {\n        _flow.SetApproved(true);\n    }\n</code></pre> <pre><code>public class ApprovalWorkflow: FlowBase\n{\n    private bool approved;\n\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        await Workflow.WaitConditionAsync(() =&gt; approved);\n        // continue after approval\n    }\n\n    public void SetApproved(bool approved) { \n        approved = true; \n    }\n}\n</code></pre>"},{"location":"4-automation/4-long-running-processes/#common-xians-scenarios","title":"Common Xians scenarios","text":"<ul> <li>Human approval with expiry: Start a Workflow when a request is created. Wait for an <code>ApproveAsync</code> Signal. If not approved within 7 days, auto-cancel or escalate. Uses a durable timer (SLA) + conditional wait (approval flag).</li> <li>Multi-step onboarding: Gate each step (KYC, contract, funding) behind a condition. Each gate has a timer for reminders and escalations. Signals/Updates set completion state.</li> <li>External system callback with SLA: Wait for a Signal from a downstream system indicating completion. In parallel, maintain an SLA timer; on timeout, retry, reroute, or notify ops.</li> <li>Subscription renewals and dunning: Sleep until renewal date, collect payment via Activity, then either complete or schedule retries/reminders using timers and conditions.</li> <li>Inventory/fulfillment holds: Park an order awaiting stock availability. Wake via Signal when inventory arrives; otherwise expire after N days and refund.</li> </ul>"},{"location":"4-automation/5-creating-sub-flows/","title":"Sub-Flows Created by Interface Flows","text":""},{"location":"4-automation/5-creating-sub-flows/#overview","title":"Overview","text":"<p>The XiansAi platform enables any workflow to spawn new workflow instances using the <code>AgentContext.StartWorkflow</code> and <code>AgentContext.ExecuteWorkflow</code> methods. This powerful capability allows ever-running interface workflows (conversational, scheduled, or data processor flows) to create dedicated business process workflows that live for the duration of specific business transactions.</p>"},{"location":"4-automation/5-creating-sub-flows/#understanding-the-pattern","title":"Understanding the Pattern","text":""},{"location":"4-automation/5-creating-sub-flows/#ever-running-interface-flows-vs-process-workflows","title":"Ever-Running Interface Flows vs Process Workflows","text":"<p>The XiansAi platform follows a clear architectural pattern:</p> <ul> <li>Interface Flows: Long-running workflows that continuously listen for external triggers</li> <li>Conversational flows that process user messages</li> <li>Scheduled flows that execute on timers  </li> <li>Data processor flows that handle API calls</li> <li>Process (Sub) Workflows: Short-lived workflows that execute specific business processes</li> <li>Order processing workflows</li> <li>Document approval workflows</li> <li>Support ticket resolution workflows</li> </ul>"},{"location":"4-automation/5-creating-sub-flows/#the-event-loop-pattern","title":"The Event Loop Pattern","text":"<p>Interface flows act as event loops that remain active indefinitely, waiting for triggers and spawning process workflows as needed. This creates a clear separation of concerns:</p> <ul> <li>Interface flows handle external communication and routing</li> <li>Process workflows handle business logic and state management</li> </ul>"},{"location":"4-automation/5-creating-sub-flows/#interface-flows-and-sub-flows-in-practice","title":"Interface Flows and Sub-Flows in Practice","text":"<p>The following sequence diagrams illustrate how interface flows spawn sub-workflows in real-world scenarios:</p>"},{"location":"4-automation/5-creating-sub-flows/#conversational-flow-pattern","title":"Conversational Flow Pattern","text":"<pre><code>sequenceDiagram\n    participant User\n    participant ConversationalFlow as Conversational Flow&lt;br/&gt;(Ever-Running)\n    participant SupportFlow as Support Ticket Workflow&lt;br/&gt;(Sub-Flow)\n    participant OrderFlow as Order Processing Workflow&lt;br/&gt;(Sub-Flow)\n\n    User-&gt;&gt;ConversationalFlow: \"Create support ticket for login issue\"\n    ConversationalFlow-&gt;&gt;SupportFlow: StartWorkflow(ticketId, issue)\n    Note over SupportFlow: Fire-and-forget execution\n    ConversationalFlow--&gt;&gt;User: \"Ticket created, being processed\"\n\n    User-&gt;&gt;ConversationalFlow: \"Process my order #12345\"\n    ConversationalFlow-&gt;&gt;OrderFlow: ExecuteWorkflow(orderId, orderData)\n    Note over OrderFlow: Synchronous execution\n    OrderFlow--&gt;&gt;ConversationalFlow: OrderResult(status, details)\n    ConversationalFlow--&gt;&gt;User: \"Order processed: Approved\"</code></pre>"},{"location":"4-automation/5-creating-sub-flows/#scheduled-flow-pattern","title":"Scheduled Flow Pattern","text":"<pre><code>sequenceDiagram\n    participant Timer\n    participant ScheduledFlow as Scheduled Flow&lt;br/&gt;(Ever-Running)\n    participant BillingFlow as Customer Billing Workflow&lt;br/&gt;(Sub-Flow)\n    participant NotificationFlow as Notification Workflow&lt;br/&gt;(Sub-Flow)\n\n    Timer-&gt;&gt;ScheduledFlow: Monthly trigger (1st of month)\n    loop For each customer\n        ScheduledFlow-&gt;&gt;BillingFlow: StartWorkflow(customerId, month)\n        Note over BillingFlow: Parallel execution per customer\n    end\n    ScheduledFlow-&gt;&gt;NotificationFlow: StartWorkflow(adminReport)\n    Note over NotificationFlow: Send billing summary to admin</code></pre>"},{"location":"4-automation/5-creating-sub-flows/#data-processor-flow-pattern","title":"Data Processor Flow Pattern","text":"<pre><code>sequenceDiagram\n    participant ExternalAPI as External API\n    participant DataProcessorFlow as Data Processor Flow&lt;br/&gt;(Ever-Running)\n    participant ContractFlow as Contract Processing Workflow&lt;br/&gt;(Sub-Flow)\n    participant SimpleDocFlow as Simple Document Workflow&lt;br/&gt;(Sub-Flow)\n\n    ExternalAPI-&gt;&gt;DataProcessorFlow: POST /process-document (contract)\n    DataProcessorFlow-&gt;&gt;ContractFlow: ExecuteWorkflow(documentId, contractData)\n    Note over ContractFlow: Complex processing with approval\n    ContractFlow--&gt;&gt;DataProcessorFlow: ContractResult(approved, comments)\n    DataProcessorFlow--&gt;&gt;ExternalAPI: ProcessingResult(status, details)\n\n    ExternalAPI-&gt;&gt;DataProcessorFlow: POST /process-document (simple)\n    DataProcessorFlow-&gt;&gt;SimpleDocFlow: StartWorkflow(documentId, simpleData)\n    Note over SimpleDocFlow: Fire-and-forget processing\n    DataProcessorFlow--&gt;&gt;ExternalAPI: ProcessingResult(processing initiated)</code></pre> <p>Key Patterns: - Interface Flows remain running indefinitely, handling external triggers - StartWorkflow creates fire-and-forget sub-flows for parallel processing - ExecuteWorkflow creates sub-flows and waits for results before responding - Sub-flows handle specific business processes with defined lifecycles</p>"},{"location":"4-automation/5-creating-sub-flows/#agentcontext-methods","title":"AgentContext Methods","text":"<p>The <code>AgentContext</code> class provides two methods for creating sub-workflows:</p>"},{"location":"4-automation/5-creating-sub-flows/#startworkflow-method","title":"StartWorkflow Method","text":"<p>Starts a new workflow instance asynchronously without waiting for completion:</p> <pre><code>public static async Task StartWorkflow&lt;TWorkflow&gt;(string namePostfix, object[] args)\n</code></pre> <p>Parameters:</p> <ul> <li><code>TWorkflow</code>: The workflow class type to start</li> <li><code>namePostfix</code>: A unique identifier appended to the workflow id</li> <li><code>args</code>: Arguments to pass to the workflow's Run method</li> </ul> <p>Use Cases:</p> <ul> <li>Fire-and-forget business processes</li> <li>Background processing that doesn't require a response</li> <li>Parallel workflow execution</li> </ul>"},{"location":"4-automation/5-creating-sub-flows/#executeworkflow-method","title":"ExecuteWorkflow Method","text":"<p>Starts a new workflow instance and waits for its completion, returning a result:</p> <pre><code>public static async Task&lt;TResult&gt; ExecuteWorkflow&lt;TWorkflow, TResult&gt;(string namePostfix, object[] args)\n</code></pre> <p>Parameters:</p> <ul> <li><code>TWorkflow</code>: The workflow class type to execute</li> <li><code>TResult</code>: The return type expected from the workflow</li> <li><code>namePostfix</code>: A unique identifier appended to the workflow id  </li> <li><code>args</code>: Arguments to pass to the workflow's Run method</li> </ul> <p>Use Cases:</p> <ul> <li>Synchronous business processes that require a response</li> <li>Workflows that return processing results</li> <li>Sequential workflow dependencies</li> </ul>"},{"location":"4-automation/5-creating-sub-flows/#implementation-examples","title":"Implementation Examples","text":""},{"location":"4-automation/5-creating-sub-flows/#1-conversational-flow-spawning-process-workflows","title":"1. Conversational Flow Spawning Process Workflows","text":"<p>Conversational flows can spawn dedicated workflows for complex business processes:</p> <p>Capability Implementation:</p> <pre><code>public class SupportCapabilities\n{\n    [Capability(\"Create a technical support ticket\")]\n    public async Task&lt;string&gt; CreateSupportTicket(string customerEmail, string issue)\n    {\n        // Spawn a dedicated support ticket workflow\n        var ticketId = Guid.NewGuid().ToString();\n        await AgentContext.StartWorkflow&lt;SupportTicketWorkflow&gt;(\n            ticketId, \n            new object[] { customerEmail, issue, ticketId }\n        );\n\n        return $\"Support ticket {ticketId} has been created and is being processed.\";\n    }\n\n    [Capability(\"Process order with approval workflow\")]\n    public async Task&lt;string&gt; ProcessOrder(OrderRequest order)\n    {\n        // Execute order workflow and wait for result\n        var result = await AgentContext.ExecuteWorkflow&lt;OrderProcessingWorkflow, OrderResult&gt;(\n            order.OrderId,\n            new object[] { order }\n        );\n\n        return $\"Order {order.OrderId} processed. Status: {result.Status}\";\n    }\n}\n</code></pre>"},{"location":"4-automation/5-creating-sub-flows/#2-scheduled-flow-spawning-process-workflows","title":"2. Scheduled Flow Spawning Process Workflows","text":"<p>Scheduled flows can create workflows for time-based business processes:</p> <pre><code>[Workflow(\"Billing Agent:Scheduled Processor\")]\npublic class BillingScheduledFlow : FlowBase\n{\n    [WorkflowRun]\n    public async Task Run()\n    {\n        await InitSchedule();\n    }\n}\n\npublic class BillingProcessor\n{\n    [MonthlySchedule(1, \"09:00\")] // First day of month at 9 AM\n    public async Task ProcessMonthlyBilling()\n    {\n        var customers = await GetActiveCustomers();\n\n        foreach (var customer in customers)\n        {\n            // Start individual billing workflows for each customer\n            await AgentContext.StartWorkflow&lt;CustomerBillingWorkflow&gt;(\n                customer.Id,\n                new object[] { customer.Id, DateTime.UtcNow.Month }\n            );\n        }\n    }\n\n}\n</code></pre>"},{"location":"4-automation/5-creating-sub-flows/#3-data-processor-flow-spawning-process-workflows","title":"3. Data Processor Flow Spawning Process Workflows","text":"<p>Data processor flows can spawn workflows based on external API calls:</p> <pre><code>[Workflow(\"Document Processor:Main Flow\")]\npublic class DocumentProcessorFlow : FlowBase\n{\n    [WorkflowRun]\n    public async Task Run()\n    {\n        await InitDataProcessor();\n    }\n}\n\npublic class DocumentProcessor\n{\n    public async Task&lt;ProcessingResult&gt; ProcessDocument(DocumentRequest request)\n    {\n        // For complex documents, spawn a dedicated processing workflow\n        if (request.DocumentType == \"Contract\")\n        {\n            var result = await AgentContext.ExecuteWorkflow&lt;ContractProcessingWorkflow, ContractResult&gt;(\n                request.DocumentId,\n                new object[] { request }\n            );\n\n            return new ProcessingResult \n            { \n                DocumentId = request.DocumentId,\n                Status = result.IsApproved ? \"Approved\" : \"Rejected\",\n                Details = result.ReviewComments\n            };\n        }\n\n        // For simple documents, spawn fire-and-forget workflow\n        await AgentContext.StartWorkflow&lt;SimpleDocumentWorkflow&gt;(\n            request.DocumentId,\n            new object[] { request }\n        );\n\n        return new ProcessingResult \n        { \n            DocumentId = request.DocumentId,\n            Status = \"Processing\",\n            Details = \"Document processing initiated\"\n        };\n    }\n}\n</code></pre> <p>This sub-workflow pattern integrates seamlessly with the existing XiansAi flow types:</p> <ul> <li>Conversational Flows: Use capabilities to spawn business process workflows</li> <li>Scheduled Flows: Use schedule processors to create time-based workflows  </li> <li>Data Processor Flows: Use data processors to spawn workflows from external API calls</li> </ul> <p>By leveraging <code>AgentContext.StartWorkflow</code> and <code>AgentContext.ExecuteWorkflow</code>, any interface flow can become a powerful orchestrator of business processes, enabling complex automation scenarios while maintaining clean architectural boundaries.</p>"},{"location":"5-inference/7-chat-interceptors/","title":"Chat Interceptors","text":"<p>Chat interceptors provide a powerful mechanism to intercept and modify chat messages both before they are processed by the LLM and after the LLM generates a response. This functionality is specifically designed for Chat message types only and enables you to implement custom logic for message processing, filtering, transformation, or blocking.</p>"},{"location":"5-inference/7-chat-interceptors/#overview","title":"Overview","text":"<p>Chat interceptors implement the <code>IChatInterceptor</code> interface and allow you to:</p> <ul> <li>Intercept incoming messages before they reach the LLM for processing</li> <li>Intercept outgoing messages after the LLM generates a response but before sending to the user</li> <li>Modify message content at both incoming and outgoing stages</li> <li>Block or filter messages based on custom logic</li> <li>Add additional processing such as logging, validation, or enrichment</li> <li>Transform message format or content structure</li> </ul>"},{"location":"5-inference/7-chat-interceptors/#the-ichatinterceptor-interface","title":"The IChatInterceptor Interface","text":"<p>The <code>IChatInterceptor</code> interface defines two key methods for message interception:</p> <pre><code>public interface IChatInterceptor\n{\n    Task&lt;MessageThread&gt; InterceptIncomingMessageAsync(MessageThread messageThread);\n    Task&lt;string&gt; InterceptOutgoingMessageAsync(MessageThread messageThread, string? response);\n}\n</code></pre>"},{"location":"5-inference/7-chat-interceptors/#interceptincomingmessageasync","title":"InterceptIncomingMessageAsync","text":"<p>This method is called before the message thread is processed by the LLM.</p> <p>Parameters:</p> <ul> <li><code>messageThread</code>: The incoming message thread containing the user's message and conversation history</li> </ul> <p>Returns:</p> <ul> <li><code>MessageThread</code>: The (potentially modified) message thread to be processed by the LLM</li> </ul> <p>Use Cases:</p> <ul> <li>Validate or sanitize incoming messages</li> <li>Add context or metadata to messages</li> <li>Filter out inappropriate content</li> <li>Transform message format</li> <li>Block messages by returning an empty or modified thread</li> </ul>"},{"location":"5-inference/7-chat-interceptors/#interceptoutgoingmessageasync","title":"InterceptOutgoingMessageAsync","text":"<p>This method is called after the LLM generates a response but before it's sent to the user.</p> <p>Parameters:</p> <ul> <li><code>messageThread</code>: The complete message thread including the conversation history</li> <li><code>response</code>: The LLM-generated response (can be null)</li> </ul> <p>Returns:</p> <ul> <li><code>string</code>: The (potentially modified) response to be sent to the user</li> </ul> <p>Use Cases:</p> <ul> <li>Post-process LLM responses</li> <li>Add formatting or additional information</li> <li>Filter or censor response content</li> <li>Log interactions</li> <li>Transform response format</li> <li>Block responses by returning empty string</li> </ul>"},{"location":"5-inference/7-chat-interceptors/#implementation-example","title":"Implementation Example","text":"<p>Here's a basic implementation of a chat interceptor:</p> <pre><code>using XiansAi.Flow;\nusing XiansAi.Messaging;\n\nnamespace Agents.LegalContract;\n\npublic class ChatInterceptor : IChatInterceptor\n{\n    public Task&lt;MessageThread&gt; InterceptIncomingMessageAsync(MessageThread messageThread)\n    {\n        // Example: Log incoming messages\n        Console.WriteLine($\"Incoming message: {messageThread.LastMessage?.Content}\");\n\n        // Example: Add timestamp to message\n        if (messageThread.LastMessage != null)\n        {\n            messageThread.LastMessage.Content = $\"[{DateTime.Now:HH:mm:ss}] {messageThread.LastMessage.Content}\";\n        }\n\n        return Task.FromResult(messageThread);\n    }\n\n    public Task&lt;string&gt; InterceptOutgoingMessageAsync(MessageThread messageThread, string? response)\n    {\n        response = response ?? string.Empty;\n\n        // Example: Add signature to responses\n        if (!string.IsNullOrEmpty(response))\n        {\n            response += \"\\n\\n---\\n*Response generated by Legal Contract Agent*\";\n        }\n\n        // Example: Log outgoing responses\n        Console.WriteLine($\"Outgoing response: {response}\");\n\n        return Task.FromResult(response);\n    }\n}\n</code></pre>"},{"location":"5-inference/7-chat-interceptors/#setting-up-chat-interceptors","title":"Setting Up Chat Interceptors","text":"<p>To register a chat interceptor with your bot, use the <code>SetChatInterceptor</code> method during bot configuration:</p> <pre><code>using DotNetEnv;\nusing XiansAi.Flow;\nusing Agents.LegalContract;\n\n// Load environment variables\nEnv.Load();\nConsole.WriteLine(\"Starting Legal Contract Agent...\\n\");\n\nvar agent = new AgentTeam(\"Legal Contract Agent\");\n\nvar bot = agent.AddAgent&lt;LegalContractBot&gt;();\nbot.AddCapabilities(typeof(GeneralCapabilities));\n\n// Set the chat interceptor\nbot.SetChatInterceptor(new ChatInterceptor());\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"5-inference/7-chat-interceptors/#advanced-use-case-llm-powered-response-analysis","title":"Advanced Use Case: LLM-Powered Response Analysis","text":"<p>Here's a sophisticated real-world example that demonstrates combining LLM analysis with UI automation in the outgoing interceptor:</p> <pre><code>using XiansAi.Flow;\nusing XiansAi.Flow.Router;\nusing XiansAi.Logging;\nusing XiansAi.Messaging;\n\npublic class ChatInterceptor : IChatInterceptor\n{\n    private readonly Logger&lt;ChatInterceptor&gt; _logger = Logger&lt;ChatInterceptor&gt;.For();\n\n    public Task&lt;MessageThread&gt; InterceptIncomingMessageAsync(MessageThread messageThread)\n    {\n        // Pre-processing: Pass through without modification in this example\n        return Task.FromResult(messageThread);\n    }\n\n    public Task&lt;string?&gt; InterceptOutgoingMessageAsync(MessageThread messageThread, string? response)\n    {\n        // Post-processing: Analyze response and trigger UI actions\n        // Fire-and-forget for better performance\n        _ = AnalyzeResponseAndTriggerUI(messageThread, response);\n        return Task.FromResult(response);\n    }\n\n    private async Task AnalyzeResponseAndTriggerUI(MessageThread messageThread, string? response)\n    {\n        string analysisPrompt = @\"Analyze the following assistant message and determine ONLY if it contains \n            an explicit, direct request to the user to enter, set, or change exactly one of these contract properties:\n            - Title\n            - Effective Date  \n            - Parties\n\n            Consider it a direct request only when the message asks a question or gives a clear instruction \n            that expects immediate user input.\n\n            Return exactly the property name if there is a direct request. Otherwise, return null. \n            Do not return any additional text.\n\n            Message: \" + response;\n\n        try\n        {\n            // Use LLM to analyze the assistant's response\n            var propertyName = await SemanticRouterHub.ChatCompletionAsync(analysisPrompt);\n            _logger.LogInformation($\"Detected property request: {propertyName}\");\n\n            // Trigger appropriate UI commands based on analysis\n            switch (propertyName?.Trim())\n            {\n                case \"Effective Date\":\n                    await messageThread.SendData(\n                        new UICommand(\n                            \"Calendar\",\n                            new Dictionary&lt;string, object&gt; { { \"field\", propertyName } }\n                        )\n                    );\n                    break;\n                case \"Parties\":\n                    await messageThread.SendData(\n                        new UICommand(\n                            \"ContractParty\", \n                            new Dictionary&lt;string, object&gt; { { \"command\", \"Add\" } }\n                        )\n                    );\n                    break;\n            }\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error in response analysis\");\n        }\n    }\n}\n</code></pre>"},{"location":"5-inference/7-chat-interceptors/#key-features-of-this-approach","title":"Key Features of This Approach","text":"<p>Post-Processing Intelligence:</p> <ul> <li>Uses <code>ChatCompletionAsync</code> to analyze the LLM's response with another LLM call</li> <li>Classifies the response to determine if specific UI actions should be triggered</li> <li>Operates asynchronously without blocking the main response flow</li> </ul> <p>UI Command Integration:</p> <ul> <li>Automatically triggers relevant UI components (Calendar, ContractParty forms)</li> <li>Enhances user experience by presenting contextual interfaces</li> <li>Bridges the gap between conversational AI and structured data entry</li> </ul> <p>Performance Optimization:</p> <ul> <li>Uses fire-and-forget pattern (<code>_ = AnalyzeResponseAndTriggerUI(...)</code>) for non-blocking execution</li> <li>Keeps the main response flow fast while performing background analysis</li> <li>Implements proper error handling to prevent UI command failures from affecting chat</li> </ul> <p>Practical Benefits:</p> <ul> <li>Provides intelligent UI automation based on conversation context</li> <li>Reduces user friction by anticipating needed actions</li> <li>Maintains clean separation between chat logic and UI commands</li> </ul>"},{"location":"5-inference/7-chat-interceptors/#important-notes","title":"Important Notes","text":"<ul> <li>Chat Message Type Only: Chat interceptors only work with Chat message types and will not be triggered for other message types</li> <li>Order of Execution: Incoming interceptor runs before LLM processing, outgoing interceptor runs after LLM processing</li> <li>Thread Safety: Ensure your interceptor implementation is thread-safe if handling concurrent requests</li> <li>Error Handling: Implement proper error handling to prevent interceptor failures from breaking the chat flow</li> <li>Performance: Keep interceptor logic lightweight to avoid introducing latency in message processing</li> </ul> <p>Chat interceptors provide a flexible way to customize your bot's message handling behavior while maintaining clean separation of concerns in your agent architecture.</p>"},{"location":"5-inference/configure-llm-provider/","title":"Configure LLM Provider","text":"<p>This guide explains how to configure Azure OpenAI as your LLM provider for XiansAi agents and workflows.</p>"},{"location":"5-inference/configure-llm-provider/#overview","title":"Overview","text":"<p>Azure OpenAI integration in XiansAi provides seamless access to OpenAI models through Azure's managed service. Configuration can be done through:</p> <ul> <li>Agent-level configuration: Set RouterOptions directly in your agent code</li> <li>Server-level configuration: Use environment variables in XiansAi.Server</li> </ul> <p>Choose the method that best fits your deployment strategy and security requirements.</p>"},{"location":"5-inference/configure-llm-provider/#method-1-agent-level-configuration","title":"Method 1: Agent-Level Configuration","text":"<p>Configure Azure OpenAI directly in your agent code using RouterOptions. This approach provides fine-grained control over the LLM configuration for specific agents.</p>"},{"location":"5-inference/configure-llm-provider/#configuration","title":"Configuration","text":"<p>Set the <code>RouterOptions</code> property in your agent's <code>AgentContext</code>:</p> <pre><code>AgentContext.RouterOptions = new RouterOptions\n{\n    ProviderName = \"azureopenai\",\n    ApiKey = \"your-azure-openai-api-key\",\n    ModelName = \"gpt-4\",\n    DeploymentName = \"your-deployment-name\",\n    Endpoint = \"https://your-resource.openai.azure.com/\"\n};\n</code></pre>"},{"location":"5-inference/configure-llm-provider/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"5-inference/configure-llm-provider/#providername","title":"ProviderName","text":"<ul> <li>Type: <code>string</code></li> <li>Required: Yes</li> <li>Value: Must be <code>\"azureopenai\"</code></li> <li>Description: Identifies Azure OpenAI as the LLM provider</li> </ul>"},{"location":"5-inference/configure-llm-provider/#apikey","title":"ApiKey","text":"<ul> <li>Type: <code>string</code></li> <li>Required: Yes</li> <li>Description: Your Azure OpenAI API key. Use secure storage mechanisms like Azure Key Vault or environment variables.</li> </ul>"},{"location":"5-inference/configure-llm-provider/#modelname","title":"ModelName","text":"<ul> <li>Type: <code>string</code></li> <li>Required: Yes</li> <li>Description: The OpenAI model to use (e.g., <code>\"gpt-4\"</code>, <code>\"gpt-35-turbo\"</code>)</li> </ul>"},{"location":"5-inference/configure-llm-provider/#deploymentname","title":"DeploymentName","text":"<ul> <li>Type: <code>string</code></li> <li>Required: Yes</li> <li>Description: The name of your Azure OpenAI deployment</li> </ul>"},{"location":"5-inference/configure-llm-provider/#endpoint","title":"Endpoint","text":"<ul> <li>Type: <code>string</code></li> <li>Required: Yes</li> <li>Format: <code>https://your-resource.openai.azure.com/</code></li> <li>Description: Your Azure OpenAI resource endpoint URL</li> </ul>"},{"location":"5-inference/configure-llm-provider/#example-implementation","title":"Example Implementation","text":"<pre><code>using XiansAi.Flow;\nusing XiansAi.Common;\n\n[Workflow(\"My Workflow\")]\npublic class MyWorkflow : FlowBase\n{\n    public MyWorkflow()\n    {\n        // Configure Azure OpenAI for this agent\n        AgentContext.RouterOptions = new RouterOptions\n        {\n            ProviderName = \"azureopenai\",\n            ApiKey = Environment.GetEnvironmentVariable(\"AZURE_OPENAI_API_KEY\"),\n            ModelName = \"gpt-4\",\n            DeploymentName = \"gpt-4-deployment\",\n            Endpoint = \"https://your-resource.openai.azure.com/\"\n        };\n    }\n\n    [WorkflowRun]\n    public async Task&lt;string&gt; Run(string input)\n    {\n        // Your workflow logic here\n        return \"Completed\";\n    }\n}\n</code></pre>"},{"location":"5-inference/configure-llm-provider/#method-2-server-level-configuration","title":"Method 2: Server-Level Configuration","text":"<p>Configure Azure OpenAI at the XiansAi.Server level using environment variables. This approach centralizes LLM configuration and applies it globally to all agents.</p>"},{"location":"5-inference/configure-llm-provider/#environment-variables","title":"Environment Variables","text":"<p>Set the following environment variables in your <code>XiansAi.Server</code> configuration:</p> <pre><code># LLM Provider Configuration\nLLM_PROVIDER=azureopenai\nLLM_API_KEY=your-azure-openai-api-key\nLLM_ENDPOINT=https://your-resource.openai.azure.com/\nLLM_DEPLOYMENT_NAME=your-deployment-name\nLLM_MODEL_NAME=gpt-4\n</code></pre>"},{"location":"5-inference/configure-llm-provider/#env-file-configuration","title":".env File Configuration","text":"<p>For local development, you can configure these settings in a <code>.env</code> file within your <code>XiansAi.Server</code> project:</p> <pre><code># Azure OpenAI Configuration\nLLM_PROVIDER=azureopenai\nLLM_API_KEY=your-azure-openai-api-key\nLLM_ENDPOINT=https://your-resource.openai.azure.com/\nLLM_DEPLOYMENT_NAME=your-deployment-name\nLLM_MODEL_NAME=gpt-4\n</code></pre>"},{"location":"5-inference/configure-llm-provider/#environment-variable-details","title":"Environment Variable Details","text":""},{"location":"5-inference/configure-llm-provider/#llm_provider","title":"LLM_PROVIDER","text":"<ul> <li>Required: Yes</li> <li>Value: <code>\"azureopenai\"</code></li> <li>Description: Specifies Azure OpenAI as the LLM provider</li> </ul>"},{"location":"5-inference/configure-llm-provider/#llm_api_key","title":"LLM_API_KEY","text":"<ul> <li>Required: Yes</li> <li>Description: Your Azure OpenAI API key</li> </ul>"},{"location":"5-inference/configure-llm-provider/#llm_endpoint","title":"LLM_ENDPOINT","text":"<ul> <li>Required: Yes</li> <li>Format: <code>https://your-resource.openai.azure.com/</code></li> <li>Description: Your Azure OpenAI resource endpoint URL</li> </ul>"},{"location":"5-inference/configure-llm-provider/#llm_deployment_name","title":"LLM_DEPLOYMENT_NAME","text":"<ul> <li>Required: Yes</li> <li>Description: The name of your Azure OpenAI deployment</li> </ul>"},{"location":"5-inference/configure-llm-provider/#llm_model_name","title":"LLM_MODEL_NAME","text":"<ul> <li>Required: Yes</li> <li>Description: The OpenAI model to use (e.g., <code>\"gpt-4\"</code>, <code>\"gpt-35-turbo\"</code>)</li> </ul>"},{"location":"5-inference/configure-llm-provider/#applying-configuration","title":"Applying Configuration","text":"<ol> <li>For Development: Update your <code>.env</code> file in the <code>XiansAi.Server</code> project</li> <li>For Production: Set environment variables through your hosting platform's configuration</li> </ol> <pre><code># Example for Docker\ndocker run -e LLM_PROVIDER=azureopenai \\\n           -e LLM_API_KEY=your-key \\\n           -e LLM_ENDPOINT=https://your-resource.openai.azure.com/ \\\n           -e LLM_DEPLOYMENT_NAME=your-deployment \\\n           -e LLM_MODEL_NAME=gpt-4 \\\n           xiansai-server\n\n# Example for Azure Container Apps\naz containerapp create \\\n  --env LLM_PROVIDER=azureopenai \\\n  --env LLM_API_KEY=your-key \\\n  --env LLM_ENDPOINT=https://your-resource.openai.azure.com/ \\\n  --env LLM_DEPLOYMENT_NAME=your-deployment \\\n  --env LLM_MODEL_NAME=gpt-4 \\\n  ...\n</code></pre>"},{"location":"5-inference/configure-llm-provider/#configuration-priority","title":"Configuration Priority","text":"<p>When both methods are configured:</p> <ul> <li>Agent-level configuration takes precedence over server-level configuration</li> <li>If RouterOptions is set in agent code, it overrides the environment variables for that specific agent</li> <li>This allows for per-agent customization while providing sensible defaults at the server level</li> </ul>"},{"location":"5-inference/configure-llm-provider/#getting-azure-openai-credentials","title":"Getting Azure OpenAI Credentials","text":"<p>To obtain the necessary credentials:</p> <ol> <li>Create an Azure OpenAI resource in the Azure Portal</li> <li>Create a deployment for your desired model (e.g., GPT-4)</li> <li>Note your endpoint: Found in the Azure OpenAI resource overview</li> <li>Get your API key: Available in the \"Keys and Endpoint\" section</li> </ol>"},{"location":"5-inference/configure-llm-provider/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about retry policies for LLM operations</li> <li>Explore LLM completion options</li> <li>Review deployment options for production</li> </ul>"},{"location":"5-inference/limiting-chat-router-tokens/","title":"Limiting Router Tokens","text":""},{"location":"5-inference/limiting-chat-router-tokens/#overview","title":"Overview","text":"<p>The XiansAi router automatically manages chat history token limits to prevent <code>context_length_exceeded</code> errors. This is especially important when using functions that return large content (like web scraping) or when having long conversations.</p>"},{"location":"5-inference/limiting-chat-router-tokens/#configuration","title":"Configuration","text":"<p>Configure token limits in your Flow's constructor by setting <code>RouterOptions</code> properties:</p> <pre><code>[Workflow(\"My Bot\")]\npublic class MyBot : FlowBase\n{\n    public MyBot()\n    {\n        SystemPrompt = \"You are a helpful assistant.\";\n\n        // Configure token limits\n        RouterOptions.TokenLimit = 80000;                    // Trigger reduction at 80k tokens\n        RouterOptions.TargetTokenCount = 50000;              // Reduce to 50k tokens\n        RouterOptions.MaxTokensPerFunctionResult = 10000;    // Limit large function results\n    }\n}\n</code></pre>"},{"location":"5-inference/limiting-chat-router-tokens/#token-limit-properties","title":"Token Limit Properties","text":"Property Default Description <code>TokenLimit</code> 80,000 Maximum tokens before chat history reduction triggers. Set to 0 to disable. <code>TargetTokenCount</code> 50,000 Target token count after reduction. Should be significantly lower than TokenLimit. <code>MaxTokensPerFunctionResult</code> 10,000 Maximum tokens allowed for a single function result (e.g., web scraping)."},{"location":"5-inference/limiting-chat-router-tokens/#model-specific-recommendations","title":"Model-Specific Recommendations","text":""},{"location":"5-inference/limiting-chat-router-tokens/#gpt-4-128k-context","title":"GPT-4 (128k context)","text":"<pre><code>RouterOptions.TokenLimit = 100000;           // Conservative limit\nRouterOptions.TargetTokenCount = 60000;      // Leave room for responses\nRouterOptions.MaxTokensPerFunctionResult = 15000;\n</code></pre>"},{"location":"5-inference/limiting-chat-router-tokens/#gpt-35-turbo-16k-context","title":"GPT-3.5 Turbo (16k context)","text":"<pre><code>RouterOptions.TokenLimit = 12000;            // Stay well below limit\nRouterOptions.TargetTokenCount = 8000;       // Conservative target\nRouterOptions.MaxTokensPerFunctionResult = 4000;\n</code></pre>"},{"location":"5-inference/limiting-chat-router-tokens/#gpt-35-turbo-4k-context","title":"GPT-3.5 Turbo (4k context)","text":"<pre><code>RouterOptions.TokenLimit = 3000;             // Very conservative\nRouterOptions.TargetTokenCount = 2000;       // Leave room for system prompt\nRouterOptions.MaxTokensPerFunctionResult = 1000;\n</code></pre>"},{"location":"5-inference/limiting-chat-router-tokens/#how-it-works","title":"How It Works","text":"<p>The router uses a two-stage reduction strategy:</p> <ol> <li>Function Result Truncation: Large function results (like web scraping) are truncated first</li> <li>Message History Reduction: If still over limit, older messages are removed while preserving:</li> <li>System messages</li> <li>Recent conversation context</li> <li>Function call/result pairs</li> </ol>"},{"location":"5-inference/limiting-chat-router-tokens/#common-scenarios","title":"Common Scenarios","text":""},{"location":"5-inference/limiting-chat-router-tokens/#web-scraping-bots","title":"Web Scraping Bots","text":"<p>When using capabilities that scrape web content:</p> <pre><code>public MyWebBot()\n{\n    RouterOptions.TokenLimit = 80000;\n    RouterOptions.MaxTokensPerFunctionResult = 8000;  // Limit scraped content\n}\n</code></pre>"},{"location":"5-inference/limiting-chat-router-tokens/#long-conversation-bots","title":"Long Conversation Bots","text":"<p>For bots with extensive chat history:</p> <pre><code>public MyChatBot()\n{\n    RouterOptions.TokenLimit = 60000;\n    RouterOptions.TargetTokenCount = 30000;           // Aggressive reduction\n    RouterOptions.HistorySizeToFetch = 100;           // Fetch more history\n}\n</code></pre>"},{"location":"5-inference/limiting-chat-router-tokens/#high-precision-bots","title":"High-Precision Bots","text":"<p>For bots requiring maximum context:</p> <pre><code>public MyAnalysisBot()\n{\n    RouterOptions.TokenLimit = 110000;               // Use more context\n    RouterOptions.TargetTokenCount = 80000;          // Less aggressive reduction\n}\n</code></pre>"},{"location":"5-inference/limiting-chat-router-tokens/#troubleshooting","title":"Troubleshooting","text":""},{"location":"5-inference/limiting-chat-router-tokens/#still-getting-token-limit-errors","title":"Still Getting Token Limit Errors?","text":"<ol> <li>Lower TokenLimit: Try reducing by 20,000 tokens</li> <li>Reduce Function Results: Lower <code>MaxTokensPerFunctionResult</code></li> <li>Check System Prompt: Very long system prompts consume tokens</li> <li>Monitor Logs: Look for reduction warnings in application logs</li> </ol>"},{"location":"5-inference/limiting-chat-router-tokens/#performance-issues","title":"Performance Issues?","text":"<ol> <li>Increase TargetTokenCount: Reduce frequency of reductions</li> <li>Optimize Functions: Return smaller, more focused results</li> <li>Disable if Not Needed: Set <code>TokenLimit = 0</code> for simple bots</li> </ol>"},{"location":"5-inference/limiting-chat-router-tokens/#example-complete-configuration","title":"Example: Complete Configuration","text":"<pre><code>[Workflow(\"Percy: Web Reporter\")]\npublic class WebReporterBot : FlowBase\n{\n    public WebReporterBot()\n    {\n        SystemPrompt = \"You are a web content reporter with scraping capabilities.\";\n\n        // Token management for web scraping\n        RouterOptions.TokenLimit = 85000;                    // Conservative for GPT-4\n        RouterOptions.TargetTokenCount = 55000;              // Leave room for analysis\n        RouterOptions.MaxTokensPerFunctionResult = 12000;    // Allow larger scraped content\n        RouterOptions.HistorySizeToFetch = 20;               // Moderate history\n\n        // Other settings\n        RouterOptions.MaxTokens = 4096;                      // Response limit\n        RouterOptions.Temperature = 0.3;                     // Focused responses\n    }\n}\n</code></pre>"},{"location":"5-inference/limiting-chat-router-tokens/#notes","title":"Notes","text":"<ul> <li>Token estimation uses ~4 characters per token heuristic</li> <li>System messages are always preserved during reduction</li> <li>Function call/result pairs are kept together when possible</li> <li>Reduction triggers before sending to the AI model, preventing errors</li> <li>All reductions are logged for debugging purposes</li> </ul>"},{"location":"5-inference/llm-completion/","title":"Chat Completion","text":"<p>The Xians platform provides a simple chat completion capability through the <code>SemanticRouterHub.ChatCompletionAsync</code> static method. This functionality allows you to send a direct prompt to an LLM and receive a response with optional system instructions, without the complexity of chat history or function calling.</p>"},{"location":"5-inference/llm-completion/#overview","title":"Overview","text":"<p>The <code>ChatCompletionAsync</code> method leverages Microsoft's SemanticKernel framework to provide straightforward LLM interactions. It supports optional system instructions to guide the AI's behavior, but unlike the full routing capabilities, it doesn't include chat history or function calling support, focusing on simple prompt-to-response interactions.</p>"},{"location":"5-inference/llm-completion/#usage","title":"Usage","text":"<pre><code>var response = await SemanticRouterHub.ChatCompletionAsync(prompt, systemInstruction, routerOptions);\n</code></pre>"},{"location":"5-inference/llm-completion/#parameters","title":"Parameters","text":"<ul> <li>prompt (string): The direct prompt to send to the LLM</li> <li>systemInstruction (string, optional): System instruction to guide the AI's behavior. Defaults to empty string</li> <li>routerOptions (RouterOptions, optional): Configuration options for the completion</li> </ul>"},{"location":"5-inference/llm-completion/#configuration-options","title":"Configuration Options","text":"<p>The <code>RouterOptions</code> class allows you to configure the LLM behavior:</p> <pre><code>var routerOptions = new RouterOptions\n{\n    ProviderName = \"openai\",           // or \"azureopenai\"\n    ModelName = \"gpt-4\",\n    ApiKey = \"your-api-key\",\n    Temperature = 0.3,                 // Controls randomness (default: 0.3)\n    MaxTokens = 1000,                  // Maximum response length (default: 10000)\n    HTTPTimeoutSeconds = 300,          // HTTP timeout (default: 5 minutes)\n    HistorySizeToFetch = 10,           // History size to fetch (default: 10)\n    WelcomeMessage = \"Hello!\",         // Welcome message for empty prompts\n\n    // Token limiting features (prevents context_length_exceeded errors)\n    TokenLimit = 80000,                // Trigger reduction at 80k tokens (default: 80000)\n    TargetTokenCount = 50000,          // Reduce to 50k tokens (default: 50000)\n    MaxTokensPerFunctionResult = 10000 // Limit large function results (default: 10000)\n};\n</code></pre>"},{"location":"5-inference/llm-completion/#available-options","title":"Available Options","text":"Property Description Default <code>ProviderName</code> LLM provider (\"openai\", \"azureopenai\") From environment/settings <code>ModelName</code> Model to use (e.g., \"gpt-4\", \"gpt-3.5-turbo\") From environment/settings <code>DeploymentName</code> Azure OpenAI deployment name From environment/settings <code>Endpoint</code> Custom endpoint URL From environment/settings <code>ApiKey</code> API key for the provider From environment/settings <code>Temperature</code> Randomness control (0.0-1.0) 0.3 <code>MaxTokens</code> Maximum tokens in response 10000 <code>HTTPTimeoutSeconds</code> HTTP timeout in seconds 300 (5 minutes) <code>HistorySizeToFetch</code> Number of history messages to fetch 10 <code>WelcomeMessage</code> Message sent for null/empty prompts null <code>TokenLimit</code> Max tokens before history reduction 80000 <code>TargetTokenCount</code> Target tokens after reduction 50000 <code>MaxTokensPerFunctionResult</code> Max tokens per function result 10000"},{"location":"5-inference/llm-completion/#example-usage","title":"Example Usage","text":"<p>Here's a practical example from a chat interceptor that analyzes assistant messages:</p> <pre><code>// Basic usage\nstring prompt = @\"Analyze the following assistant message and determine if it contains \n    a direct request for contract information: \" + userMessage;\n\nvar analysis = await SemanticRouterHub.ChatCompletionAsync(prompt);\n\n// With system instruction\nstring systemInstruction = \"You are a helpful assistant that analyzes messages accurately.\";\nvar detailedAnalysis = await SemanticRouterHub.ChatCompletionAsync(prompt, systemInstruction);\n\n// With full options\nvar routerOptions = new RouterOptions { Temperature = 0.1, MaxTokens = 500 };\nvar preciseAnalysis = await SemanticRouterHub.ChatCompletionAsync(prompt, systemInstruction, routerOptions);\n</code></pre>"},{"location":"5-inference/llm-completion/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Optional System Instructions: Supports system instructions to guide AI behavior (defaults to empty string, but underlying implementation uses \"You are a helpful assistant. Perform the user's request accurately and concisely.\" when null/empty)</li> <li>No Chat History: Each call is independent with no conversation context</li> <li>No Function Calling: Functions/tools are disabled for simple text responses</li> <li>SemanticKernel Based: Uses Microsoft SemanticKernel framework internally</li> <li>Provider Agnostic: Supports OpenAI and Azure OpenAI providers</li> <li>Token Management: Built-in token limiting to prevent context length errors</li> <li>Configurable Timeouts: Adjustable HTTP timeouts for different use cases</li> </ul>"},{"location":"5-inference/llm-completion/#when-to-use","title":"When to Use","text":"<p>Use <code>ChatCompletionAsync</code> when you need:</p> <ul> <li>Simple prompt-to-response interactions</li> <li>Text analysis or generation tasks</li> <li>Independent LLM calls without conversation context</li> <li>Quick LLM evaluations or classifications</li> <li>System-guided responses without conversation history</li> </ul> <p>For more complex scenarios involving system prompts, chat history, or function calling, use the full routing capabilities instead.</p>"},{"location":"5-inference/mcp-integration/","title":"MCP Integration","text":"<p>Model Context Protocol (MCP) servers can be seamlessly integrated into Agent workflows by implementing the <code>IKernelModifier</code> interface. This allows agents to leverage external tools and services through standardized MCP connections while maintaining the flexibility of the Semantic Kernel framework.</p>"},{"location":"5-inference/mcp-integration/#overview","title":"Overview","text":"<p>MCP integration in XiansAi agents works by:</p> <ol> <li>Kernel Modification: Implementing <code>IKernelModifier</code> to extend the agent's Semantic Kernel</li> <li>Tool Registration: Converting MCP tools to Kernel functions and registering them as plugins</li> <li>Client Management: Establishing and managing MCP client connections</li> <li>Runtime Integration: Making MCP tools available to the LLM during conversation flow</li> </ol>"},{"location":"5-inference/mcp-integration/#implementation-pattern","title":"Implementation Pattern","text":""},{"location":"5-inference/mcp-integration/#1-create-an-mcp-kernel-modifier","title":"1. Create an MCP Kernel Modifier","text":"<p>Implement the <code>IKernelModifier</code> interface to integrate your MCP server:</p> <pre><code>public class PlayWriteMCP : IKernelModifier\n{\n    private static List&lt;KernelFunction&gt;? functions;\n\n\n#pragma warning disable SKEXP0001\n    public async Task&lt;Kernel&gt; ModifyKernelAsync(Kernel kernel)\n    {\n        if (functions == null)\n        {\n            var client = await GetMCPClientForPlaywright();\n            var tools = await client.ListToolsAsync();\n            functions = tools.Select(f =&gt; f.AsKernelFunction()).ToList();\n        }\n        Console.WriteLine($\"Adding Playwright Functions: {functions.Count}\");\n\n        kernel.Plugins.AddFromFunctions(\"Playwright\", functions);\n\n        return kernel;\n    }\n#pragma warning restore SKEXP0001\n\n    public static async Task&lt;IMcpClient&gt; GetMCPClientForPlaywright()\n    {\n        var clientTransport = new StdioClientTransport(new StdioClientTransportOptions\n        {\n            Name = \"Playwright\",\n            Command = \"npx\",\n            Arguments = new List&lt;string&gt;() {\n                \"-y\",\n                \"@playwright/mcp@latest\",\n                \"--isolated\",\n                \"--headless\"\n            }\n        });\n\n        var client = await McpClientFactory.CreateAsync(clientTransport);\n        return client;\n    }\n}\n</code></pre>"},{"location":"5-inference/mcp-integration/#2-register-the-kernel-modifier-with-your-agent","title":"2. Register the Kernel Modifier with Your Agent","text":"<p>In your <code>Program.cs</code>, add the kernel modifier to your bot:</p> <pre><code>using XiansAi.Flow;\nusing DotNetEnv;\n\n// Load environment variables\nEnv.Load();\n\n// Create your agent\nvar agent = new AgentTeam(\"A2A Agent Team\");\n\n// Create and configure your bot\nvar webBot = agent.AddAgent&lt;WebBot&gt;();\nwebBot.AddKernelModifier(new PlayWriteMCP());\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"5-inference/mcp-integration/#3-use-mcp-tools-in-your-workflow","title":"3. Use MCP Tools in Your Workflow","text":"<p>The MCP tools become available to your agent's LLM automatically:</p> <pre><code>[Workflow(\"A2A Agent Team: Web Bot\")]\npublic class WebBot : FlowBase\n{\n    public WebBot(){\n        SystemPrompt = \"You are a web bot. You can get the information from the web.\";\n    }\n\n    [WorkflowRun]\n    public async Task Run()\n    {\n        await InitConversation();\n    }\n}\n</code></pre>"},{"location":"5-inference/mcp-integration/#key-components","title":"Key Components","text":""},{"location":"5-inference/mcp-integration/#ikernelmodifier-interface","title":"IKernelModifier Interface","text":"<p>The <code>IKernelModifier</code> interface requires implementation of:</p> <pre><code>Task&lt;Kernel&gt; ModifyKernelAsync(Kernel kernel)\n</code></pre> <p>This method receives the agent's Semantic Kernel and returns a modified version with additional capabilities.</p>"},{"location":"5-inference/mcp-integration/#mcp-client-setup","title":"MCP Client Setup","text":"<ul> <li>Transport: Use <code>StdioClientTransport</code> for process-based MCP servers</li> <li>Configuration: Pass command and arguments to start the MCP server</li> <li>Client Factory: Use <code>McpClientFactory.CreateAsync()</code> to establish connection</li> </ul>"},{"location":"5-inference/mcp-integration/#tool-registration","title":"Tool Registration","text":"<ul> <li>List Tools: Call <code>client.ListToolsAsync()</code> to get available MCP tools</li> <li>Convert Functions: Use <code>.AsKernelFunction()</code> to convert MCP tools to Kernel functions</li> <li>Add Plugin: Register functions as a named plugin using <code>kernel.Plugins.AddFromFunctions()</code></li> </ul>"},{"location":"5-inference/mcp-integration/#benefits","title":"Benefits","text":"<ul> <li>Standardized Integration: Leverage existing MCP servers without custom adapters</li> <li>Automatic Tool Discovery: MCP tools are automatically discovered and made available</li> <li>Kernel Extension: Seamlessly extends the agent's capabilities through the Semantic Kernel</li> <li>Runtime Flexibility: Tools are available during LLM processing for dynamic usage</li> </ul>"},{"location":"5-inference/mcp-integration/#best-practices","title":"Best Practices","text":"<ol> <li>Static Function Caching: Cache MCP functions statically to avoid repeated client initialization</li> <li>Error Handling: Implement proper error handling for MCP client connections</li> <li>Configuration Options: Allow configuration of MCP server parameters (like headless mode)</li> <li>Resource Management: Properly manage MCP client lifecycle and connections</li> <li>Plugin Naming: Use descriptive names for MCP plugins to aid LLM understanding</li> </ol> <p>This pattern allows agents to seamlessly integrate with any MCP-compatible server, extending their capabilities with external tools while maintaining the familiar agent workflow patterns.</p>"},{"location":"n-encyclopedia/access-agents-via-websocket/","title":"Accessing Agents Through WebSocket Connection","text":"<p>This guide demonstrates how to create a .NET console application that connects to XiansAI agents using SignalR WebSocket connections.</p>"},{"location":"n-encyclopedia/access-agents-via-websocket/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET 8.0 or later</li> <li>Microsoft.AspNetCore.SignalR.Client NuGet package</li> <li>Newtonsoft.Json NuGet package</li> <li>DotNetEnv NuGet package</li> </ul>"},{"location":"n-encyclopedia/access-agents-via-websocket/#project-setup","title":"Project Setup","text":"<ol> <li> <p>Create a new .NET console application: <pre><code>dotnet new console -n AgentChatClient\ncd AgentChatClient\n</code></pre></p> </li> <li> <p>Add required NuGet packages: <pre><code>dotnet add package Microsoft.AspNetCore.SignalR.Client\ndotnet add package Newtonsoft.Json\ndotnet add package DotNetEnv\n</code></pre></p> </li> <li> <p>Create a <code>.env</code> file in your project directory: <pre><code>WEBSOCKET_URL=https://your-hub-url/ws/chat\nAPI_KEY=your-api-key\nTENANT_ID=your-tenant-id\nPARTICIPANT_ID=your-participant-id\n</code></pre>  API key can be generated from the Xians portal. Navigate to Settings &gt; API Keys tab &gt; Create API Key (only Tenant or System admins have access to generate API keys).</p> </li> </ol>"},{"location":"n-encyclopedia/access-agents-via-websocket/#agent-configuration","title":"Agent Configuration","text":"<ol> <li> <p>Create an <code>agents.json</code> file in your project directory with the following structure: <pre><code>[\n    {\n        \"id\": \"tenant:agent-name:workflow-name\",\n        \"name\": \"bot-name\",\n        \"agent\": \"agent-name\",\n        \"workflowType\": \"workflow-type\"\n    }\n]\n</code></pre></p> </li> <li> <p>Use the following model to represent agent configuration: <pre><code>public class AgentConfig\n{\n    public required string Id { get; set; }           // Unique identifier for the agent\n    public required string Name { get; set; }         // Display name of the agent\n    public required string Agent { get; set; }        // Agent identifier\n    public required string WorkflowType { get; set; } // Type of workflow the agent handles\n}\n</code></pre></p> </li> </ol>"},{"location":"n-encyclopedia/access-agents-via-websocket/#message-model-recieved-message-format-via-websocket","title":"Message Model (Recieved message format via websocket)","text":"<p>Use the following model for Coversation and to receive messages from the agent via websocket: <pre><code>public class Message\n{\n    public string Id { get; set; } = null!;\n    public required string ThreadId { get; set; }\n    public required string TenantId { get; set; }\n    public required DateTime CreatedAt { get; set; }\n    public DateTime? UpdatedAt { get; set; }\n    public required string CreatedBy { get; set; }\n    public required string Direction { get; set; } // Incoming or Outgoing\n    public string? Text { get; set; }\n    public string? Status { get; set; } // FailedToDeliverToWorkflow or DeliveredToWorkflow\n    public object? Data { get; set; }\n    public required string ParticipantId { get; set; }\n    public required string WorkflowId { get; set; }\n    public required string WorkflowType { get; set; }\n    public string? MessageType { get; set; } // Chat, Data, or Handoff\n}\n</code></pre></p>"},{"location":"n-encyclopedia/access-agents-via-websocket/#send-message-request-model","title":"Send Message Request Model","text":"<p>Use to send messages to the agent via websocket: <pre><code>public class SendMessageRequest\n{\n    public required string ParticipantId { get; set; }\n    public string? WorkflowId { get; set; }\n    public required string WorkflowType { get; set; }\n    public required string Agent { get; set; }\n    public object? Data { get; set; }\n    public string? Text { get; set; }\n    public string? ThreadId { get; set; }\n    public string? Authorization { get; set; }\n}\n</code></pre></p>"},{"location":"n-encyclopedia/access-agents-via-websocket/#setup-websocket-connection","title":"Setup Websocket Connection","text":"<p>Before subscribing to agents, you need to establish a Websocket connection. Here's how to set up and start the connection:</p> <pre><code>private static async Task SetupWebsocketConnection()\n{\n    _connection = new HubConnectionBuilder()\n        .WithUrl($\"{_webSocketUrl}?tenantId={_tenantId}\", options =&gt;\n        {\n            options.Headers.Add(\"Authorization\", $\"Bearer {_apiKey}\");\n        })\n        .WithAutomaticReconnect()\n        .Build();\n\n    // Setup message handlers\n    _connection.On&lt;Message&gt;(\"ReceiveMessage\", HandleReceivedMessage);\n    _connection.On&lt;string&gt;(\"InboundProcessed\", HandleInboundProcessed);\n    _connection.On&lt;List&lt;Message&gt;&gt;(\"ThreadHistory\", HandleThreadHistory);\n\n    try\n    {\n        await _connection.StartAsync();\n        Console.WriteLine(\"Connected to SignalR hub\");\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine($\"Error connecting to SignalR hub: {ex.Message}\");\n        throw;\n    }\n}\n</code></pre> <p>Important notes: - The connection requires a valid WebSocket URL, API key, and tenant ID. - The connection includes automatic reconnection capability. - Message handlers should be set up before starting the connection. - Always handle connection errors appropriately. - The connection must be established before attempting to subscribe to agents.</p>"},{"location":"n-encyclopedia/access-agents-via-websocket/#subscribing-to-agents","title":"Subscribing to Agents","text":"<p>To subscribe to agents, call the <code>SubscribeToAgent</code> method through the SignalR connection:</p> <pre><code>await _connection.InvokeAsync(\"SubscribeToAgent\",\n    agent.Id,        // The agent's unique identifier (workflowId)\n    _participantId,  // Your participant ID\n    _tenantId        // Your tenant ID\n);\n</code></pre>"},{"location":"n-encyclopedia/access-agents-via-websocket/#loading-initial-chat-history","title":"Loading Initial Chat History","text":"<p>The initial chat history is loaded for each agent using:</p> <pre><code>await _connection.InvokeAsync(\"GetThreadHistory\",\n    agent.WorkflowType, // Workflow type\n    _participantId,     // Participant ID\n    1,                  // Page number\n    20                  // Page size\n);\n</code></pre>"},{"location":"n-encyclopedia/access-agents-via-websocket/#sending-and-receiving-messages","title":"Sending and Receiving Messages","text":"<ul> <li>Messages are sent using the <code>SendInboundMessage</code> method.</li> <li>The request model uses the <code>Text</code> property for message content.</li> <li>The method signature is:   <pre><code>await _connection.InvokeAsync(\"SendInboundMessage\", request, \"Chat\");\n</code></pre></li> <li>Wait for a response using a <code>TaskCompletionSource</code> with a 15-second timeout.</li> </ul> <p>Example: <pre><code>var request = new SendMessageRequest\n{\n    ThreadId = _currentThreadId,\n    Agent = selectedAgent.Agent,\n    WorkflowType = selectedAgent.WorkflowType,\n    WorkflowId = selectedAgent.Id,\n    ParticipantId = _participantId,\n    Text = input,\n    Data = null\n};\n\n_messageResponseReceived = new TaskCompletionSource&lt;bool&gt;();\nawait _connection.InvokeAsync(\"SendInboundMessage\", request, \"Chat\");\nConsole.WriteLine(\"Message sent successfully\");\n\nusing var cts = new CancellationTokenSource(TimeSpan.FromSeconds(15));\ntry\n{\n    await _messageResponseReceived.Task.WaitAsync(cts.Token);\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"No response received within 15 seconds\");\n}\n</code></pre></p> <ul> <li>To send a Data object use the below method signature;   <pre><code>await _connection.InvokeAsync(\"SendInboundMessage\", request, \"Data\");\n</code></pre> Example:</li> </ul> <pre><code>var request = new SendMessageRequest\n{\n    ThreadId = _currentThreadId,\n    Agent = selectedAgent.Agent,\n    WorkflowType = selectedAgent.WorkflowType,\n    WorkflowId = selectedAgent.Id,\n    ParticipantId = _participantId,\n    Text = null,\n    Data = new ExampleDataModel {ExampleName:\"hi\", ExampleAge:23 }\n};\n\n_messageResponseReceived = new TaskCompletionSource&lt;bool&gt;();\nawait _connection.InvokeAsync(\"SendInboundMessage\", request, \"Data\");\nConsole.WriteLine(\"Message sent successfully\");\n\nusing var cts = new CancellationTokenSource(TimeSpan.FromSeconds(15));\ntry\n{\n    await _messageResponseReceived.Task.WaitAsync(cts.Token);\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"No response received within 15 seconds\");\n}\n</code></pre>"},{"location":"n-encyclopedia/access-agents-via-websocket/#message-handlers","title":"Message Handlers","text":"<ul> <li> <p><code>ReceiveMessage</code>: Handles incoming messages. <pre><code>_connection.On&lt;Message&gt;(\"ReceiveMessage\", HandleReceivedMessage); \n</code></pre></p> </li> <li> <p><code>InboundProcessed</code>: Updates the current thread ID. <pre><code>_connection.On&lt;string&gt;(\"InboundProcessed\", HandleInboundProcessed);\n</code></pre></p> </li> <li> <p><code>ThreadHistory</code>: Loads message history for an agent. <pre><code>_connection.On&lt;List&lt;Message&gt;&gt;(\"ThreadHistory\", HandleThreadHistory);\n</code></pre></p> </li> </ul>"},{"location":"n-encyclopedia/access-agents-via-websocket/#chat-history-storage","title":"Chat History Storage","text":"<ul> <li>Messages are stored in the <code>_chatHistories</code> dictionary.</li> <li>Key: Agent's WorkflowId.</li> <li>Value: List of messages for that agent.</li> </ul> <pre><code>private static Dictionary&lt;string, List&lt;Message&gt;&gt; _chatHistories;\n</code></pre>"},{"location":"n-encyclopedia/agent-context-utility/","title":"Agent Context Utility (<code>AgentContext</code>)","text":"<p>Very short guide to access runtime context and start/execute sub-workflows.</p>"},{"location":"n-encyclopedia/agent-context-utility/#what-it-provides","title":"What it provides","text":"<ul> <li>TenantId: From certificate; required for workflow IDs.</li> <li>UserId: From certificate.</li> <li>AgentName: First segment of <code>WorkflowType</code>.</li> <li>WorkflowId / WorkflowType / WorkflowRunId: From Temporal context (workflow or activity).</li> <li><code>StartWorkflow&lt;TWorkflow&gt;(namePostfix, args)</code>: Fire-and-forget sub-workflow.</li> <li><code>ExecuteWorkflow&lt;TWorkflow, TResult&gt;(namePostfix, args)</code>: Sub-workflow returning a result.</li> </ul>"},{"location":"n-encyclopedia/agent-context-utility/#quick-usage","title":"Quick usage","text":"<pre><code>// Inside a workflow or activity\nvar tenantId = AgentContext.TenantId;     // throws if certificate missing tenant\nvar userId = AgentContext.UserId;         // throws if certificate missing user\n\nvar workflowId = AgentContext.WorkflowId;     // current workflow id\nvar workflowType = AgentContext.WorkflowType; // e.g., \"My Agent v1.3.1:Router Bot\"\nvar runId = AgentContext.WorkflowRunId;       // current run id\nvar agentName = AgentContext.AgentName;       // \"My Agent v1.3.1\"\n</code></pre>"},{"location":"n-encyclopedia/agent-context-utility/#sub-workflows","title":"Sub-workflows","text":"<pre><code>// Start a sub-workflow (no return)\nawait AgentContext.StartWorkflow&lt;MyFlow&gt;(\n    namePostfix: Guid.NewGuid().ToString(),\n    args: new object[] { /* flow args */ }\n);\n\n// Execute a sub-workflow and get result\nvar result = await AgentContext.ExecuteWorkflow&lt;MyFlow, MyResult&gt;(\n    namePostfix: Guid.NewGuid().ToString(),\n    args: new object[] { /* flow args */ }\n);\n</code></pre>"},{"location":"n-encyclopedia/agent-context-utility/#notes-and-pitfalls","title":"Notes and pitfalls","text":"<ul> <li>Context required: <code>WorkflowId</code>, <code>WorkflowType</code>, and <code>WorkflowRunId</code> throw if not in a workflow or activity.</li> <li>Certificate required: <code>TenantId</code> and <code>UserId</code> come from the loaded certificate; missing values throw.</li> <li>AgentName derivation: Computed from the <code>WorkflowType</code> (text before the first <code>:</code>).</li> </ul>"},{"location":"n-encyclopedia/agent-context/","title":"AgentContext Utility Methods","text":"<p>The <code>AgentContext</code> class provides essential utility methods and properties for managing workflow execution context, agent information, and sub-workflow operations within the Xians AI platform.</p>"},{"location":"n-encyclopedia/agent-context/#workflow-utility-methods","title":"Workflow Utility Methods","text":""},{"location":"n-encyclopedia/agent-context/#getsingletonworkflowidfortype-flowclasstype","title":"<code>GetSingletonWorkflowIdFor(Type flowClassType)</code>","text":"<p>Give the unique workflow ID for singleton workflows by combining the tenant ID and workflow type.</p> <p>Returns: <code>string</code> - Formatted as <code>{TenantId}:{WorkflowType}</code></p> <p>Usage:</p> <pre><code>var workflowId = AgentContext.GetSingletonWorkflowIdFor(typeof(MyWorkflow));\n</code></pre>"},{"location":"n-encyclopedia/agent-context/#getworkflowtypefortype-flowclasstype","title":"<code>GetWorkflowTypeFor(Type flowClassType)</code>","text":"<p>Extracts the workflow type name from a workflow class using the <code>WorkflowAttribute</code>.</p> <p>Returns: <code>string</code> - The workflow type name</p> <p>Throws: <code>InvalidOperationException</code> if WorkflowAttribute.Name is not set</p>"},{"location":"n-encyclopedia/agent-context/#startworkflowtworkflowstring-namepostfix-object-args","title":"<code>StartWorkflow&lt;TWorkflow&gt;(string namePostfix, object[] args)</code>","text":"<p>Starts a new sub-workflow asynchronously.</p> <p>Parameters:</p> <ul> <li><code>namePostfix</code>: Suffix to append to workflow name</li> <li><code>args</code>: Arguments to pass to the workflow</li> </ul> <p>Returns: <code>Task</code></p>"},{"location":"n-encyclopedia/agent-context/#executeworkflowtworkflow-tresultstring-namepostfix-object-args","title":"<code>ExecuteWorkflow&lt;TWorkflow, TResult&gt;(string namePostfix, object[] args)</code>","text":"<p>Executes a sub-workflow and waits for its result.</p> <p>Parameters:</p> <ul> <li><code>namePostfix</code>: Suffix to append to workflow name  </li> <li><code>args</code>: Arguments to pass to the workflow</li> </ul> <p>Returns: <code>Task&lt;TResult&gt;</code> - The workflow execution result</p>"},{"location":"n-encyclopedia/agent-context/#context-properties","title":"Context Properties","text":""},{"location":"n-encyclopedia/agent-context/#identity-and-security","title":"Identity and Security","text":"<ul> <li><code>TenantId</code> - Gets the current tenant identifier from certificate info</li> <li><code>UserId</code> - Gets the current user identifier from certificate info</li> <li><code>CertificateInfo</code> - Gets certificate information for authentication and authorization</li> </ul>"},{"location":"n-encyclopedia/agent-context/#agent-information","title":"Agent Information","text":"<ul> <li><code>AgentName</code> - Gets/sets the current agent name</li> <li>In workflow context: Retrieved from workflow memo</li> <li>Outside workflow: Uses static field value</li> <li>Throws exception if not properly initialized</li> </ul>"},{"location":"n-encyclopedia/agent-context/#workflow-context","title":"Workflow Context","text":"<ul> <li><code>WorkflowId</code> - Gets the current workflow identifier</li> <li>Available in workflow, activity, or when explicitly set</li> <li><code>WorkflowType</code> - Gets the current workflow type</li> <li>Available in workflow, activity, or when explicitly set  </li> <li><code>WorkflowRunId</code> - Gets the current workflow run identifier</li> <li>Available in workflow, activity, or when explicitly set</li> </ul>"},{"location":"n-encyclopedia/agent-context/#context-detection","title":"Context Detection","text":"<p>The class automatically detects the execution context:</p> <ul> <li>Workflow Context: Uses <code>Workflow.InWorkflow</code> and <code>Workflow.Info</code></li> <li>Activity Context: Uses <code>ActivityExecutionContext.HasCurrent</code> and <code>ActivityExecutionContext.Current.Info</code></li> <li>External Context: Falls back to static field values</li> </ul>"},{"location":"n-encyclopedia/agent-context/#usage-patterns","title":"Usage Patterns","text":""},{"location":"n-encyclopedia/agent-context/#within-a-workflow","title":"Within a Workflow","text":"<pre><code>// Context properties are automatically available\nvar currentAgent = AgentContext.AgentName;\nvar workflowId = AgentContext.WorkflowId;\n</code></pre>"},{"location":"n-encyclopedia/agent-context/#within-an-activity","title":"Within an Activity","text":"<pre><code>// Activity context provides workflow information\nvar workflowType = AgentContext.WorkflowType;\nvar runId = AgentContext.WorkflowRunId;\n</code></pre>"},{"location":"n-encyclopedia/agent-context/#starting-sub-workflows","title":"Starting Sub-workflows","text":"<pre><code>// Fire-and-forget sub-workflow\nawait AgentContext.StartWorkflow&lt;ProcessingWorkflow&gt;(\"_batch\", new object[] { data });\n\n// Execute and wait for result\nvar result = await AgentContext.ExecuteWorkflow&lt;CalculationWorkflow, int&gt;(\"_calc\", new object[] { input });\n</code></pre> <p>This utility class serves as the central access point for workflow context information and sub-workflow management within the Xians AI platform.</p>"},{"location":"n-encyclopedia/chat-message-encryption/","title":"Chat Message Encryption","text":"<p>All chat messages stored in the database are encrypted at rest to ensure data privacy and security. This encryption is mandatory and complies with the EU AI Act requirements for data protection in AI systems.</p>"},{"location":"n-encyclopedia/chat-message-encryption/#encryption-overview","title":"Encryption Overview","text":"<p>The system uses AES encryption to secure all conversation messages before storing them in the database. Each message is encrypted using a combination of:</p> <ul> <li>A base secret key for foundational encryption</li> <li>A unique conversation message key for additional security layers</li> </ul> <p>This dual-key approach ensures that even if one key is compromised, the data remains protected.</p>"},{"location":"n-encyclopedia/chat-message-encryption/#eu-ai-act-compliance","title":"EU AI Act Compliance","text":"<p>Under the EU AI Act, AI systems that process personal data must implement appropriate technical and organizational measures to ensure data protection. Message encryption is a critical requirement for:</p> <ul> <li>Data Minimization: Only encrypted data is stored, limiting exposure</li> <li>Security by Design: Encryption is built into the system architecture</li> <li>Data Protection: Personal conversations are protected against unauthorized access</li> <li>Transparency: Users can be assured their messages are encrypted</li> </ul>"},{"location":"n-encyclopedia/chat-message-encryption/#environment-configuration","title":"Environment Configuration","text":"<p>Important: The encryption keys must be configured in your environment before the system can encrypt and store messages. Without proper key configuration, the system cannot function securely.</p>"},{"location":"n-encyclopedia/chat-message-encryption/#required-environment-variables","title":"Required Environment Variables","text":"<p>Configure the following encryption keys in your environment:</p> <pre><code># Base encryption secret - use a long, random string (minimum 32 characters)\nEncryptionKeys__BaseSecret=&lt;LONG_RANDOM_BASE_SECRET&gt;\n\n# Conversation message encryption key - unique secret for chat messages\nEncryptionKeys__UniqueSecrets__ConversationMessageKey=&lt;UNIQUE_SECRET_FOR_MESSAGES&gt;\n</code></pre>"},{"location":"n-encyclopedia/chat-message-encryption/#key-generation-guidelines","title":"Key Generation Guidelines","text":"<ul> <li>Base Secret: Generate a cryptographically secure random string of at least 32 characters</li> <li>Message Key: Use a different random string, also minimum 32 characters</li> <li>Security: Never reuse keys across different environments (dev/staging/prod)</li> <li>Storage: Store keys securely using your organization's secret management system</li> </ul>"},{"location":"n-encyclopedia/chat-message-encryption/#example-configuration","title":"Example Configuration","text":"<pre><code># Generate secure keys (Linux/macOS)\nopenssl rand -base64 32\n\n# Example .env configuration\nEncryptionKeys__BaseSecret=YourSecureBase64EncodedSecretKeyHere123456789\nEncryptionKeys__UniqueSecrets__ConversationMessageKey=AnotherSecureRandomKeyForMessages987654321\n</code></pre>"},{"location":"n-encyclopedia/chat-message-encryption/#security-considerations","title":"Security Considerations","text":"<ul> <li>Key Rotation: Regularly rotate encryption keys according to your security policy</li> <li>Access Control: Limit access to encryption keys to authorized personnel only</li> <li>Backup: Ensure encryption keys are included in your secure backup procedures</li> <li>Monitoring: Monitor for any unauthorized access attempts to encrypted data</li> </ul>"},{"location":"n-encyclopedia/chat-message-encryption/#troubleshooting","title":"Troubleshooting","text":"<p>\"Encryption keys not configured\": Ensure both <code>BaseSecret</code> and <code>ConversationMessageKey</code> are set in your environment</p> <p>\"Unable to decrypt messages\": Verify that the same encryption keys used to encrypt the data are being used for decryption</p> <p>\"Key format invalid\": Ensure keys are properly base64 encoded and meet minimum length requirements</p>"},{"location":"n-encyclopedia/deployment-options/","title":"Agent Deployment Settings","text":""},{"location":"n-encyclopedia/deployment-options/#option-1-azure-container-apps","title":"Option 1: Azure Container Apps","text":"<ol> <li>Dockerize the agent</li> <li>Upload via ACR service (Azure Container Registry)</li> <li>Configure Container App settings</li> </ol>"},{"location":"n-encyclopedia/deployment-options/#ingress-configuration","title":"Ingress Configuration","text":"<ul> <li>Disable Ingress - Agents don't need external HTTP access</li> <li>Set <code>\"ingress\": { \"external\": false }</code> in configuration</li> </ul>"},{"location":"n-encyclopedia/deployment-options/#scaling-settings","title":"Scaling Settings","text":"<ul> <li>Min replicas: Set to 1 or more to ensure availability</li> <li>Max replicas: Configure based on expected load</li> <li>Scale rules: Consider CPU/memory-based scaling</li> </ul>"},{"location":"n-encyclopedia/deployment-options/#environment-variables","title":"Environment Variables","text":"<pre><code># Essential environment variables\nAPP_SERVER_URL=https://your-platform-url\nAPP_SERVER_API_KEY=your-api-key\n...\n</code></pre>"},{"location":"n-encyclopedia/deployment-options/#resource-allocation","title":"Resource Allocation","text":"<ul> <li>CPU: 1 cores for basic agents</li> <li>Memory: 1.0 GB for basic agents</li> <li>Adjust based on agent complexity and workload</li> </ul>"},{"location":"n-encyclopedia/deployment-options/#networking","title":"Networking","text":"<ul> <li>no public endpoint needed</li> <li>Ensure connectivity to Xians platform</li> <li>Configure any required service connections</li> </ul>"},{"location":"n-encyclopedia/logging/","title":"Logging in Agent Flows","text":"<p>This guide explains how to implement logging in your XiansAi workflows using the built-in logging framework.</p>"},{"location":"n-encyclopedia/logging/#overview","title":"Overview","text":"<p>XiansAi provides a robust logging system built on top of Microsoft.Extensions.Logging that integrates with Temporal workflows. The system supports multiple log levels, context-aware logging, and configurable output destinations. This approach enables:</p> <ul> <li>Consistent logging across workflows and activities</li> <li>Automatic context capture for better debugging</li> <li>Configurable log levels for different environments</li> <li>Thread-safe logging implementation</li> </ul>"},{"location":"n-encyclopedia/logging/#step-1-initialize-logger","title":"Step 1: Initialize Logger","text":"<p>To use logging in your workflow or activity, first initialize a static logger instance:</p> <pre><code>using XiansAi.Logging;\n\npublic class YourWorkflow : FlowBase\n{\n    private static readonly Logger&lt;YourWorkflow&gt; _logger = Logger&lt;YourWorkflow&gt;.For();\n}\n</code></pre>"},{"location":"n-encyclopedia/logging/#step-2-configure-logging","title":"Step 2: Configure Logging","text":"<p>The logging system can be configured through environment variables:</p> <pre><code># Set console log level (defaults to Debug if not set)\nCONSOLE_LOG_LEVEL=DEBUG  # Options: TRACE, DEBUG, INFORMATION/INFO, WARNING/WARN, ERROR, CRITICAL\n\n# Set API log level for database logging (defaults to Error if not set)\nAPI_LOG_LEVEL=ERROR      # Options: TRACE, DEBUG, INFORMATION/INFO, WARNING/WARN, ERROR, CRITICAL\n</code></pre>"},{"location":"n-encyclopedia/logging/#console-vs-api-logging","title":"Console vs API Logging","text":"<p>It's important to understand the distinction between console logging and API logging:</p> <ul> <li> <p><code>CONSOLE_LOG_LEVEL</code>: Controls which logs are displayed in the agent's console output. This is useful for local debugging and monitoring agent activity in real-time.</p> </li> <li> <p><code>API_LOG_LEVEL</code>: Controls which logs are sent to the server and stored in the database. By default, only logs with level <code>ERROR</code> and above are sent to the server for database storage.</p> </li> </ul> <p>The API log level supports the following values: - <code>TRACE</code>: All log levels are sent to the database - <code>DEBUG</code>: Debug and above are sent to the database - <code>INFORMATION</code> or <code>INFO</code>: Information and above are sent to the database - <code>WARNING</code> or <code>WARN</code>: Warning and above are sent to the database - <code>ERROR</code>: Only Error and Critical logs are sent to the database (default) - <code>CRITICAL</code>: Only Critical logs are sent to the database</p>"},{"location":"n-encyclopedia/logging/#database-log-retention","title":"Database Log Retention","text":"<p>Logs stored in the database have a Time-To-Live (TTL) of 15 days. After this period, logs are automatically deleted from the database to manage storage efficiently. This retention policy ensures that recent logs are available for debugging and auditing while preventing unlimited storage growth.</p>"},{"location":"n-encyclopedia/logging/#step-3-implement-logging","title":"Step 3: Implement Logging","text":""},{"location":"n-encyclopedia/logging/#workflow-example","title":"Workflow Example","text":"<pre><code>using Temporalio.Workflows;\nusing XiansAi.Flow;\nusing XiansAi.Logging;\n\n[Workflow(\"Example Workflow\")]\npublic class ExampleWorkflow : FlowBase\n{\n    private static readonly Logger&lt;ExampleWorkflow&gt; _logger = Logger&lt;ExampleWorkflow&gt;.For();\n\n    private readonly ActivityOptions _activityOptions = new()\n    {\n        ScheduleToCloseTimeout = TimeSpan.FromMinutes(1)\n    };\n\n    [WorkflowRun]\n    public async Task&lt;string&gt; Run(string input)\n    {\n        _logger.LogInformation(\"Starting workflow with input: \" + input);\n\n        try\n        {\n            var result = await Workflow.ExecuteActivityAsync(\n                (IExampleActivity a) =&gt; a.ProcessData(input), \n                _activityOptions\n            );\n\n            _logger.LogInformation(\"Workflow completed successfully\");\n            return result;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogCritical(\"Critical workflow failure that requires admin attention\", ex);\n            throw;\n        }\n    }\n}\n</code></pre>"},{"location":"n-encyclopedia/logging/#activity-example","title":"Activity Example","text":"<pre><code>using Temporalio.Activities;\nusing XiansAi.Logging;\n\npublic interface IExampleActivity\n{\n    [Activity]\n    Task&lt;string&gt; ProcessData(string input);\n}\n\npublic class ExampleActivity : IExampleActivity\n{\n    private static readonly Logger&lt;ExampleActivity&gt; _logger = Logger&lt;ExampleActivity&gt;.For();\n\n    public Task&lt;string&gt; ProcessData(string input)\n    {\n        _logger.LogInformation(\"Starting to process data: \" + input);\n\n        try\n        {\n            // Simulate some processing\n            var result = input.ToUpper();\n            _logger.LogInformation(\"Data processed successfully\");\n\n            return Task.FromResult(result);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(\"Failed to process data\", ex);\n            throw;\n        }\n    }\n}\n</code></pre>"},{"location":"n-encyclopedia/logging/#log-levels","title":"Log Levels","text":"<p>XiansAi supports all standard log levels from Microsoft.Extensions.Logging:</p> <ol> <li>Trace (<code>LogTrace</code>): Most detailed logging level</li> <li>Debug (<code>LogDebug</code>): Detailed information for debugging</li> <li>Information (<code>LogInformation</code>): General operational messages</li> <li>Warning (<code>LogWarning</code>): Potentially harmful situations</li> <li>Error (<code>LogError</code>): Error events that might still allow the application to continue</li> <li>Critical (<code>LogCritical</code>): Critical failures that require admin attention and will trigger notifications in the admin panel. Should only be used at the workflow level.</li> </ol>"},{"location":"n-encyclopedia/logging/#best-practices","title":"Best Practices","text":""},{"location":"n-encyclopedia/logging/#1-log-level-selection","title":"1. Log Level Selection","text":"<ul> <li>Use <code>LogTrace</code> for very detailed debugging information</li> <li>Use <code>LogDebug</code> for general debugging information</li> <li>Use <code>LogInformation</code> for normal operational messages</li> <li>Use <code>LogWarning</code> for potentially harmful situations</li> <li>Use <code>LogError</code> for recoverable errors</li> <li>Use <code>LogCritical</code> only at the workflow level for failures that require admin attention</li> </ul>"},{"location":"n-encyclopedia/logging/#2-critical-error-usage","title":"2. Critical Error Usage","text":"<ul> <li>Use <code>LogCritical</code> only at the workflow level</li> <li>Use for system-level failures that require immediate attention</li> <li>Use for security-related issues</li> <li>Use for data integrity problems</li> <li>Use for critical business rule violations</li> <li>Critical errors will automatically notify administrators via the admin panel</li> <li>Activities should use <code>LogError</code> or <code>LogWarning</code> instead of <code>LogCritical</code></li> </ul>"},{"location":"n-encyclopedia/logging/#3-exception-logging","title":"3. Exception Logging","text":"<p>Exceptions are optional when logging errors:</p> <pre><code>// In activities, use error level\n_logger.LogError(\"Activity failed\", exception);\n\n// In workflows, use critical for important failures\n_logger.LogCritical(\"Critical workflow failure\", exception);\n</code></pre>"},{"location":"n-encyclopedia/logging/#4-context-usage","title":"4. Context Usage","text":"<ul> <li>The logger automatically includes workflow context when available</li> <li>No need to manually add context information</li> <li>Context is preserved across async boundaries</li> </ul>"},{"location":"n-encyclopedia/logging/#5-performance-considerations","title":"5. Performance Considerations","text":"<ul> <li>Logger instances are cached per type</li> <li>Lazy initialization ensures minimal overhead</li> <li>Context data is collected only when needed</li> </ul>"},{"location":"n-encyclopedia/logging/#auditing-and-log-exploration","title":"Auditing and Log Exploration","text":"<p>XiansAi provides a comprehensive auditing interface to help you monitor and troubleshoot your workflows through two main components:</p>"},{"location":"n-encyclopedia/logging/#activity-retry-failures","title":"Activity Retry Failures","text":"<p>The Activity Retry Failures section specifically focuses on critical workflow failures:</p> <ul> <li>Displays workflows that have encountered critical errors</li> <li>Shows detailed error information and stack traces</li> <li>Highlights workflows requiring immediate attention</li> <li>Provides quick access to related logs and context</li> <li>Automatically notifies administrators of critical failures</li> </ul> <p>These auditing tools are directly integrated with the logging system. When you use <code>LogCritical</code> in your workflows, these events are automatically surfaced in the Activity Retry Failures section, making it easy to identify and respond to critical issues quickly.</p> <p></p>"},{"location":"n-encyclopedia/logging/#workflow-log-explorer","title":"Workflow Log Explorer","text":"<p>The Workflow Log Explorer is a powerful tool that allows you to:</p> <ul> <li>View and search through all workflow logs across your system</li> <li>Filter logs by various criteria including:<ul> <li>Agent name</li> <li>Workflow type</li> <li>Workflow ID</li> <li>Log Level</li> <li>Time range</li> </ul> </li> <li>Track the complete execution history of any workflow</li> </ul> <p></p>"},{"location":"n-encyclopedia/multi-flow-agents/","title":"Creating Multi-Flow Agents","text":"<p>This guide explains how to create an agent with multiple flows using the XiansAi framework.</p>"},{"location":"n-encyclopedia/multi-flow-agents/#overview","title":"Overview","text":"<p>Multi-flow agents allow you to split complex functionality into separate workflows that can run independently but share the same agent identity. This approach enables:</p> <ul> <li>Better separation of concerns</li> <li>Independent development and scaling of different workflows</li> <li>Simpler maintenance and debugging</li> </ul>"},{"location":"n-encyclopedia/multi-flow-agents/#step-1-define-individual-flows","title":"Step 1: Define Individual Flows","text":""},{"location":"n-encyclopedia/multi-flow-agents/#example-consultationbot","title":"Example: ConsultationBot","text":"<pre><code>using Temporalio.Workflows;\nusing XiansAi.Flow;\n\nnamespace Conversing.Consultation;\n\n[Workflow(\"Consultation Bot\")]\npublic class ConsultationBot : FlowBase\n{\n    [WorkflowRun]\n    public async Task Run()\n    {\n        // Your consultation logic here\n    }\n}\n</code></pre>"},{"location":"n-encyclopedia/multi-flow-agents/#example-medicineinfobot","title":"Example: MedicineInfoBot","text":"<pre><code>using Temporalio.Workflows;\nusing XiansAi.Flow;\n\nnamespace Conversing.MedicineInfo;\n\n[Workflow(\"Medicine Info Bot\")]\npublic class MedicineInfoBot : FlowBase\n{\n    [WorkflowRun]\n    public async Task Run()\n    {\n        // Your medicine info logic here\n    }\n}\n</code></pre>"},{"location":"n-encyclopedia/multi-flow-agents/#step-2-configure-agent-and-flows","title":"Step 2: Configure Agent and Flows","text":"<p>In your <code>Program.cs</code>, define a single <code>Agent</code> object and configure each flow with its capabilities:</p> <pre><code>using XiansAi.Flow;\nusing DotNetEnv;\nusing Conversing.Consultation;\nusing Conversing.MedicineInfo;\nusing Conversing.HealthRecords;\nusing Sensing.ConsultantNotes;\n\n// Env config via DotNetEnv\nEnv.Load();\n\n// name your agent\nvar agent = new AgentTeam(\"Consultation Assist Agent\");\n\n// Configure Consultation Bot\nvar consultationBot = agent.AddAgent&lt;ConsultationBot&gt;();\nconsultationBot.AddCapabilities&lt;UploadCapability&gt;();\nconsultationBot.AddCapabilities&lt;HandoverCapabilities&gt;();\n\n// Configure Medicine Info Bot\nvar medicineInfoBot = agent.AddAgent&lt;MedicineInfoBot&gt;();\nmedicineInfoBot.AddCapabilities&lt;FdaInfoCapabilities&gt;();\nmedicineInfoBot.AddCapabilities&lt;HandoverCapabilities&gt;();\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"n-encyclopedia/multi-flow-agents/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Shared Identity: Use a single <code>Agent</code> object for all flows to maintain a consistent agent identity.</p> </li> <li> <p>Flow Separation: Design flows to handle distinct functionality (e.g., consultation handling vs. medicine information).</p> </li> <li> <p>Flow Communication: If flows need to communicate, use events rather than direct references.</p> </li> </ol> <p>This architecture allows you to build complex agents with specialized workflows while maintaining a unified agent identity and coordinated lifecycle management. Each flow can have its own set of capabilities and activities, making the system modular and maintainable.</p>"},{"location":"n-encyclopedia/retry-policy/","title":"Retry Policy in XiansAi Workflows","text":"<p>This guide explains how to implement retry policies in your XiansAi workflows using Temporal's activity options.</p>"},{"location":"n-encyclopedia/retry-policy/#overview","title":"Overview","text":"<p>XiansAi leverages Temporal's robust retry policy system to handle transient failures in activities. The system provides:</p> <ul> <li>Configurable retry attempts and backoff strategies</li> <li>Customizable timeout settings</li> <li>Automatic handling of transient failures</li> <li>Fine-grained control over activity execution</li> </ul>"},{"location":"n-encyclopedia/retry-policy/#activity-options-configuration","title":"Activity Options Configuration","text":"<p>Activities in XiansAi workflows can be configured with various options to control their execution and retry behavior:</p> <pre><code>private readonly ActivityOptions _activityOptions = new()\n{\n    // Total timeout for all attempts including retries\n    ScheduleToCloseTimeout = TimeSpan.FromMinutes(5),\n\n    // Timeout for each individual attempt\n    StartToCloseTimeout = TimeSpan.FromMinutes(1),\n\n    // Timeout for activity heartbeats\n    HeartbeatTimeout = TimeSpan.FromSeconds(30),\n\n    // Retry policy configuration\n    RetryPolicy = new RetryPolicy\n    {\n        InitialInterval = TimeSpan.FromSeconds(1),\n        MaximumInterval = TimeSpan.FromMinutes(1),\n        BackoffCoefficient = 2.0,\n        MaximumAttempts = 3\n    }\n};\n</code></pre>"},{"location":"n-encyclopedia/retry-policy/#timeout-settings","title":"Timeout Settings","text":""},{"location":"n-encyclopedia/retry-policy/#scheduletoclosetimeout","title":"ScheduleToCloseTimeout","text":"<ul> <li>Total timeout for all attempts including retries</li> <li>Must be set if StartToCloseTimeout is not set</li> <li>Defaults to workflow execution timeout if unset</li> </ul>"},{"location":"n-encyclopedia/retry-policy/#starttoclosetimeout","title":"StartToCloseTimeout","text":"<ul> <li>Timeout for each individual retry attempt</li> <li>Must be set if ScheduleToCloseTimeout is not set</li> <li>Applies to each separate retry attempt</li> </ul>"},{"location":"n-encyclopedia/retry-policy/#scheduletostarttimeout","title":"ScheduleToStartTimeout","text":"<ul> <li>Timeout from schedule to when activity is picked up by a worker</li> <li>Defaults to ScheduleToCloseTimeout if unset</li> </ul>"},{"location":"n-encyclopedia/retry-policy/#heartbeattimeout","title":"HeartbeatTimeout","text":"<ul> <li>Required for activities to receive cancellation</li> <li>Should be set for all but the most instantly completing activities</li> </ul>"},{"location":"n-encyclopedia/retry-policy/#retry-policy-configuration","title":"Retry Policy Configuration","text":"<p>The RetryPolicy property allows you to configure how activities handle failures:</p> <pre><code>RetryPolicy = new RetryPolicy\n{\n    // Initial delay between retries\n    InitialInterval = TimeSpan.FromSeconds(1),\n\n    // Maximum delay between retries\n    MaximumInterval = TimeSpan.FromMinutes(1),\n\n    // Multiplier for the interval after each retry\n    BackoffCoefficient = 2.0,\n\n    // Maximum number of retry attempts\n    MaximumAttempts = 3,\n\n    // Non-retryable error types\n    NonRetryableErrorTypes = new[] { \"NonRetryableError\" }\n}\n</code></pre>"},{"location":"n-encyclopedia/retry-policy/#example-implementation","title":"Example Implementation","text":"<p>Here's a complete example of a workflow using activity options with retry policy:</p> <pre><code>using Temporalio.Common;\nusing Temporalio.Workflows;\nusing XiansAi.Flow;\n\n[Workflow(\"Example Workflow\")]\npublic class ExampleWorkflow : FlowBase\n{\n    private readonly ActivityOptions _activityOptions = new()\n    {\n        ScheduleToCloseTimeout = TimeSpan.FromMinutes(5),\n        StartToCloseTimeout = TimeSpan.FromMinutes(1),\n        HeartbeatTimeout = TimeSpan.FromSeconds(30),\n        RetryPolicy = new RetryPolicy\n        {\n            InitialInterval = TimeSpan.FromSeconds(1),\n            MaximumInterval = TimeSpan.FromMinutes(1),\n            BackoffCoefficient = 2.0,\n            MaximumAttempts = 3\n        }\n    };\n\n    [WorkflowRun]\n    public async Task&lt;string&gt; Run(string input)\n    {\n        try\n        {\n            var result = await Workflow.ExecuteActivityAsync(\n                (IExampleActivity a) =&gt; a.ProcessData(input), \n                _activityOptions\n            );\n            return result;\n        }\n        catch (Exception ex)\n        {\n            // Handle any non-retryable errors here\n            throw;\n        }\n    }\n}\n</code></pre>"},{"location":"n-encyclopedia/retry-policy/#best-practices","title":"Best Practices","text":""},{"location":"n-encyclopedia/retry-policy/#1-timeout-configuration","title":"1. Timeout Configuration","text":"<ul> <li>Always set appropriate timeouts for your activities</li> <li>Consider the nature of the activity when setting timeouts</li> <li>Use HeartbeatTimeout for long-running activities</li> </ul>"},{"location":"n-encyclopedia/retry-policy/#2-retry-policy-design","title":"2. Retry Policy Design","text":"<ul> <li>Set reasonable MaximumAttempts to prevent infinite retries</li> <li>Use exponential backoff with BackoffCoefficient</li> <li>Configure appropriate InitialInterval and MaximumInterval</li> <li>Specify NonRetryableErrorTypes for errors that shouldn't be retried</li> </ul>"},{"location":"n-encyclopedia/retry-policy/#3-error-handling","title":"3. Error Handling","text":"<ul> <li>Implement proper error handling in activities</li> <li>Use appropriate error types for different failure scenarios</li> <li>Consider using custom exceptions for specific error cases</li> </ul>"},{"location":"n-encyclopedia/retry-policy/#4-performance-considerations","title":"4. Performance Considerations","text":"<ul> <li>Balance retry attempts with overall workflow timeout</li> <li>Consider the impact of retries on downstream systems</li> <li>Monitor retry patterns to identify systemic issues</li> </ul>"},{"location":"n-encyclopedia/retry-policy/#additional-options","title":"Additional Options","text":"<p>ActivityOptions provides several other useful settings:</p> <ul> <li>CancellationType: Controls how the workflow handles activity cancellation</li> <li>TaskQueue: Specifies which task queue to use for the activity</li> <li>DisableEagerActivityExecution: Controls whether to disable eager execution optimization</li> <li>VersioningIntent: Controls worker versioning behavior</li> <li>ActivityId: Unique identifier for the activity (use with caution)</li> </ul>"},{"location":"n-encyclopedia/retry-policy/#implementation-details","title":"Implementation Details","text":"<p>The retry system uses: - Exponential backoff for retry intervals - Configurable maximum attempts - Customizable error type filtering - Automatic handling of transient failures - Integration with Temporal's workflow engine</p> <p>This architecture allows you to build resilient workflows that can handle transient failures while maintaining control over the retry behavior and execution timeouts.</p>"},{"location":"n-encyclopedia/scaling-agents/","title":"Scaling Agent Flows","text":""},{"location":"n-encyclopedia/scaling-agents/#overview","title":"Overview","text":"<p>In Xians, scalability is achieved through distributed workflow execution using Temporal queues. Every Agent Workflow automatically creates a temporal queue that enables horizontal scaling by allowing multiple agent instances to share the workload seamlessly. This document explains how to configure and scale your agent flows for high-throughput scenarios.</p>"},{"location":"n-encyclopedia/scaling-agents/#temporal-queue-architecture","title":"Temporal Queue Architecture","text":"<p>Each Agent Workflow in Xians is backed by a Temporal queue that serves as the distribution mechanism for work items. When multiple agent instances are deployed, they all connect to the same temporal queue and automatically distribute the workload among themselves.</p>"},{"location":"n-encyclopedia/scaling-agents/#key-benefits","title":"Key Benefits","text":"<ul> <li>Automatic Load Distribution: Work is automatically distributed across all connected workers</li> <li>Fault Tolerance: If one worker fails, others continue processing</li> <li>Dynamic Scaling: Add or remove workers without service interruption</li> <li>Guaranteed Execution: Temporal ensures all work items are processed exactly once</li> </ul>"},{"location":"n-encyclopedia/scaling-agents/#configuring-worker-scalability","title":"Configuring Worker Scalability","text":""},{"location":"n-encyclopedia/scaling-agents/#default-configuration","title":"Default Configuration","text":"<p>By default, each Xians agent creates a single worker per workflow. This is suitable for development and low-throughput scenarios:</p> <pre><code>// Default single worker configuration\nvar agent = new AgentTeam(\"ERP Agent\");\nvar bot = agent.AddAgent&lt;OrderBot&gt;(); // Creates 1 worker by default\nbot.AddCapabilities(typeof(OrderCapabilities));\nawait agent.RunAsync();\n</code></pre>"},{"location":"n-encyclopedia/scaling-agents/#multi-worker-configuration","title":"Multi-Worker Configuration","text":"<p>For production environments requiring higher throughput, you can configure multiple workers using the <code>numberOfWorkers</code> parameter:</p> <pre><code>// Multi-worker configuration for high throughput\nvar agent = new AgentTeam(\"ERP Agent\");\n\n// Configure 5 workers for the OrderBot workflow\nvar bot = agent.AddAgent&lt;OrderBot&gt;(numberOfWorkers: 5);\nbot.AddCapabilities(typeof(OrderCapabilities));\nawait agent.RunAsync();\n</code></pre>"},{"location":"n-encyclopedia/scaling-agents/#advanced-worker-configuration","title":"Advanced Worker Configuration","text":"<p>You can configure different worker counts for different workflows within the same agent:</p> <pre><code>var agent = new AgentTeam(\"Multi-Service Agent\");\n\n// High-throughput order processing\nvar orderBot = agent.AddAgent&lt;OrderBot&gt;(numberOfWorkers: 10);\norderBot.AddCapabilities(typeof(OrderCapabilities));\n\n// Moderate-throughput inventory management\nvar inventoryBot = agent.AddAgent&lt;InventoryBot&gt;(numberOfWorkers: 3);\ninventoryBot.AddCapabilities(typeof(InventoryCapabilities));\n\n// Low-throughput reporting\nvar reportBot = agent.AddAgent&lt;ReportBot&gt;(numberOfWorkers: 1);\nreportBot.AddCapabilities(typeof(ReportCapabilities));\n\nawait agent.RunAsync();\n</code></pre>"},{"location":"n-encyclopedia/scaling-agents/#scaling-strategies","title":"Scaling Strategies","text":""},{"location":"n-encyclopedia/scaling-agents/#vertical-scaling-per-instance-workers","title":"Vertical Scaling (Per-Instance Workers)","text":"<p>Increase the <code>numberOfWorkers</code> parameter to handle more concurrent workflows within a single agent instance:</p> <pre><code>// Scale up workers within a single instance\nvar agent = new AgentTeam(\"High-Performance Agent\");\nvar bot = agent.AddAgent&lt;ProcessingBot&gt;(numberOfWorkers: 20);\n</code></pre> <p>When to use:</p> <ul> <li>Single deployment environment</li> <li>Sufficient CPU and memory resources</li> <li>Simplified deployment management</li> </ul>"},{"location":"n-encyclopedia/scaling-agents/#horizontal-scaling-multiple-instances","title":"Horizontal Scaling (Multiple Instances)","text":"<p>Combine both approaches for maximum throughput:</p> <pre><code>// Multiple instances, each with multiple workers\nvar agent = new AgentTeam(\"Hybrid Scaled Agent\");\nvar bot = agent.AddAgent&lt;ProcessingBot&gt;(numberOfWorkers: 8);\n</code></pre> <p>Deploy this configuration across multiple containers/servers for optimal scaling.</p>"},{"location":"n-encyclopedia/scaling-agents/#performance-considerations","title":"Performance Considerations","text":""},{"location":"n-encyclopedia/scaling-agents/#optimal-worker-count","title":"Optimal Worker Count","text":"<p>The optimal number of workers depends on several factors:</p> <ul> <li>CPU Cores: Generally 1-2 workers per CPU core</li> <li>I/O Operations: More workers for I/O-heavy workflows</li> <li>Memory Usage: Consider memory requirements per worker</li> <li>External Dependencies: Account for rate limits and connection pools</li> </ul>"},{"location":"n-encyclopedia/scaling-agents/#example-configurations","title":"Example Configurations","text":"<pre><code>// CPU-intensive workflows\nvar cpuBot = agent.AddAgent&lt;DataProcessingBot&gt;(numberOfWorkers: Environment.ProcessorCount);\n\n// I/O-intensive workflows (API calls, database operations)\nvar ioBot = agent.AddAgent&lt;IntegrationBot&gt;(numberOfWorkers: Environment.ProcessorCount * 2);\n\n// Memory-intensive workflows\nvar memoryBot = agent.AddAgent&lt;AnalyticsBot&gt;(numberOfWorkers: 2);\n</code></pre>"},{"location":"n-encyclopedia/scaling-agents/#monitoring-and-tuning","title":"Monitoring and Tuning","text":"<p>Monitor these metrics to optimize worker configuration:</p> <ul> <li>Queue Depth: High queue depth indicates need for more workers</li> <li>Worker Utilization: Low utilization suggests over-provisioning</li> <li>Throughput: Measure workflows completed per second</li> <li>Error Rates: High error rates may indicate resource contention</li> </ul>"},{"location":"n-encyclopedia/scaling-agents/#best-practices","title":"Best Practices","text":""},{"location":"n-encyclopedia/scaling-agents/#1-start-conservative","title":"1. Start Conservative","text":"<p>Begin with fewer workers and scale up based on monitoring data:</p> <pre><code>// Start with moderate scaling\nvar bot = agent.AddAgent&lt;NewWorkflowBot&gt;(numberOfWorkers: 3);\n</code></pre>"},{"location":"n-encyclopedia/scaling-agents/#2-environment-specific-configuration","title":"2. Environment-Specific Configuration","text":"<p>Use configuration files or environment variables for different environments:</p> <pre><code>var workerCount = int.Parse(Environment.GetEnvironmentVariable(\"WORKER_COUNT\") ?? \"1\");\nvar bot = agent.AddAgent&lt;ProductionBot&gt;(numberOfWorkers: workerCount);\n</code></pre>"},{"location":"n-encyclopedia/scaling-agents/#3-resource-aware-scaling","title":"3. Resource-Aware Scaling","text":"<p>Consider available resources when setting worker counts:</p> <pre><code>var maxWorkers = Math.Min(Environment.ProcessorCount * 2, 20);\nvar bot = agent.AddAgent&lt;AdaptiveBot&gt;(numberOfWorkers: maxWorkers);\n</code></pre>"},{"location":"n-encyclopedia/scaling-agents/#monitoring-commands","title":"Monitoring Commands","text":"<p>Use Temporal CLI to monitor queue performance:</p> <pre><code># Check workflow queue status\ntemporal workflow list --query \"WorkflowType='YourWorkflowType'\"\n\n# Monitor task queue\ntemporal task-queue describe --task-queue your-task-queue\n</code></pre>"},{"location":"n-encyclopedia/scaling-agents/#auto-scaling-based-on-queue-metrics","title":"Auto Scaling Based on Queue Metrics","text":""},{"location":"n-encyclopedia/scaling-agents/#monitoring-queue-size-for-auto-scaling","title":"Monitoring Queue Size for Auto Scaling","text":"<p>For dynamic scaling scenarios, you can monitor the Temporal queue size to automatically adjust the number of workers. This approach enables responsive scaling based on actual workload demand.</p>"},{"location":"n-encyclopedia/system-scoped-agents/","title":"System-Scoped Agents","text":""},{"location":"n-encyclopedia/system-scoped-agents/#overview","title":"Overview","text":"<p>System-scoped agents are agents that are deployed system-wide as templates rather than being deployed directly to a specific tenant. These agents serve as reusable templates that can be onboarded to multiple tenants, making them ideal for creating agent marketplaces, starter templates, or organization-wide agent libraries.</p> <p></p>"},{"location":"n-encyclopedia/system-scoped-agents/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>System-Wide Availability: Deployed once and available across all tenants</li> <li>Template-Based: Act as blueprints that can be instantiated per tenant</li> <li>Centralized Management: Updated in one place, available everywhere</li> <li>Onboarding Workflow: Include guided setup for tenant-specific configuration</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#prerequisites","title":"Prerequisites","text":"<p>To create and deploy a system-scoped agent, the developer must have:</p> <ul> <li>System Administrator Access: The API key used for deployment must belong to a system administrator</li> <li>Without system admin privileges, the deployment will fail with an authorization error</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#creating-a-system-scoped-agent","title":"Creating a System-Scoped Agent","text":""},{"location":"n-encyclopedia/system-scoped-agents/#basic-configuration","title":"Basic Configuration","text":"<p>To create a system-scoped agent, set the <code>SystemScoped</code> property to <code>true</code> in the <code>RunnerOptions</code>:</p> <pre><code>var options = new RunnerOptions \n{\n    SystemScoped = true\n};\n\n// Create the agent\nvar agentTeam = new AgentTeam(\"Percy v4\", options);\n</code></pre>"},{"location":"n-encyclopedia/system-scoped-agents/#with-onboarding-configuration","title":"With Onboarding Configuration","text":"<p>For a complete system-scoped agent with guided tenant onboarding, include the <code>OnboardingJson</code> property. It's recommended to organize your onboarding configurations in a static class:</p> <pre><code>public static class Onboarding\n{\n    public static string Percy = @\"\n    {\n        \"\"display-name\"\": \"\"Percy - Prospect Discovery Agent\"\",\n        \"\"version\"\": \"\"3.0.0\"\",\n        \"\"description\"\": \"\"Continuously scans news articles, tender databases, social media, and industry publications to identify potential opportunities 24/7. Uses advanced NLP to understand context and relevance.\"\",\n        \"\"author\"\": \"\"99x\"\",\n        \"\"license\"\": \"\"Proprietary\"\",\n        \"\"icon\"\": \"\"https://agentri.ai/img/theme/percy_icon.png\"\",\n        \"\"url\"\": \"\"https://agentri.ai/\"\",\n        \"\"tags\"\": [\n            \"\"Prospecting\"\",\n            \"\"Marketing Automation\"\"\n        ],\n        \"\"workflow\"\": [\n            {\n                \"\"step\"\": \"\"knowledge\"\",\n                \"\"name\"\": \"\"Configurations\"\",\n                \"\"description\"\": \"\"Sets the news sources to scan and the recipients of the prospect report.\"\",\n                \"\"url\"\": \"\"https://agentri.ai\"\",\n                \"\"value\"\": {\n                    \"\"reportRecipients\"\": [\n                        \"\"user@email.com\"\"\n                    ],\n                    \"\"sources\"\": [\n                        {\n                            \"\"name\"\": \"\"Shifter\"\",\n                            \"\"url\"\": \"\"https://www.shifter.no/nyheter/\"\"\n                        }\n                    ]\n                }            \n            },\n            {\n                \"\"step\"\": \"\"knowledge\"\",\n                \"\"name\"\": \"\"How To Select Articles\"\",\n                \"\"description\"\": \"\"How to select articles to scan for potential opportunities.\"\",\n                \"\"value\"\": \"\"Select articles about any company getting funding to build AI products. Return 'true: &lt;justification&gt;' or 'false: &lt;justification&gt;'. Do not return any other text.\"\"           \n            },\n            {\n                \"\"step\"\": \"\"activate\"\",\n                \"\"name\"\": \"\"Activate the following bots\"\",\n                \"\"description\"\": \"\"Activate the Scheduler Bot to start the agent.\"\",\n                \"\"value\"\": [\n                    \"\"Percy v3: Scheduler Bot\"\"\n                ]\n            }\n        ]\n    }\";\n}\n\n// Use the onboarding configuration\nvar options = new RunnerOptions \n{\n    SystemScoped = true,\n    OnboardingJson = Onboarding.Percy\n};\n\nvar agentTeam = new AgentTeam(\"Percy v4\", options);\n</code></pre>"},{"location":"n-encyclopedia/system-scoped-agents/#onboarding-json-structure","title":"Onboarding JSON Structure","text":"<p>The <code>OnboardingJson</code> provides metadata and a guided workflow for tenants to onboard the agent. Here's the structure:</p>"},{"location":"n-encyclopedia/system-scoped-agents/#metadata-fields","title":"Metadata Fields","text":"Field Type Required Description <code>display-name</code> string Yes User-friendly name shown in the agent marketplace or catalog <code>version</code> string Yes Semantic version number (e.g., \"3.0.0\") <code>description</code> string Yes Detailed description of the agent's capabilities and purpose <code>author</code> string Yes Organization or individual who created the agent <code>license</code> string Yes License type (e.g., \"Proprietary\", \"MIT\", \"Apache-2.0\") <code>icon</code> string No URL to the agent's icon/logo image <code>url</code> string No Link to documentation, website, or more information <code>tags</code> array No Array of strings for categorization and searchability <code>workflow</code> array Yes Step-by-step onboarding workflow (see below)"},{"location":"n-encyclopedia/system-scoped-agents/#workflow-steps","title":"Workflow Steps","text":"<p>The <code>workflow</code> array defines the onboarding process for tenants. Each step has a specific purpose:</p>"},{"location":"n-encyclopedia/system-scoped-agents/#step-types","title":"Step Types","text":""},{"location":"n-encyclopedia/system-scoped-agents/#1-knowledge-step","title":"1. Knowledge Step","text":"<p>Used to configure knowledge base entries, settings, or instructions:</p> <p>Example - JSON Configuration:</p> <pre><code>{\n    \"step\": \"knowledge\",\n    \"name\": \"Configurations\",\n    \"description\": \"Sets the news sources to scan and the recipients of the prospect report.\",\n    \"url\": \"https://agentri.ai\",\n    \"type\": \"json\",\n    \"value\": {\n        \"reportRecipients\": [\"user@email.com\"],\n        \"sources\": [\n            {\n                \"name\": \"Example Source\",\n                \"url\": \"https://example.com\"\n            }\n        ]\n    }\n}\n</code></pre> <p>Example - String/Text Value (without type):</p> <pre><code>{\n    \"step\": \"knowledge\",\n    \"name\": \"Selection Criteria\",\n    \"description\": \"Instructions for selecting relevant articles\",\n    \"value\": \"Select articles about AI funding. Return 'true: &lt;reason&gt;' or 'false: &lt;reason&gt;'.\"\n}\n</code></pre> <p>Example - Markdown Type:</p> <pre><code>{\n    \"step\": \"knowledge\",\n    \"name\": \"Article Selection Guidelines\",\n    \"description\": \"Detailed instructions for article selection\",\n    \"type\": \"markdown\",\n    \"value\": \"## Selection Criteria\\n\\nSelect articles that meet the following:\\n- Company funding announcements\\n- AI product development\\n\\nReturn 'true: &lt;reason&gt;' or 'false: &lt;reason&gt;'.\"\n}\n</code></pre> <p>Fields:</p> <ul> <li><code>step</code>: (Required) Must be <code>\"knowledge\"</code></li> <li><code>name</code>: (Required) Display name for this configuration step</li> <li><code>description</code>: (Required) Explanation of what this configuration does</li> <li><code>url</code>: (Optional) Link to additional documentation</li> <li><code>type</code>: (Optional) Data type - can be <code>\"json\"</code> or <code>\"markdown\"</code>. If omitted, the value is treated as plain text/string</li> <li><code>value</code>: (Required) The actual configuration data or instructions. Can be an object (for JSON) or a string</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#2-activate-step","title":"2. Activate Step","text":"<p>Used to specify which agents or bots should be activated after configuration:</p> <pre><code>{\n    \"step\": \"activate\",\n    \"name\": \"Activate the following bots\",\n    \"description\": \"Activate the Scheduler Bot to start the agent.\",\n    \"value\": [\n        \"Percy v3: Scheduler Bot\",\n        \"Percy v3: News Scanner Bot\"\n    ]\n}\n</code></pre> <p>Fields:</p> <ul> <li><code>step</code>: Must be <code>\"activate\"</code></li> <li><code>name</code>: Display name for this activation step</li> <li><code>description</code>: Explanation of what will be activated</li> <li><code>value</code>: Array of agent/bot names to activate</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#best-practices","title":"Best Practices","text":""},{"location":"n-encyclopedia/system-scoped-agents/#1-version-management","title":"1. Version Management","text":"<p>Use semantic versioning for your agents:</p> <ul> <li>Major version (X.0.0): Breaking changes or major feature overhauls</li> <li>Minor version (1.X.0): New features, backward compatible</li> <li>Patch version (1.0.X): Bug fixes and minor improvements</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#2-comprehensive-descriptions","title":"2. Comprehensive Descriptions","text":"<p>Provide clear, detailed descriptions that help users understand:</p> <ul> <li>What the agent does</li> <li>What problems it solves</li> <li>Any prerequisites or requirements</li> <li>Expected outcomes</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#3-type-field-usage","title":"3. Type Field Usage","text":"<p>The <code>type</code> field in knowledge steps is optional:</p> <ul> <li>Omit <code>type</code>: For simple string/text values or when the system should infer the type from the value</li> <li>Use <code>\"json\"</code>: When you want to explicitly indicate structured JSON data that may need validation</li> <li>Use <code>\"markdown\"</code>: When the content includes markdown formatting that should be rendered appropriately</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#4-sensible-defaults","title":"4. Sensible Defaults","text":"<p>Include default values in the onboarding JSON that:</p> <ul> <li>Demonstrate the expected format</li> <li>Work out-of-the-box for testing</li> <li>Are clearly placeholder values (e.g., <code>user@email.com</code>)</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#5-clear-workflow-steps","title":"5. Clear Workflow Steps","text":"<ul> <li>Order steps logically (configuration \u2192 activation)</li> <li>Use descriptive names and detailed descriptions</li> <li>Provide links to additional documentation when needed</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#6-tagging-strategy","title":"6. Tagging Strategy","text":"<p>Use consistent, meaningful tags:</p> <ul> <li>Functional categories: \"Prospecting\", \"Customer Support\", \"Data Analysis\"</li> <li>Industry: \"Healthcare\", \"Finance\", \"E-commerce\"</li> <li>Use case: \"Automation\", \"Research\", \"Reporting\"</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#organizing-multiple-agent-templates","title":"Organizing Multiple Agent Templates","text":"<p>For projects with multiple system-scoped agents, organize them in a static <code>Onboarding</code> class:</p> <pre><code>public static class Onboarding\n{\n    public static string Percy = @\"\n    {\n        \"\"display-name\"\": \"\"Percy - Prospect Discovery Agent\"\",\n        \"\"version\"\": \"\"3.0.0\"\",\n        \"\"description\"\": \"\"Continuously scans news articles, tender databases, social media, and industry publications to identify potential opportunities 24/7.\"\",\n        \"\"author\"\": \"\"99x\"\",\n        \"\"license\"\": \"\"Proprietary\"\",\n        \"\"icon\"\": \"\"https://agentri.ai/img/theme/percy_icon.png\"\",\n        \"\"url\"\": \"\"https://agentri.ai/\"\",\n        \"\"tags\"\": [\"\"Prospecting\"\", \"\"Marketing Automation\"\"],\n        \"\"workflow\"\": [ /* ... */ ]\n    }\";\n\n    public static string Eli = @\"\n    {\n        \"\"display-name\"\": \"\"Eli - CRM Enrichment Agent\"\",\n        \"\"version\"\": \"\"3.0.0\"\",\n        \"\"description\"\": \"\"Continuously enrich CRM data with additional information.\"\",\n        \"\"author\"\": \"\"99x\"\",\n        \"\"license\"\": \"\"Proprietary\"\",\n        \"\"icon\"\": \"\"https://agentri.ai/img/theme/eli_icon.png\"\",\n        \"\"url\"\": \"\"https://agentri.ai/\"\",\n        \"\"tags\"\": [\"\"Marketing\"\", \"\"Sales\"\"],\n        \"\"workflow\"\": [ /* ... */ ]\n    }\";\n\n    public static string Ava = @\"\n    {\n        \"\"display-name\"\": \"\"Ava - Brand Advisor Agent\"\",\n        \"\"version\"\": \"\"3.0.0\"\",\n        \"\"description\"\": \"\"Continuously observe trends and competitor movements and advises on brand strategy and marketing.\"\",\n        \"\"author\"\": \"\"99x\"\",\n        \"\"license\"\": \"\"Proprietary\"\",\n        \"\"icon\"\": \"\"https://agentri.ai/img/theme/ava_icon.png\"\",\n        \"\"url\"\": \"\"https://agentri.ai/\"\",\n        \"\"tags\"\": [\"\"Branding\"\", \"\"Marketing Strategy\"\"],\n        \"\"workflow\"\": [ /* ... */ ]\n    }\";\n}\n</code></pre> <p>Then reference them when creating agents:</p> <pre><code>var options = new RunnerOptions \n{\n    SystemScoped = true,\n    OnboardingJson = Onboarding.Percy  // or Onboarding.Eli, Onboarding.Ava, etc.\n};\n</code></pre>"},{"location":"n-encyclopedia/system-scoped-agents/#example-complete-system-scoped-agent","title":"Example: Complete System-Scoped Agent","text":"<p>Here's a complete example of creating a system-scoped agent with full onboarding configuration:</p> <pre><code>using Xians.Agent.Sdk;\n\npublic static class Onboarding\n{\n    public static string CustomerSupport = @\"\n    {\n        \"\"display-name\"\": \"\"Customer Support Agent\"\",\n        \"\"version\"\": \"\"1.0.0\"\",\n        \"\"description\"\": \"\"An intelligent customer support agent that handles inquiries, provides product information, and escalates complex issues to human agents.\"\",\n        \"\"author\"\": \"\"Your Company\"\",\n        \"\"license\"\": \"\"Proprietary\"\",\n        \"\"icon\"\": \"\"https://example.com/support-agent-icon.png\"\",\n        \"\"url\"\": \"\"https://example.com/docs/support-agent\"\",\n        \"\"tags\"\": [\n            \"\"Customer Support\"\",\n            \"\"Automation\"\",\n            \"\"Chat\"\"\n        ],\n        \"\"workflow\"\": [\n            {\n                \"\"step\"\": \"\"knowledge\"\",\n                \"\"name\"\": \"\"Support Configuration\"\",\n                \"\"description\"\": \"\"Configure the support channels and escalation rules.\"\",\n                \"\"type\"\": \"\"json\"\",\n                \"\"value\"\": {\n                    \"\"escalationEmail\"\": \"\"support@example.com\"\",\n                    \"\"businessHours\"\": {\n                        \"\"start\"\": \"\"09:00\"\",\n                        \"\"end\"\": \"\"17:00\"\",\n                        \"\"timezone\"\": \"\"UTC\"\"\n                    },\n                    \"\"supportedChannels\"\": [\"\"chat\"\", \"\"email\"\"]\n                }\n            },\n            {\n                \"\"step\"\": \"\"knowledge\"\",\n                \"\"name\"\": \"\"Response Guidelines\"\",\n                \"\"description\"\": \"\"Guidelines for how the agent should respond to customers.\"\",\n                \"\"value\"\": \"\"Always be polite and professional. If you cannot answer a question, escalate to a human agent. Never make promises about delivery dates without checking availability.\"\"\n            },\n            {\n                \"\"step\"\": \"\"activate\"\",\n                \"\"name\"\": \"\"Start Support Agent\"\",\n                \"\"description\"\": \"\"Activate the support bot to begin handling customer inquiries.\"\",\n                \"\"value\"\": [\n                    \"\"Customer Support Bot\"\"\n                ]\n            }\n        ]\n    }\";\n}\n\n// Create and deploy the agent\nvar options = new RunnerOptions \n{\n    SystemScoped = true,\n    OnboardingJson = Onboarding.CustomerSupport\n};\n\nvar agentTeam = new AgentTeam(\"Customer Support Agent\", options);\n\n// Add your flows and agents\nagentTeam.AddAgent&lt;SupportFlow&gt;();\n\n// Run the agent\nawait agentTeam.RunAsync();\n</code></pre>"},{"location":"n-encyclopedia/system-scoped-agents/#tenant-onboarding-process","title":"Tenant Onboarding Process","text":"<p>When a tenant onboards a system-scoped agent:</p> <ol> <li>Discovery: The agent appears in the agent marketplace/catalog with its metadata</li> <li>Configuration: The tenant follows the workflow steps to configure:</li> <li>Knowledge base entries</li> <li>Settings and parameters</li> <li>Custom instructions</li> <li>Activation: The specified agents/bots are activated for that tenant</li> <li>Isolation: Each tenant gets their own instance with their own configuration</li> <li>Updates: System-level updates to the agent template are available to all tenants</li> </ol>"},{"location":"n-encyclopedia/system-scoped-agents/#common-use-cases","title":"Common Use Cases","text":""},{"location":"n-encyclopedia/system-scoped-agents/#agent-marketplaces","title":"Agent Marketplaces","text":"<p>Create a catalog of pre-built agents that users can discover and deploy:</p> <ul> <li>Industry-specific solutions</li> <li>Common business processes</li> <li>Utility agents</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#organization-templates","title":"Organization Templates","text":"<p>Provide standardized agents across an organization:</p> <ul> <li>Consistent tooling across departments</li> <li>Centralized updates and maintenance</li> <li>Compliance and governance controls</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#partner-integrations","title":"Partner Integrations","text":"<p>Enable third-party developers to create and distribute agents:</p> <ul> <li>Ecosystem growth</li> <li>Specialized solutions</li> <li>Revenue sharing opportunities</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#troubleshooting","title":"Troubleshooting","text":""},{"location":"n-encyclopedia/system-scoped-agents/#authorization-errors","title":"Authorization Errors","text":"<p>Problem: Deployment fails with authorization error</p> <p>Solution: Ensure the API key used belongs to a system administrator. Regular user API keys cannot deploy system-scoped agents.</p>"},{"location":"n-encyclopedia/system-scoped-agents/#json-parsing-errors","title":"JSON Parsing Errors","text":"<p>Problem: OnboardingJson fails to parse</p> <p>Solution:</p> <ul> <li>Validate your JSON using a JSON validator</li> <li>Ensure all strings are properly escaped (use <code>@\"\"</code> verbatim strings in C#)</li> <li>Check for missing commas or brackets</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#workflow-steps-not-executing","title":"Workflow Steps Not Executing","text":"<p>Problem: Onboarding steps don't execute as expected</p> <p>Solution:</p> <ul> <li>Verify the <code>step</code> field contains valid values (\"knowledge\", \"activate\")</li> <li>Ensure the <code>value</code> field matches the expected type for each step</li> <li>Check that agent names in \"activate\" steps match actual deployed agents</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#security-considerations","title":"Security Considerations","text":"<ul> <li>Access Control: Only system administrators can create system-scoped agents</li> <li>Tenant Isolation: Each tenant's instance is completely isolated</li> <li>Configuration Validation: Validate all user-provided configuration during onboarding</li> <li>API Key Management: Protect system administrator API keys</li> <li>Version Control: Track and audit agent template changes</li> </ul>"},{"location":"n-encyclopedia/system-scoped-agents/#see-also","title":"See Also","text":"<ul> <li>Deployment Options</li> <li>Agent Configuration</li> <li>Multi-Flow Agents</li> <li>Scaling Agents</li> </ul>"},{"location":"n-encyclopedia/unit-testing-activities/","title":"Unit Testing Activities","text":""},{"location":"n-encyclopedia/unit-testing-activities/#overview","title":"Overview","text":"<p>This guide explains how to effectively unit test activities using local knowledge for development.</p>"},{"location":"n-encyclopedia/unit-testing-activities/#setting-up-local-knowledge","title":"Setting Up Local Knowledge","text":"<p>During development, it's often more efficient to use local knowledge rather than fetching it from Xians portal. This approach speeds up development and testing cycles. Here's how to set it up:</p> <ol> <li>Create a local knowledge folder (e.g., <code>knowledge</code>)</li> <li>Store your knowledge files in this folder</li> <li>Set the environment variable in your tests:</li> </ol> <pre><code>Environment.SetEnvironmentVariable(\"LOCAL_INSTRUCTIONS_FOLDER\", \"/path/to/knowledge\");\n</code></pre>"},{"location":"n-encyclopedia/unit-testing-activities/#file-matching","title":"File Matching","text":"<p>The file matching is done by the name of the file excluding the file extension.</p> <p>Example:</p> <ul> <li><code>ExampleProject.Knowledge/SalesMeeting.md</code> will match instructions named <code>SalesMeeting</code></li> <li><code>ExampleProject.Knowledge/Sales Meeting.md</code> will match instructions named <code>Sales Meeting</code></li> <li><code>ExampleProject.Knowledge/My Sales Meeting.txt</code> will match instructions named <code>My Sales Meeting</code></li> </ul>"},{"location":"n-encyclopedia/unit-testing-activities/#test-structure-example","title":"Test Structure Example","text":"<p>Here's a typical structure for activity unit tests where we use local knowledge folder:</p> <p>Knowledge folder in the root of the test project: <code>ExampleProject.Knowledge</code></p> <pre><code>public class ExampleActivityTests\n{\n    private readonly ExampleActivity _activity;\n    private readonly string _projectRoot;\n\n    public ExampleActivityTests()\n    {\n        // Setup project root path\n        _projectRoot = Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"..\", \"..\", \"..\"));\n\n        // Load environment variables\n        DotNetEnv.Env.Load(Path.Combine(_projectRoot, \"..\", \".env\"));\n\n        // *** Configure local knowledge ***\n        var knowledgeFolder = Path.Combine(_projectRoot, \"..\", \"ExampleProject.Knowledge\");\n        Environment.SetEnvironmentVariable(\"LOCAL_INSTRUCTIONS_FOLDER\", knowledgeFolder);\n\n        // Initialize activity\n        _activity = new ExampleActivity();\n    }\n\n    [Fact]\n    public async Task ActivityMethod_Scenario_ExpectedBehavior()\n    {\n        // Arrange\n        var input = new InputModel\n        {\n            Property1 = \"value1\",\n            Property2 = \"value2\"\n        };\n\n        // Act\n        var result = await _activity.MethodUnderTest(input);\n\n        // Assert\n        Assert.True(result.Success);\n        Assert.Equal(expectedValue, result.Output);\n    }\n}\n</code></pre>"},{"location":"n-encyclopedia/unit-testing-activities/#running-tests","title":"Running Tests","text":"<ul> <li>Use test filters to run specific tests:</li> </ul> <pre><code>dotnet test --filter \"FullyQualifiedName=Namespace.TestClass.TestMethod\"\n</code></pre> <ul> <li>OR run all tests in the test class:</li> </ul> <pre><code>dotnet test\n</code></pre>"},{"location":"n-encyclopedia/unit-testing/","title":"Unit Testing Xians Router Capabilities","text":"<p>This guide covers how to unit test capabilities that use the Xians semantic router framework.</p>"},{"location":"n-encyclopedia/unit-testing/#test-class-setup","title":"Test Class Setup","text":""},{"location":"n-encyclopedia/unit-testing/#required-imports","title":"Required Imports","text":"<pre><code>using AgentTools;\nusing DotNetEnv;\nusing Server;\nusing System.Reflection;\nusing XiansAi.Flow;\nusing XiansAi.Flow.Router;\n</code></pre>"},{"location":"n-encyclopedia/unit-testing/#environment-variables-context-setup","title":"Environment Variables &amp; Context Setup","text":"<pre><code>public class MyCapabilitiesTests\n{\n    /// &lt;summary&gt;\n    /// Run with: dotnet test --filter \"FullyQualifiedName~MyCapabilitiesTests\"\n    /// &lt;/summary&gt;\n    static MyCapabilitiesTests()\n    {\n        // Load environment variables once for the entire test suite\n        var assemblyLocation = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\n        var projectRoot = Path.GetFullPath(Path.Combine(assemblyLocation!, \"..\", \"..\", \"..\", \"..\"));\n        var envPath = Path.Combine(projectRoot, \".env\");\n        Env.Load(envPath);\n\n        // Set agent context for testing\n        AgentContext.SetLocalContext(\"test-user\", \"test-tenant:test-agent:test-workflow\");\n        AgentContext.RouterOptions = new RouterOptions {\n            ProviderName = \"openai\",\n            ApiKey = Env.GetString(\"OPENAI_API_KEY\"),\n            ModelName = \"gpt-4o-mini\",\n        };\n\n        // Create agent and add capabilities\n        var agent = new AgentTeam(\"TestAgent\");\n\n        // Add web bot with capabilities\n        var webBot = agent.AddAgent&lt;WebBot&gt;(numberOfWorkers: 3);\n        webBot.AddCapabilities(typeof(MyCapability));\n        webBot.AddCapabilities(typeof(FirecrawlCapability));\n        webBot.AddCapabilities(typeof(GoogleSearchCapability));\n        webBot.AddKernelModifier(new PlayWrightMCP());\n\n        // Add reporter bot with kernel modifiers\n        var reporterBot = agent.AddAgent&lt;ReporterBot&gt;();\n        reporterBot.AddKernelModifier(new MicrosoftO365MCP());\n        reporterBot.AddKernelModifier(new PdfGeneratorMCP());\n    }\n}\n</code></pre>"},{"location":"n-encyclopedia/unit-testing/#environment-configuration","title":"Environment Configuration","text":""},{"location":"n-encyclopedia/unit-testing/#required-env-variables","title":"Required .env Variables","text":"<pre><code>LOCAL_KNOWLEDGE_FOLDER=./local_knowledge  # Reduces server dependencies\n...\n</code></pre> <p>Benefits of LOCAL_KNOWLEDGE_FOLDER is that it reduces external server dependencies during testing. See Local Development for more details.</p>"},{"location":"n-encyclopedia/unit-testing/#test-categories","title":"Test Categories","text":""},{"location":"n-encyclopedia/unit-testing/#unit-tests","title":"Unit Tests","text":"<pre><code>/// &lt;summary&gt;\n/// Run with: dotnet test --filter \"FullyQualifiedName~MyMethod_WithValidInput_ShouldReturnExpectedOutput\"\n/// &lt;/summary&gt;\n[Theory]\n[Trait(\"Category\", \"Unit\")]\n[InlineData(\"test input\", \"expected output\")]\npublic async Task MyMethod_WithValidInput_ShouldReturnExpectedOutput(string input, string expected)\n{\n    // Act\n    var result = await new MyCapabilities().MyMethod(input);\n\n    // Assert\n    Assert.Equal(expected, result);\n}\n</code></pre>"},{"location":"n-encyclopedia/unit-testing/#integration-tests","title":"Integration Tests","text":"<p>Integration tests require API keys and network access to external services:</p> <pre><code>/// &lt;summary&gt;\n/// Run with: dotnet test --filter \"FullyQualifiedName~MyIntegrationMethod_WithValidInput_ShouldReturnExpectedResult\"\n/// &lt;/summary&gt;\n[Theory]\n[Trait(\"Category\", \"Integration\")]\n[InlineData(\"https://example.com\", \"Expected Company\")]\npublic async Task MyIntegrationMethod_WithValidInput_ShouldReturnExpectedResult(string url, string expectedCompany)\n{\n    // Act\n    var result = await new MyCapabilities().MyIntegrationMethod(new Uri(url));\n\n    // Assert\n    Assert.Equal(expectedCompany, result);\n\n    // Additional assertions for integration tests\n    Assert.NotNull(result);\n    Assert.NotEmpty(result);\n\n    Console.WriteLine($\"Result: {result}\");\n}\n</code></pre>"},{"location":"n-encyclopedia/unit-testing/#testing-agent-to-agent-communication","title":"Testing Agent-to-Agent Communication","text":"<p>Agent2Agent chat message passing works seamlessly in unit tests when both agents are in the same .NET process. No special configuration needed.</p> <pre><code>public class MyCapabilities\n{\n    [Capability(\"Determine if a company is a software product company (ISV) and is a small or medium enterprise (SME)\")]\n    [Parameter(\"companyWebsite\", \"Website of the company to determine if it is a software product company (ISV)\")]\n    [Returns(\"True if the company is a software product company (ISV), false otherwise\")]\n    public async Task&lt;bool&gt; IsSMEProductCompany(Uri companyWebsite) \n    {\n        var instruction = @$\"\n            Url: {companyWebsite}\n            Read the content of the above url and return the content in markdown format.\n            Return the content in English.\n            Do not return any other text.\n            First try/retry with scraping tools. If fails try web automation tools. If still fails return text 'ERROR: &lt;reason&gt;'.\n        \";\n\n        // Call WebBot Agent to extract the content\n        var siteContent = await MessageHub.Agent2Agent.SendChat(typeof(WebBot), instruction);\n        if (string.IsNullOrEmpty(siteContent.Text) || siteContent.Text.StartsWith(\"ERROR\"))\n        {\n            throw new Exception($\"Error occurred in reading page content from: {companyWebsite}: {siteContent.Text}\");\n        }\n\n        return await IsSMEProductCompany(siteContent.Text);\n    }\n}\n</code></pre>"},{"location":"n-encyclopedia/unit-testing/#test-cleanup-and-file-management","title":"Test Cleanup and File Management","text":"<p>For tests that create temporary files, always use proper cleanup:</p> <pre><code>[Theory]\n[Trait(\"Category\", \"Unit\")]\n[InlineData(\"# Test Content\")]\npublic async Task SaveAsMarkdown_WithValidContent_ShouldCreateFile(string content)\n{\n    string? filePath = null;\n\n    try\n    {\n        // Act\n        filePath = await new MyCapabilities().SaveAsMarkdown(content);\n\n        // Assert\n        Assert.NotNull(filePath);\n        Assert.True(File.Exists(filePath));\n        Assert.EndsWith(\".md\", filePath);\n\n        var savedContent = await File.ReadAllTextAsync(filePath);\n        Assert.Equal(content, savedContent);\n    }\n    finally\n    {\n        // Clean up: Delete the created file\n        if (filePath != null &amp;&amp; File.Exists(filePath))\n        {\n            File.Delete(filePath);\n        }\n    }\n}\n</code></pre>"},{"location":"n-encyclopedia/unit-testing/#running-tests","title":"Running Tests","text":"<pre><code># Run entire test class\ndotnet test --filter \"FullyQualifiedName~MyCapabilitiesTests\"\n\n# Run specific test method\ndotnet test --filter \"FullyQualifiedName~MyMethod_WithValidInput_ShouldReturnExpectedOutput\"\n\n# Run by category\ndotnet test --filter \"Category=Unit\"\ndotnet test --filter \"Category=Integration\"\n\n# Run with console output for debugging\ndotnet test --filter \"FullyQualifiedName~MyMethod_WithValidInput\" --logger \"console;verbosity=detailed\"\n</code></pre>"},{"location":"n-encyclopedia/unit-testing/#key-changes-from-previous-setup","title":"Key Changes from Previous Setup","text":"<ol> <li>RouterOptions moved to AgentContext: Router options are now set globally on <code>AgentContext.RouterOptions</code> instead of being passed to capability constructors</li> <li>Static constructor setup: All agent and bot initialization happens once in the static constructor</li> <li>No constructor parameters: Capability classes no longer need RouterOptions constructor parameters</li> <li>Enhanced bot setup: More comprehensive bot configuration with multiple capabilities and kernel modifiers</li> <li>Better test organization: Clear separation between Unit and Integration test categories with appropriate traits</li> </ol>"},{"location":"n-encyclopedia/user-auth-config/","title":"OIDC Authentication Configuration","text":"<p>Configure OpenID Connect (OIDC) authentication per tenant. These settings are encrypted at rest and enforced at runtime for both REST and WebSocket endpoints.</p>"},{"location":"n-encyclopedia/user-auth-config/#authentication-priority","title":"Authentication Priority","text":"<p>Important: When both an API key and JWT token are provided in a request, the system gives priority to the API key. The JWT token will be ignored in favor of API key authentication.</p> <p>This means:</p> <ul> <li>If you provide both <code>apikey</code> parameter and <code>Authorization: Bearer &lt;jwt-token&gt;</code> header, the API key takes precedence</li> <li>JWT token validation (configured below) only applies when no API key is present</li> <li>For API key generation and management, see Portal \u2192 Settings \u2192 API Keys</li> </ul>"},{"location":"n-encyclopedia/user-auth-config/#jwt-token-participant-validation","title":"JWT Token Participant Validation","text":"<p>Important: When using JWT token authentication, the system validates that the <code>participantId</code> sent in the request matches the user identity extracted from the token using <code>userIdClaim(s)</code>.</p>"},{"location":"n-encyclopedia/user-auth-config/#how-it-works","title":"How it works","text":"<ol> <li>User Identity Extraction: The system extracts the user identity from the JWT token using the configured <code>userIdClaim</code> or <code>userIdClaims</code> settings</li> <li>If <code>userIdClaim</code> is specified: uses that single claim (e.g., <code>\"sub\"</code>)</li> <li>If <code>userIdClaims</code> is specified: tries claims in order until one is found (e.g., <code>\"sub,email\"</code> tries <code>sub</code> first, then <code>email</code>)</li> <li> <p>If neither is configured: defaults to standard claims like <code>sub</code> or <code>oid</code></p> </li> <li> <p>Participant Validation: The extracted user identity must exactly match the <code>participantId</code> parameter sent in the request</p> </li> <li> <p>Authentication Failure: If the <code>participantId</code> doesn't match the token's user identity, authentication will fail</p> </li> </ol>"},{"location":"n-encyclopedia/user-auth-config/#example","title":"Example","text":"<p>If your JWT token contains <code>\"sub\": \"user123@company.com\"</code> and you configure:</p> <pre><code>\"providerSpecificSettings\": {\n  \"userIdClaim\": \"sub\"\n}\n</code></pre> <p>Then your API requests must use <code>participantId=user123@company.com</code>, otherwise authentication will fail.</p> <p>Note: This validation only applies when JWT tokens are used for authentication (not when API keys are used).</p>"},{"location":"n-encyclopedia/user-auth-config/#where-to-configure","title":"Where to configure","text":"<ul> <li>Portal \u2192 Settings \u2192 Auth config (per tenant)</li> <li>Providers per tenant: minimum 1, maximum 5</li> <li>Config is stored encrypted</li> </ul>"},{"location":"n-encyclopedia/user-auth-config/#prerequisites","title":"Prerequisites","text":"<p>In your Xians AI server environment (if not already set), configure the encryption keys before saving any auth config in the portal:</p> <pre><code>{\n  \"EncryptionKeys\": {\n    \"BaseSecret\": \"&lt;LONG_RANDOM_BASE_SECRET&gt;\",\n    \"UniqueSecrets\": {\n      \"TenantOidcSecretKey\": \"&lt;LONG_RANDOM_UNIQUE_SECRET_FOR_TENANT_OIDC&gt;\"\n    }\n  }\n}\n</code></pre> <pre><code>EncryptionKeys__BaseSecret=&lt;LONG_RANDOM_BASE_SECRET&gt;\nEncryptionKeys__UniqueSecrets__ConversationMessageKey=mysecretkey2\nEncryptionKeys__UniqueSecrets__TenantOidcSecretKey=&lt;LONG_RANDOM_UNIQUE_SECRET_FOR_TENANT_OIDC&gt;\n</code></pre>"},{"location":"n-encyclopedia/user-auth-config/#quick-start-xians-ai-portal","title":"Quick start (Xians ai Portal)","text":"<ol> <li>Open your tenant \u2192 Settings \u2192 Auth config</li> <li>Click on Create configuration</li> <li>Edit the JSON template that appear and adjust the values for your identity providers</li> <li>Start with one provider, verify login, then add others if needed</li> <li>Keep <code>allowedProviders</code> minimal to explicitly whitelist providers</li> <li><code>issue</code> is mandatory for each provider and you can put <code>null</code> for other attributes if not needed.</li> </ol>"},{"location":"n-encyclopedia/user-auth-config/#recommended-json-template-secure-defaults","title":"Recommended JSON template (secure defaults)","text":"<p>Use this as a starting point. Replace placeholders with your values. Provider keys (<code>Auth0</code>, <code>Keycloak</code>, etc.) are identifiers you choose. If you set <code>allowedProviders</code>, only those keys can be used.</p> <p>Example:</p> <pre><code>{\n  \"tenantId\": \"99x.io\",\n  \"allowedProviders\": [\n    \"Auth0\",\n    \"Keycloak\",\n    \"AzureB2C\",\n    \"Google\"\n  ],\n  \"providers\": {\n    \"Auth0\": {\n      \"authority\": \"https://your-tenant.auth0.com/\",\n      \"issuer\": \"https://your-tenant.auth0.com/\",\n      \"expectedAudience\": [\n        \"https://api.yourapp.com\"\n      ],\n      \"scope\": \"openid profile email\",\n      \"requireSignedTokens\": true,\n      \"acceptedAlgorithms\": [\"RS256\"],\n      \"requireHttpsMetadata\": true,\n      \"additionalClaims\": [\n        { \"claim\": \"email_verified\", \"op\": \"equals\", \"value\": true },\n        { \"claim\": \"aud\", \"op\": \"equals\", \"value\": \"https://api.yourapp.com\" }\n      ],\n      \"providerSpecificSettings\": {\n        \"userIdClaim\": \"sub\"\n      }\n    },\n    \"Keycloak\": {\n      \"authority\": null,\n      \"issuer\": \"http://localhost:18080/realms/xiansai\",\n      \"expectedAudience\": [\"xiansai-api\"],\n      \"scope\": \"openid profile email\",\n      \"requireSignedTokens\": true,\n      \"acceptedAlgorithms\": [\"RS256\"],\n      \"requireHttpsMetadata\": false,\n      \"additionalClaims\": [\n        { \"claim\": \"azp\", \"op\": \"equals\", \"value\": \"xiansai-client\" },\n        { \"claim\": \"groups\", \"op\": \"contains\", \"value\": \"xians-admins\" }\n      ],\n      \"providerSpecificSettings\": {\n        \"userIdClaims\": \"sub,email\"\n      }\n    },\n    \"AzureB2C\": {\n      \"authority\": \"https://login.microsoftonline.com/your-tenant-id/v2.0\",\n      \"issuer\": \"https://sts.windows.net/your-tenant-id/\",\n      \"expectedAudience\": [\n        \"api://774af795-bae0-42cb-b10f-1bff6e15c3c4\"\n      ],\n      \"scope\": \"openid profile email\",\n      \"requireSignedTokens\": true,\n      \"acceptedAlgorithms\": [\"RS256\"],\n      \"requireHttpsMetadata\": true,\n      \"additionalClaims\": [\n        { \"claim\": \"tid\", \"op\": \"equals\", \"value\": \"your-tenant-id\" },\n        { \"claim\": \"scp\", \"op\": \"contains\", \"value\": \"access_as_user\" }\n      ],\n      \"providerSpecificSettings\": {\n        \"userIdClaims\": \"oid,sub\"\n      }\n    },\n    \"Google\": {\n      \"authority\": \"https://accounts.google.com\",\n      \"issuer\": \"https://accounts.google.com\",\n      \"expectedAudience\": [\n        \"your-google-client-id.apps.googleusercontent.com\"\n      ],\n      \"scope\": \"openid email profile\",\n      \"requireSignedTokens\": true,\n      \"acceptedAlgorithms\": [\"RS256\"],\n      \"requireHttpsMetadata\": true,\n      \"additionalClaims\": [\n        { \"claim\": \"email_verified\", \"op\": \"equals\", \"value\": true },\n        { \"claim\": \"hd\", \"op\": \"equals\", \"value\": \"yourcompany.com\" }\n      ],\n      \"providerSpecificSettings\": {\n        \"userIdClaims\": \"sub,email\"\n      }\n    }\n  },\n  \"notes\": \"Configure 1\u20135 OIDC providers per tenant. Strongly prefer RS256, strict issuer, and audience checks.\"\n}\n</code></pre>"},{"location":"n-encyclopedia/user-auth-config/#field-reference","title":"Field reference","text":"<ul> <li>tenantId: Must exactly match the tenant id for which you\u2019re configuring auth</li> <li>allowedProviders: Optional list of provider keys allowed for this tenant. If set, only these keys may be used</li> <li>providers: A map of provider key \u2192 rule object</li> <li>authority: Base URL used for OIDC discovery. If omitted, <code>issuer</code> (or token <code>iss</code>) is used</li> <li>issuer: Exact issuer that tokens must match. Required by service constraints</li> <li>expectedAudience: List of allowed audiences. If provided, audience validation is enforced</li> <li>scope: Space-separated scopes required to be present (checked against <code>scope</code> or <code>scp</code>)</li> <li>requireSignedTokens: Defaults to true. Determines if signature validation is required</li> <li>acceptedAlgorithms: Restrict signing algorithms (e.g., <code>[\"RS256\"]</code>)</li> <li>requireHttpsMetadata: Defaults to true. Only set to false for local/dev identity servers</li> <li>additionalClaims: Extra per-claim checks. See syntax below</li> <li>providerSpecificSettings:<ul> <li><code>userIdClaim</code>: Single claim to use for the canonical user id when <code>sub</code>/<code>oid</code> are not present</li> <li><code>userIdClaims</code>: Comma-separated preference list (e.g., <code>\"sub,email\"</code>)</li> </ul> </li> </ul>"},{"location":"n-encyclopedia/user-auth-config/#additionalclaims-syntax","title":"additionalClaims syntax","text":"<p>Each entry enforces an operation against a single claim value.</p> <pre><code>{ \"claim\": \"&lt;claim-name&gt;\", \"op\": \"equals|not_equals|contains\", \"value\": &lt;string|number|boolean|array&gt; }\n</code></pre> <p>Notes:</p> <ul> <li> <p><code>value</code> may be a string/number/boolean or an array of those. Arrays are evaluated as:</p> </li> <li> <p><code>equals</code>: token value must equal any of the provided values</p> </li> <li><code>not_equals</code>: token value must equal none of the provided values</li> <li> <p><code>contains</code>: token value string must contain any of the provided values</p> </li> <li> <p>Comparisons are ordinal (case-sensitive). Provide exact expected casing</p> </li> </ul>"},{"location":"n-encyclopedia/user-auth-config/#security-recommendations","title":"Security recommendations","text":"<ul> <li>Keep <code>requireHttpsMetadata: true</code> (except local development)</li> <li>Always set <code>issuer</code> to the exact expected value (copy from discovery document)</li> <li>Set <code>acceptedAlgorithms</code> to <code>[\"RS256\"]</code> (or your provider\u2019s strongest asymmetric alg)</li> <li>Provide <code>expectedAudience</code> (and require proper <code>aud</code>)</li> <li>Use <code>scope</code> to require precise scopes minimally needed</li> <li> <p>Add <code>additionalClaims</code> for tenant/org enforcement. Examples:</p> </li> <li> <p>Azure AD/B2C: <code>{ \"claim\": \"tid\", \"op\": \"equals\", \"value\": \"&lt;tenant-guid&gt;\" }</code></p> </li> <li>Google Workspace: <code>{ \"claim\": \"hd\", \"op\": \"equals\", \"value\": \"yourcompany.com\" }</code></li> <li>Auth0 organization: <code>{ \"claim\": \"org_id\", \"op\": \"equals\", \"value\": \"&lt;org-id&gt;\" }</code></li> <li>Keycloak groups: <code>{ \"claim\": \"groups\", \"op\": \"contains\", \"value\": \"&lt;required-group&gt;\" }</code></li> </ul>"},{"location":"n-encyclopedia/user-auth-config/#constraints-and-validation","title":"Constraints and validation","text":"<ul> <li>Providers: minimum 1, maximum 5</li> <li>Each configured provider must include a non-empty <code>issuer</code></li> <li><code>tenantId</code> in JSON must match the tenant path/selection in the UI</li> <li>If <code>allowedProviders</code> is set, only those keys can be selected/used for this tenant</li> </ul>"},{"location":"n-encyclopedia/user-auth-config/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>\"The encryption keys may have changed. Please reconfigure\u2026\": Your app\u2019s encryption keys changed; re-save the config in UI</li> <li>\"Provider not allowed for tenant\": The provider key is not listed in <code>allowedProviders</code></li> <li>\"No OIDC providers configured for tenant\": Add at least one entry under <code>providers</code></li> <li>\"Signing algorithm not allowed\": Ensure the token\u2019s <code>alg</code> is present in <code>acceptedAlgorithms</code> or remove the restriction</li> <li>\"Required scope missing\": Ensure the token has the scopes listed in <code>scope</code></li> </ul>"},{"location":"n-encyclopedia/user-auth-config/#minimal-example","title":"Minimal example","text":"<pre><code>{\n  \"tenantId\": \"acme.io\",\n  \"providers\": {\n    \"Auth0\": {\n      \"issuer\": \"https://acme.auth0.com/\",\n      \"expectedAudience\": [\"https://api.acme.io\"],\n      \"requireSignedTokens\": true,\n      \"acceptedAlgorithms\": [\"RS256\"],\n      \"requireHttpsMetadata\": true,\n      \"additionalClaims\": [\n        { \"claim\": \"email_verified\", \"op\": \"equals\", \"value\": true }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"n-encyclopedia/user-auth-config/#authorization-model-and-risks","title":"Authorization model and risks","text":"<p>Important: The system performs stateless, per-request validation of JWTs. It does not persist end users in a database or maintain server-side user sessions, and there is no centralized, strict role-based authorization for end users in the User API beyond what their token and your tenant rules enforce. Therefore:</p> <ul> <li>If you do not configure restrictive rules for your tenant, anyone with a valid token from a listed provider that matches minimal checks could gain access to eligible endpoints</li> <li>You must explicitly constrain access with strong, tenant-specific rules in this config</li> </ul> <p>Recommended hardening steps:</p> <ul> <li>Pin issuer and require HTTPS metadata (prod): set <code>issuer</code> precisely and keep <code>requireHttpsMetadata: true</code></li> <li>Restrict signing algorithms: set <code>acceptedAlgorithms</code> to <code>[\"RS256\"]</code> and keep <code>requireSignedTokens: true</code></li> <li>Enforce audience and scope: set <code>expectedAudience</code> and <code>scope</code> and ensure client apps request only the minimal necessary scopes</li> <li> <p>Lock to your organization/tenant (examples):</p> </li> <li> <p>Azure AD/B2C: <code>tid</code> equals your tenant GUID</p> </li> <li>Auth0: <code>org_id</code> equals your organization id (if used)</li> <li>Google Workspace: <code>hd</code> equals your domain (e.g., <code>yourcompany.com</code>)</li> <li>Keycloak: <code>groups</code> contains a required group (e.g., <code>xians-admins</code>)</li> <li>Constrain clients: require <code>azp</code> (authorized party) equals your expected client id</li> <li>Prefer canonical user ids from stable claims (<code>sub</code>, <code>oid</code>) and, if needed, set <code>providerSpecificSettings.userIdClaim(s)</code></li> <li>Keep <code>allowedProviders</code> minimal; avoid listing providers you do not actively use</li> </ul>"},{"location":"n-encyclopedia/wf-best-practices/","title":"Workflow Best Practices","text":"<p>Agent flows are essentially Temporal workflows. Therefore usual Temporal workflow best practices apply.</p>"},{"location":"n-encyclopedia/wf-best-practices/#determinism","title":"Determinism","text":"<p>Workflows should be deterministic. This means that the workflow should always produce the same output for the same input.</p>"},{"location":"n-encyclopedia/wf-best-practices/#maintaining-determinism","title":"Maintaining Determinism","text":"<p>To maintain determinism in workflows, follow these key principles:</p>"},{"location":"n-encyclopedia/wf-best-practices/#use-temporal-apis-for-non-deterministic-operations","title":"Use Temporal APIs for Non-Deterministic Operations","text":"<ul> <li>Always use Temporal's built-in APIs for time-based operations, random numbers, and external data access</li> <li>Never use system time, random functions, or direct external calls in workflow code</li> <li>Temporal APIs ensure these operations are recorded in the event history</li> </ul>"},{"location":"n-encyclopedia/wf-best-practices/#avoid-code-changes-during-execution","title":"Avoid Code Changes During Execution","text":"<ul> <li>Once a workflow execution starts, avoid modifying its code</li> <li>Use workflow versioning for planned changes</li> <li>Implement new features through new activities rather than modifying existing workflow code</li> </ul>"},{"location":"n-encyclopedia/wf-best-practices/#handle-versioning-properly","title":"Handle Versioning Properly","text":"<ul> <li>Use workflow patching APIs for backward compatibility</li> <li>Consider worker build ID-based versioning for major changes</li> <li>Plan versioning strategy for long-running workflows</li> </ul>"},{"location":"n-encyclopedia/wf-best-practices/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<ul> <li>Don't use system time or random functions directly</li> <li>Avoid branching based on external state</li> <li>Don't modify workflow code while executions are running</li> <li>Never use non-deterministic libraries or functions</li> </ul> <p>Example of incorrect (non-deterministic) code:</p> <pre><code>// Bad: Using system time directly\nif (new Date().getHours() &lt; 12) {\n    await activities.morningTask();\n} else {\n    await activities.afternoonTask();\n}\n</code></pre> <p>Example of correct (deterministic) code:</p> <pre><code>// Good: Using Temporal's time API\nconst currentTime = await workflow.getCurrentTime();\nif (currentTime.getHours() &lt; 12) {\n    await activities.morningTask();\n} else {\n    await activities.afternoonTask();\n}\n</code></pre> <p>Read more about determinism in the Temporal documentation.</p>"},{"location":"n-encyclopedia/wf-best-practices/#development-best-practices","title":"Development Best Practices","text":""},{"location":"n-encyclopedia/wf-best-practices/#1-minimize-business-logic-in-workflows","title":"1. Minimize Business Logic in Workflows","text":"<ul> <li>Keep workflow code focused on orchestration only</li> <li>Delegate all business logic to activities</li> <li>Ensure workflows remain deterministic</li> <li>Use workflows primarily for coordination and flow control</li> </ul> <p>Example:</p> <pre><code>// Good: Workflow only handles orchestration\nasync function paymentWorkflow(paymentId: string) {\n    // Orchestration only\n    const status = await activities.initiatePayment(paymentId);\n    await activities.logPayment(paymentId, status);\n}\n</code></pre>"},{"location":"n-encyclopedia/wf-best-practices/#2-design-activities-for-business-logic","title":"2. Design Activities for Business Logic","text":"<ul> <li>Activities can contain complex business logic</li> <li>Activity code changes don't impact workflow determinism</li> <li>Activities execute outside workflow's replay scope</li> <li>Changes to activity implementation don't require workflow migration</li> </ul>"},{"location":"n-encyclopedia/wf-best-practices/#3-use-objects-for-arguments","title":"3. Use Objects for Arguments","text":"<ul> <li>Avoid passing primitive arguments directly</li> <li>Use structured objects for workflow and activity parameters</li> <li>Allows for future parameter additions without breaking changes</li> </ul> <p>Example:</p> <pre><code>interface PaymentRequest {\n    paymentId: string;\n    amount: number;\n    currency: string;\n    // Extensible for future fields\n}\n</code></pre>"},{"location":"n-encyclopedia/wf-best-practices/#4-keep-activities-atomic","title":"4. Keep Activities Atomic","text":"<ul> <li>Each activity should perform exactly one task</li> <li>Prevents unintended side effects during retries</li> <li>Separates concerns for better error handling</li> <li>Makes activities more reusable</li> </ul> <p>Example:</p> <pre><code>// Good: Separate atomic activities\nasync function handlePayment(request: PaymentRequest) {\n    await callPaymentAPI(request);\n}\n\nasync function logPayment(request: PaymentRequest) {\n    await logToDatabase(request);\n}\n</code></pre>"},{"location":"n-encyclopedia/wf-best-practices/#5-handle-large-data-efficiently","title":"5. Handle Large Data Efficiently","text":"<ul> <li>Avoid passing large data between activities</li> <li>Use storage systems for large datasets</li> <li>Pass references (like storage keys) instead of full data</li> <li>Consider chunking large data processing</li> </ul> <p>Example:</p> <pre><code>// Good: Using storage reference\nasync function processLargeDataset(storageKey: string) {\n    const dataChunk = await loadFromStorage(storageKey);\n    await activities.processDataChunk(dataChunk);\n}\n</code></pre>"},{"location":"n-encyclopedia/wf-best-practices/#6-prefer-activities-over-child-workflows","title":"6. Prefer Activities Over Child Workflows","text":"<ul> <li>Use activities to start new workflows instead of child workflows</li> <li>Child workflows may have limitations with reset features</li> <li>Activities provide better control and visibility</li> </ul>"},{"location":"n-encyclopedia/wf-best-practices/#7-plan-for-new-features","title":"7. Plan for New Features","text":"<ul> <li>Introduce new functionality as new activities</li> <li>Avoid nested patching in workflow code</li> <li>Deprecate patches in future versions</li> <li>Keep workflow code clean and maintainable</li> </ul>"},{"location":"n-encyclopedia/wf-best-practices/#8-error-handling-and-retries","title":"8. Error Handling and Retries","text":"<ul> <li>Implement proper retry policies for activities</li> <li>Handle transient failures appropriately</li> <li>Consider idempotency in activity design</li> <li>Use compensation logic when needed</li> </ul>"},{"location":"n-encyclopedia/wf-best-practices/#9-testing-and-monitoring","title":"9. Testing and Monitoring","text":"<ul> <li>Test activities independently</li> <li>Verify workflow orchestration logic</li> <li>Monitor activity execution times</li> </ul> <p>Remember that these practices help ensure your agent flows remain scalable, maintainable, and resilient. The focus should be on keeping workflows simple and deterministic while delegating complex business logic to activities.</p>"},{"location":"n-encyclopedia/workflow-identification-utility/","title":"Workflow Identification Utility (<code>WorkflowIdentifier</code>)","text":"<p>A guide to construct and parse workflow names/IDs in Agents.</p>"},{"location":"n-encyclopedia/workflow-identification-utility/#formats","title":"Formats","text":"<ul> <li>Workflow Type: <code>AgentName:FlowName</code></li> <li>Workflow ID (no postfix): <code>TenantId:AgentName:FlowName</code></li> <li>Workflow ID (with postfix): <code>TenantId:AgentName:FlowName:IdPostfix</code></li> </ul>"},{"location":"n-encyclopedia/workflow-identification-utility/#quick-usage","title":"Quick usage","text":"<pre><code>// From a full Workflow ID (validates tenant prefix)\nvar wi1 = new WorkflowIdentifier(\"tenant:My Agent v1.3.1:Router Bot:123\");\nwi1.WorkflowId;   // \"tenant:My Agent v1.3.1:Router Bot:123\"\nwi1.WorkflowType; // \"My Agent v1.3.1:Router Bot\"\nwi1.AgentName;    // \"My Agent v1.3.1\"\n\n// From a Workflow Type (auto-builds an ID without postfix)\nvar wi2 = new WorkflowIdentifier(\"My Agent v1.3.1:Router Bot\");\nwi2.WorkflowId;   // \"tenant:My Agent v1.3.1:Router Bot\"\nwi2.WorkflowType; // \"My Agent v1.3.1:Router Bot\"\nwi2.AgentName;    // \"My Agent v1.3.1\"\n\n// Static helpers\nWorkflowIdentifier.GetWorkflowId(\"My Agent v1.3.1:Router Bot\"); \nWorkflowIdentifier.GetWorkflowType(\"tenant:My Agent v1.3.1:Router Bot:123\"); // \"My Agent v1.3.1:Router Bot\"\n\n// Note: GetAgentName expects a workflow type. If you pass a full ID,\n// it returns the first segment (the tenant).\nWorkflowIdentifier.GetAgentName(\"My Agent v1.3.1:Router Bot\"); // \"My Agent v1.3.1\"\nWorkflowIdentifier.GetAgentName(\"tenant:My Agent v1.3.1:Router Bot\"); // \"tenant\"\n</code></pre>"},{"location":"n-encyclopedia/workflow-identification-utility/#with-typed-flows-workflowname","title":"With typed flows (<code>[Workflow(Name = ...)]</code>)","text":"<pre><code>using Temporalio.Workflows;\n\n[Workflow(Name = \"My Agent v1.3.1:Router Bot\")]\npublic class RouterBotFlow {}\n\nWorkflowIdentifier.GetWorkflowTypeFor(typeof(RouterBotFlow));\n// =&gt; \"My Agent v1.3.1:Router Bot\"\n\nWorkflowIdentifier.GetSingletonWorkflowIdFor(typeof(RouterBotFlow));\n// =&gt; \"{TenantId}:My Agent v1.3.1:Router Bot\"\n\nWorkflowIdentifier.GetWorkflowIdFor(typeof(RouterBotFlow), Guid.NewGuid().ToString());\n// =&gt; \"{TenantId}:My Agent v1.3.1:Router Bot:{postfix}\"\n</code></pre>"},{"location":"n-encyclopedia/workflow-identification-utility/#pitfalls","title":"Pitfalls","text":"<ul> <li>Tenant validation: Passing a full ID with the wrong <code>tenantId</code> throws.</li> </ul>"},{"location":"platform-development/learning-path/","title":"Learning &amp; Contribution Path","text":"<p>Welcome to the Xians AI Platform development journey! Follow this structured path to become proficient in building AI agents and contributing to the platform.</p>"},{"location":"platform-development/learning-path/#phase-1-explore-and-learn","title":"\ud83c\udf93 Phase 1: Explore and Learn","text":""},{"location":"platform-development/learning-path/#get-started-with-the-platform","title":"Get Started with the Platform","text":"<ul> <li> 1.1 Login to agentri.ai (hosted version of Xians.AI platform)</li> <li> 1.2 Join the existing tenant 99x and request admin approval</li> <li> 1.3 Read Why Xians Platform to understand how AI agents differ from conventional software</li> <li> 1.4 Review the complete documentation to understand how Xians.AI helps developers build AI Agent systems</li> </ul>"},{"location":"platform-development/learning-path/#make-your-first-contribution","title":"Make Your First Contribution","text":"<ul> <li> 1.5 Send a PR to the documentation repository to improve documentation</li> </ul>"},{"location":"platform-development/learning-path/#phase-2-setting-up-development-environment","title":"\ud83d\udee0\ufe0f Phase 2: Setting Up Development Environment","text":"<ul> <li> 2.1 Set up Xians Community Edition locally on your machine</li> <li> 2.2 Verify your local setup is working correctly</li> </ul>"},{"location":"platform-development/learning-path/#phase-3-simple-agent-development","title":"\ud83e\udd16 Phase 3: Simple Agent Development","text":"<p>Build your first agents and learn core concepts:</p>"},{"location":"platform-development/learning-path/#basic-chat-agent","title":"Basic Chat Agent","text":"<ul> <li> 3.1 Develop a simple chat agent</li> <li> 3.2 Test and verify the agent responds correctly</li> </ul>"},{"location":"platform-development/learning-path/#add-functionality","title":"Add Functionality","text":"<ul> <li> 3.3 Add Capabilities to your agent</li> <li> 3.4 Integrate MCPs (Model Context Protocol) into your agent</li> </ul>"},{"location":"platform-development/learning-path/#workflow-automation","title":"Workflow Automation","text":"<ul> <li> 3.5 Create a Deterministic Workflow for your agent</li> <li> 3.6 Schedule the deterministic flow for automated execution</li> </ul>"},{"location":"platform-development/learning-path/#phase-4-agent-teams","title":"\ud83d\udc65 Phase 4: Agent Teams","text":"<p>Learn to build multi-agent systems:</p> <ul> <li> 4.1 Study an Agent team implementation such as Percy (Internal Repo)</li> <li> 4.2 Implement an Agent with Agent2Agent communication in a multi-agent team setup</li> <li> 4.3 Build a SuperAgent (Team Lead) that can:</li> <li>Discuss with users to understand requirements</li> <li>Create automations dynamically</li> <li>Coordinate with other agents (reference Percy's SuperAgent implementation)</li> </ul>"},{"location":"platform-development/learning-path/#phase-5-platform-development","title":"\ud83d\udd27 Phase 5: Platform Development","text":"<p>Contribute to the core platform:</p>"},{"location":"platform-development/learning-path/#setup-core-repositories","title":"Setup Core Repositories","text":"<ul> <li> 5.1 Clone and set up the following repositories locally:</li> <li>XiansAi.Server</li> <li>XiansAi.UI</li> <li>XiansAi.Lib</li> <li> 5.2 Configure your existing agent development projects to use the local Lib and Server</li> </ul>"},{"location":"platform-development/learning-path/#contribute-to-platform","title":"Contribute to Platform","text":"<ul> <li> 5.3 Make improvements to the platform repositories (e.g., unit tests, UI enhancements)</li> <li> 5.4 Test your changes thoroughly</li> <li> 5.5 Submit a Pull Request with your improvements</li> </ul>"},{"location":"platform-development/learning-path/#join-platform-development","title":"Join Platform Development","text":"<ul> <li> 5.6 Review tasks in the XiansAI Platform project board. Pick up a task and contribute to platform development</li> </ul>"},{"location":"platform-development/learning-path/#next-steps","title":"\ud83c\udfaf Next Steps","text":"<p>After completing this learning path, you'll be ready to:</p> <ul> <li>Build production-ready AI agents</li> <li>Contribute to the Xians AI Platform</li> <li>Help others in their learning journey</li> <li>Design and implement complex multi-agent systems</li> </ul> <p>Happy coding! \ud83d\ude80</p>"},{"location":"platform-development/setup/","title":"Developer Guide - Agentic AI","text":"<p>This guide provides step-by-step instructions to set up and run the Agentic AI platform. Follow the steps below to clone the repositories, configure the server, and set up the UI.</p>"},{"location":"platform-development/setup/#1-clone-the-repositories","title":"1. Clone the Repositories","text":"<p>To begin, clone the following three repositories from GitHub:</p> <ol> <li> <p>XiansAI.Server    Repository URL: https://github.com/XiansAiPlatform/XiansAi.Server.git    Command to clone:    <pre><code>git clone https://github.com/XiansAiPlatform/XiansAi.Server.git\n</code></pre></p> </li> <li> <p>XiansAI.Lib    Repository URL: https://github.com/XiansAiPlatform/XiansAi.Lib.git    Command to clone:    <pre><code>git clone https://github.com/XiansAiPlatform/XiansAi.Lib.git\n</code></pre></p> </li> <li> <p>XiansAI.UI    Repository URL: https://github.com/XiansAiPlatform/XiansAi.UI.git    Command to clone:    <pre><code>git clone https://github.com/XiansAiPlatform/XiansAi.UI.git\n</code></pre></p> </li> </ol>"},{"location":"platform-development/setup/#2-setting-up-the-server","title":"2. Setting Up the Server","text":"<p>To configure and run the server, follow these steps:</p> <ol> <li> <p>Obtain Configuration Files</p> <p>Request the <code>appsettings.json</code> and <code>appsettings.Development.json</code> files from a team member. These files contain the necessary configuration settings for the server.</p> </li> <li> <p>Place Configuration Files</p> <p>Copy the <code>appsettings.json</code> and <code>appsettings.Development.json</code> files into the <code>src</code> folder of the <code>XiansAI.Server</code> repository.</p> <p>Example path: <pre><code>XiansAI.Server/src/\n</code></pre></p> </li> <li> <p>Run the Server</p> <p>Follow the specific instructions provided in the <code>XiansAI.Server</code> repository's README file to build and run the server.</p> </li> </ol>"},{"location":"platform-development/setup/#3-setting-up-the-ui","title":"3. Setting Up the UI","text":"<p>To configure and run the UI, follow these steps:</p> <ol> <li> <p>Create a <code>.env</code> File </p> <ul> <li>Navigate to the root directory of the <code>XiansAI.UI</code> repository.  </li> <li>Create a new file named <code>.env</code>.</li> </ul> </li> <li> <p>Copy Environment Variables </p> <ul> <li>Open the <code>XiansAI.UI</code> repository and locate the <code>.env.development</code> file.  </li> <li>Copy the contents of the <code>.env.development</code> file into the newly created <code>.env</code> file.</li> </ul> </li> <li> <p>Install Dependencies </p> <ul> <li>Run the following command to install all required dependencies:   <pre><code>npm install\n</code></pre></li> </ul> </li> <li> <p>Start the UI </p> <ul> <li> <p>Start the development server by running:   <pre><code>npm start\n</code></pre></p> </li> <li> <p>The UI should now be accessible in your browser. The default URL is typically <code>http://localhost:3000</code>, but refer to the project documentation for confirmation.</p> </li> </ul> </li> </ol>"},{"location":"platform-development/setup/#4-setting-up-the-library-xiansailib","title":"4. Setting Up the Library (XiansAI.Lib)","text":"<p>To configure and use the <code>XiansAI.Lib</code> library, follow these steps:</p> <ol> <li> <p>Run the Library </p> <ul> <li>After cloning the <code>XiansAI.Lib</code> repository, navigate to its root directory and run the following command to build and execute the library in release mode:   <pre><code>dotnet run -c Release\n</code></pre></li> </ul> </li> <li> <p>Making Changes to the Library </p> <ul> <li>If you make any changes to the <code>XiansAI.Lib</code> codebase, you need to update its reference in the agent's package dependency list:</li> <li>Locate the <code>.csproj</code> file of the <code>XiansAI.Lib</code> project.</li> <li>Copy the file path of the <code>.csproj</code> file.</li> <li>Update the agent's package dependency list to reference the updated <code>.csproj</code> file location.</li> </ul> <p>Example of referencing the <code>.csproj</code> file in another project:   <pre><code>&lt;ProjectReference Include=\"path/to/XiansAI.Lib.csproj\" /&gt;\n</code></pre></p> </li> <li> <p>Rebuild the Dependent Project </p> <ul> <li>After updating the reference, rebuild the dependent project to ensure the changes in the library are applied.</li> </ul> </li> </ol>"},{"location":"platform-development/setup/#notes","title":"Notes","text":"<ul> <li>Ensure you have the required versions of .NET SDK installed on your system before setting up the library. Refer to the <code>XiansAI.Lib</code> repository's README for version requirements.</li> <li>For the server and library, ensure you have the necessary runtime environment (e.g., .NET Core) installed. Check the respective repositories for specific prerequisites.</li> <li>If you encounter any issues during setup, consult the respective repository's documentation or reach out to your team for assistance.</li> </ul> <p>By following these steps, you should be able to successfully set up and run the Agentic AI platform.</p>"}]}